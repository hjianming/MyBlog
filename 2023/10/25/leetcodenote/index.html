<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>leetcode日记 | HUANGjm 's blog</title><meta name="author" content="HUANG jm"><meta name="copyright" content="HUANG jm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数组数组算法技巧分类：  双指针 左右指针 快慢指针   前缀和数组 差分数组 花式遍历(过程模拟) 滑动窗口 二分查找 常数时间删除&#x2F;查找元素  双指针技巧秒杀七道数组题目读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：    LeetCode 力扣 难度    167. Two Sum II - Input Array Is Sorted 167. 两数之和 II - 输入有">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode日记">
<meta property="og:url" content="https://huangjm0508.gitee.io/2023/10/25/leetcodenote/index.html">
<meta property="og:site_name" content="HUANGjm &#39;s blog">
<meta property="og:description" content="数组数组算法技巧分类：  双指针 左右指针 快慢指针   前缀和数组 差分数组 花式遍历(过程模拟) 滑动窗口 二分查找 常数时间删除&#x2F;查找元素  双指针技巧秒杀七道数组题目读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：    LeetCode 力扣 难度    167. Two Sum II - Input Array Is Sorted 167. 两数之和 II - 输入有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img0.baidu.com/it/u=2515196433,1042495811&fm=253&fmt=auto&app=138&f=JPG?w=400&h=230">
<meta property="article:published_time" content="2023-10-25T07:11:57.000Z">
<meta property="article:modified_time" content="2023-11-23T06:56:28.657Z">
<meta property="article:author" content="HUANG jm">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img0.baidu.com/it/u=2515196433,1042495811&fm=253&fmt=auto&app=138&f=JPG?w=400&h=230"><link rel="shortcut icon" href="/master/img/favicon.png"><link rel="canonical" href="https://huangjm0508.gitee.io/2023/10/25/leetcodenote/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/master/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/master/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'leetcode日记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-23 14:56:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/master/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/master/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/master/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/master/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/master/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/master/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/master/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/master/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/master/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/master/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/master/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/master/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/master/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img0.baidu.com/it/u=2515196433,1042495811&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=400&amp;h=230')"><nav id="nav"><span id="blog-info"><a href="/master/" title="HUANGjm 's blog"><span class="site-name">HUANGjm 's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/master/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/master/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/master/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/master/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/master/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/master/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/master/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/master/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/master/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/master/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">leetcode日记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-25T07:11:57.000Z" title="发表于 2023-10-25 15:11:57">2023-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-23T06:56:28.657Z" title="更新于 2023-11-23 14:56:28">2023-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/master/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="leetcode日记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组算法技巧分类：</p>
<ol>
<li>双指针<ul>
<li>左右指针</li>
<li>快慢指针</li>
</ul>
</li>
<li>前缀和数组</li>
<li>差分数组</li>
<li>花式遍历(过程模拟)</li>
<li>滑动窗口</li>
<li>二分查找</li>
<li>常数时间删除&#x2F;查找元素</li>
</ol>
<h2 id="双指针技巧秒杀七道数组题目"><a href="#双指针技巧秒杀七道数组题目" class="headerlink" title="双指针技巧秒杀七道数组题目"></a>双指针技巧秒杀七道数组题目</h2><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p>
<table>
<thead>
<tr>
<th align="center">LeetCode</th>
<th align="center">力扣</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">167. Two Sum II - Input Array Is Sorted</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-element/">27. Remove Element</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/move-zeroes/">283. Move Zeroes</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-string/">344. Reverse String</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates from Sorted List</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kLl5u1/">剑指 Offer II 006. 排序数组中两个数字之和</a></td>
<td align="center">🟢</td>
</tr>
</tbody></table>
<p>在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：<strong>左右指针</strong>和<strong>快慢指针</strong>。</p>
<p>所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行，一快一慢。</p>
<p>对于单链表来说，大部分技巧都属于快慢指针，前文 <a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/shuang-zhi-0f7cc/">单链表的六大解题套路</a> 都涵盖了，比如链表环判断，倒数第 <code>K</code> 个链表节点等问题，它们都是通过一个 <code>fast</code> 快指针和一个 <code>slow</code> 慢指针配合完成任务。</p>
<p>在数组中并没有真正意义上的指针，但我们可以把索引当做数组中的指针，这样也可以在数组中施展双指针技巧，<strong>本文主要讲数组相关的双指针算法</strong>。</p>
<h3 id="快慢指针技巧"><a href="#快慢指针技巧" class="headerlink" title="快慢指针技巧"></a>快慢指针技巧</h3><p><strong>数组问题中比较常见的快慢指针技巧，是让你原地修改数组</strong>。</p>
<p>比如说看下力扣第 26 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a>」，让你在有序数组去重：</p>
<blockquote>
<p>原地修改：</p>
<p>原地删除，不允许 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。如果不是原地修改的话，我们直接 new 一个 <code>int[]</code> 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。</p>
</blockquote>
<p>由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。但如果毎找到一个重复元素就立即原地删除它，由于数组中删除元素涉及数据搬移，整个时间复杂度是会达到 <code>O(N^2)</code>。</p>
<p>高效解决这道题就要用到快慢指针技巧：</p>
<p>我们让慢指针 <code>slow</code> 走在后面，快指针 <code>fast</code> 走在前面探路，找到一个不重复的元素就赋值给 <code>slow</code> 并让 <code>slow</code> 前进一步。</p>
<p>这样，就保证了 <code>nums[0..slow]</code> 都是无重复的元素，当 <code>fast</code> 指针遍历完整个数组 <code>nums</code> 后，<code>nums[0..slow]</code> 就是整个数组去重之后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] 无重复</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组长度为索引 + 1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再简单扩展一下，看看力扣第 83 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a>」，如果给你一个有序的单链表，如何去重呢？</p>
<p>其实和数组去重是一模一样的，唯一的区别是把数组赋值操作变成操作指针而已。</p>
<p><strong>除了让你在有序数组&#x2F;链表中去重，题目还可能让你对数组中的某些元素进行「原地删除」</strong>。</p>
<p>比如力扣第 27 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">移除元素</a>」</p>
<h3 id="左右指针的常用算法"><a href="#左右指针的常用算法" class="headerlink" title="左右指针的常用算法"></a>左右指针的常用算法</h3><p><strong>1、二分查找</strong></p>
<p>在另一篇文章 <a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-xie-le--3c789/">二分查找框架详解</a> 中有详细探讨二分搜索代码的细节问题，这里只写最简单的二分算法，旨在突出它的双指针特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、两数之和</strong></p>
<p>看下力扣第 167 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和 II</a>」：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="comment">// 题目要求的索引是从 1 开始的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++; <span class="comment">// 让 sum 大一点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--; <span class="comment">// 让 sum 小一点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、反转数组</strong></p>
<p>一般编程语言都会提供 <code>reverse</code> 函数，其实这个函数的原理非常简单，力扣第 344 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">反转字符串</a>」就是类似的需求，让你反转一个 <code>char[]</code> 类型的字符数组，我们直接看代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 交换 s[left] 和 s[right]</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、回文串判断</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那接下来我提升一点难度，给你一个字符串，让你用双指针技巧从中找出最长的回文串，你会做吗？</p>
<p>这就是力扣第 5 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a>」：</p>
<p>找回文串的难点在于，回文串的的长度可能是奇数也可能是偶数，解决该问题的核心是<strong>从中心向两端扩散的双指针技巧</strong>。</p>
<p>如果回文串的长度为奇数，则它有一个中心字符；如果回文串的长度为偶数，则可以认为它有两个中心字符。所以我们可以先实现这样一个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">String <span class="title function_">palindrome</span><span class="params">(String s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 防止索引越界</span></span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length()</span><br><span class="line">           <span class="comment">//注意这里的l &gt;= 0, 防止</span></span><br><span class="line">            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">        <span class="comment">// 双指针，向两边展开</span></span><br><span class="line">        l--; r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(l + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果输入相同的 <code>l</code> 和 <code>r</code>，就相当于寻找长度为奇数的回文串，如果输入相邻的 <code>l</code> 和 <code>r</code>，则相当于寻找长度为偶数的回文串。</p>
<p>那么回到最长回文串的问题，解法的大致思路就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; len(s):</span><br><span class="line">    找到以 s[i] 为中心的回文串</span><br><span class="line">    找到以 s[i] 和 s[i+<span class="number">1</span>] 为中心的回文串</span><br><span class="line">    更新答案</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>翻译成代码，就可以解决最长回文子串这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 以 s[i] 为中心的最长回文子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> palindrome(s, i, i);</span><br><span class="line">        <span class="comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> palindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// res = longest(res, s1, s2)</span></span><br><span class="line">        res = res.length() &gt; s1.length() ? res : s1;</span><br><span class="line">        res = res.length() &gt; s2.length() ? res : s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小而美的算法技巧-前缀和数组"><a href="#小而美的算法技巧-前缀和数组" class="headerlink" title="小而美的算法技巧:前缀和数组"></a>小而美的算法技巧:前缀和数组</h2><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p>
<table>
<thead>
<tr>
<th align="center">LeetCode</th>
<th align="center">力扣</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-sum-query-immutable/">303. Range Sum Query - Immutable</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-sum-query-2d-immutable/">304. Range Sum Query 2D - Immutable</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/O4NDxx/">剑指 Offer II 013. 二维子矩阵的和</a></td>
<td align="center">🟠</td>
</tr>
</tbody></table>
<p>前缀和技巧适用于快速、频繁地计算一个<u>索引区间内的元素之和</u>。</p>
<h3 id="一维数组的前缀和"><a href="#一维数组的前缀和" class="headerlink" title="一维数组的前缀和"></a>一维数组的前缀和</h3><p>先看一道例题，力扣第 303 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-immutable/">区域和检索 - 数组不可变</a>」，让你计算数组区间内元素的和，这是一道标准的前缀和问题：</p>
<p><code>sumRange</code> 函数需要计算并返回一个索引区间之内的元素和，没学过前缀和的人可能写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            res += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，可以达到效果，但是效率很差，因为 <code>sumRange</code> 方法会被频繁调用，而它的时间复杂度是 <code>O(N)</code>，其中 <code>N</code> 代表 <code>nums</code> 数组的长度。</p>
<p>这道题的最优解法是使用前缀和技巧，将 <code>sumRange</code> 函数的时间复杂度降为 <code>O(1)</code>，说白了就是不要在 <code>sumRange</code> 里面用 for 循环，咋整？</p>
<p>直接看代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="comment">// 前缀和数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输入一个数组，构造前缀和 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/master/2023/10/25/leetcodenote/1.jpeg"></p>
<p>看这个 <code>preSum</code> 数组，如果我想求索引区间 <code>[1, 4]</code> 内的所有元素之和，就可以通过 <code>preSum[5] - preSum[1]</code> 得出。</p>
<p>这样，<code>sumRange</code> 函数仅仅需要做一次减法运算，避免了每次进行 for 循环调用，最坏时间复杂度为常数 <code>O(1)</code>。</p>
<p>接下来，我们看一看前缀和思路在二维数组中如何运用。</p>
<h3 id="二维数组的前缀和"><a href="#二维数组的前缀和" class="headerlink" title="二维数组的前缀和"></a>二维数组的前缀和</h3><p>这是力扣第 304 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">二维区域和检索 - 矩阵不可变</a>」，其实和上一题类似，上一题是让你计算子数组的元素之和，这道题让你计算二维矩阵中子矩阵的元素之和：</p>
<p>当然，你可以用一个嵌套 for 循环去遍历这个矩阵，但这样的话 <code>sumRegion</code> 函数的时间复杂度就高了，你算法的格局就低了。</p>
<p>注意任意子矩阵的元素和可以转化成它周边几个大矩阵的元素和的运算：</p>
<p><img src="/master/2023/10/25/leetcodenote/2.jpeg"></p>
<p>而这四个大矩阵有一个共同的特点，就是左上角都是 <code>(0, 0)</code> 原点。</p>
<p>那么做这道题更好的思路和一维数组中的前缀和是非常类似的，我们可以维护一个二维 <code>preSum</code> 数组，专门记录以原点为顶点的矩阵的元素之和，就可以用几次加减运算算出任何一个子矩阵的元素和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[matrix.length + <span class="number">1</span>][matrix[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; preSum.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; preSum[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                preSum[i][j] = preSum[i - <span class="number">1</span>][j] + preSum[i][j - <span class="number">1</span>] - preSum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - preSum[row2 + <span class="number">1</span>][col1] - preSum[row1][col2 + <span class="number">1</span>] + preSum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>sumRegion</code> 函数的时间复杂度也用前缀和技巧优化到了 O(1)，这是典型的「空间换时间」思路。</p>
<p>前缀和技巧就讲到这里，应该说这个算法技巧是会者不难难者不会，实际运用中还是要多培养自己的思维灵活性，做到一眼看出题目是一个前缀和问题。</p>
<p>除了本文举例的基本用法，前缀和数组经常和其他数据结构或算法技巧相结合，我会在 <a target="_blank" rel="noopener" href="https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_627cd61de4b0cedf38b0f3a0/1">前缀和技巧高频习题</a> 中举例讲解。</p>
<h2 id="小而美的算法技巧-差分数组"><a href="#小而美的算法技巧-差分数组" class="headerlink" title="小而美的算法技巧:差分数组"></a>小而美的算法技巧:差分数组</h2><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p>
<table>
<thead>
<tr>
<th align="center">LeetCode</th>
<th align="center">力扣</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/car-pooling/">1094. Car Pooling</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/car-pooling/">1094. 拼车</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/corporate-flight-bookings/">1109. Corporate Flight Bookings</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-addition/">370. Range Addition</a>🔒</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-addition/">370. 区间加法</a>🔒</td>
<td align="center">🟠</td>
</tr>
</tbody></table>
<p><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。本文讲一个和前缀和思想非常类似的算法技巧<strong>「差分数组」</strong>，<strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。</p>
<p>比如说，我给你输入一个数组 <code>nums</code>，然后又要求给区间 <code>nums[2..6]</code> 全部加 1，再给 <code>nums[3..9]</code> 全部减 3，再给 <code>nums[0..4]</code> 全部加 2，再给…</p>
<p>一通操作猛如虎，然后问你，最后 <code>nums</code> 数组的值是什么？</p>
<p>常规的思路很容易，你让我给区间 <code>nums[i..j]</code> 加上 <code>val</code>，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对 <code>nums</code> 的修改非常频繁，所以效率会很低下。</p>
<p>这里就需要差分数组的技巧，类似前缀和技巧构造的 <code>preSum</code> 数组，我们先对 <code>nums</code> 数组构造一个 <code>diff</code> 差分数组，**<code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 之差**：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这样构造差分数组 <code>diff</code>，就可以快速进行区间增减的操作</strong>，如果你想对区间 <code>nums[i..j]</code> 的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让 <code>diff[j+1] -= 3</code> 即可：</p>
<p><strong>原理很简单，回想 <code>diff</code> 数组反推 <code>nums</code> 数组的过程，<code>diff[i] += 3</code> 意味着给 <code>nums[i..]</code> 所有的元素都加了 3，然后 <code>diff[j+1] -= 3</code> 又意味着对于 <code>nums[j+1..]</code> 所有元素再减 3，那综合起来，是不是就是对 <code>nums[i..j]</code> 中的所有元素都加 3 了</strong>？</p>
<p>只要花费 O(1) 的时间修改 <code>diff</code> 数组，就相当于给 <code>nums</code> 的整个区间做了修改。多次修改 <code>diff</code>，然后通过 <code>diff</code> 数组反推，即可得到 <code>nums</code> 修改后的结果。</p>
<p>现在我们把差分数组抽象成一个类，包含 <code>increment</code> 方法和 <code>result</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">    <span class="comment">// 差分数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] diff;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 输入一个初始数组，区间操作将在这个数组上进行 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 给闭区间 [i, j] 增加 val（可以是负数）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">            <span class="comment">//如果j+1 &gt;= diff.length，说明是对 `nums[i]` 及以后的整个数组都进行修改，</span></span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回结果数组 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">        <span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法实践</p>
<p>首先，力扣第 370 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-addition/">区间加法</a>」 就直接考察了差分数组技巧：</p>
<p>当然，实际的算法题可能需要我们对题目进行联想和抽象，不会这么直接地让你看出来要用差分数组技巧，这里看一下力扣第 1109 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/corporate-flight-bookings/">航班预订统计</a>」：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bookings.length; i++)&#123;</span><br><span class="line">            diff[bookings[i][<span class="number">0</span>] - <span class="number">1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(bookings[i][<span class="number">1</span>] &lt; n)&#123;</span><br><span class="line">                diff[bookings[i][<span class="number">1</span>]] -= bookings[i][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            diff[i] = diff[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="花式遍历-过程模拟"><a href="#花式遍历-过程模拟" class="headerlink" title="花式遍历(过程模拟)"></a>花式遍历(过程模拟)</h2><h3 id="顺-x2F-逆时针旋转矩阵"><a href="#顺-x2F-逆时针旋转矩阵" class="headerlink" title="顺&#x2F;逆时针旋转矩阵"></a>顺&#x2F;逆时针旋转矩阵</h3><p>对二维数组进行旋转是常见的笔试题，力扣第 48 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">旋转图像</a>」就是很经典的一道：</p>
<p>如何「原地」旋转二维矩阵？稍想一下，感觉操作起来非常复杂，可能要设置巧妙的算法机制来「一圈一圈」旋转矩阵：</p>
<p><strong>但实际上，这道题不能走寻常路</strong>，在讲巧妙解法之前，我们先看另一道谷歌曾经考过的算法题热热身：</p>
<p>给你一个包含若干单词和空格的字符串 <code>s</code>，请你写一个算法，<strong>原地</strong>反转所有单词的顺序。</p>
<p>比如说，给你输入这样一个字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world labuladong&quot;</span></span><br></pre></td></tr></table></figure>

<p>你的算法需要<strong>原地</strong>反转这个字符串中的单词顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;labuladong world hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>常规的方式是把 <code>s</code> 按空格 <code>split</code> 成若干单词，然后 <code>reverse</code> 这些单词的顺序，最后把这些单词 <code>join</code> 成句子。但这种方式使用了额外的空间，并不是「原地反转」单词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;gnodalubal dlrow olleh&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>然后将每个单词分别反转</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;labuladong world hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样，就实现了原地反转所有单词顺序的目的。力扣第 151 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">颠倒字符串中的单词</a>」就是类似的问题，你可以顺便去做一下。</p>
<p>我讲这道题的目的是什么呢？</p>
<p><strong>旨在说明，有时候咱们拍脑袋的常规思维，在计算机看来可能并不是最优雅的；但是计算机觉得最优雅的思维，对咱们来说却不那么直观</strong>。也许这就是算法的魅力所在吧。</p>
<p>回到之前说的顺时针旋转二维矩阵的问题，常规的思路就是去寻找原始坐标和旋转后坐标的映射规律，但我们是否可以让思维跳跃跳跃，尝试把矩阵进行反转、镜像对称等操作，可能会出现新的突破口。</p>
<p><strong>我们可以先将 <code>n x n</code> 矩阵 <code>matrix</code> 按照左上到右下的对角线进行镜像对称</strong>：</p>
<p><img src="/master/2023/10/25/leetcodenote/%5C3.jpeg"></p>
<p><img src="/master/2023/10/25/leetcodenote/%5C4.jpeg"></p>
<p><strong>发现结果就是 <code>matrix</code> 顺时针旋转 90 度的结果</strong>：</p>
<p>将上述思路翻译成代码，即可解决本题：</p>
<p><img src="/master/2023/10/25/leetcodenote/%5C5.jpeg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">       <span class="comment">//1.先将矩阵置换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="comment">//for(int j = i; j &lt; matrix[0].length; j++)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.再将矩阵左右对称</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][matrix[<span class="number">0</span>].length - j - <span class="number">1</span>];</span><br><span class="line">                matrix[i][matrix[<span class="number">0</span>].length - j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵的螺旋遍历"><a href="#矩阵的螺旋遍历" class="headerlink" title="矩阵的螺旋遍历"></a>矩阵的螺旋遍历</h3><p>接下来我们讲一下力扣第 54 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵</a>」，看一看二维矩阵可以如何花式遍历：</p>
<p><strong>解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界</strong>：</p>
<p><img src="/master/2023/10/25/leetcodenote/%5C6.jpg"></p>
<p>随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组：</p>
<p>只要有了这个思路，翻译出代码就很容易了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">upper_bound</span> <span class="operator">=</span> <span class="number">0</span>, lower_bound = m - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left_bound</span> <span class="operator">=</span> <span class="number">0</span>, right_bound = n - <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// res.size() == m * n 则遍历完整个数组</span></span><br><span class="line">    <span class="keyword">while</span> (res.size() &lt; m * n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (upper_bound &lt;= lower_bound) &#123;</span><br><span class="line">            <span class="comment">// 在顶部从左向右遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left_bound; j &lt;= right_bound; j++) &#123;</span><br><span class="line">                res.add(matrix[upper_bound][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上边界下移</span></span><br><span class="line">            upper_bound++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left_bound &lt;= right_bound) &#123;</span><br><span class="line">            <span class="comment">// 在右侧从上向下遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> upper_bound; i &lt;= lower_bound; i++) &#123;</span><br><span class="line">                res.add(matrix[i][right_bound]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右边界左移</span></span><br><span class="line">            right_bound--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (upper_bound &lt;= lower_bound) &#123;</span><br><span class="line">            <span class="comment">// 在底部从右向左遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right_bound; j &gt;= left_bound; j--) &#123;</span><br><span class="line">                res.add(matrix[lower_bound][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下边界上移</span></span><br><span class="line">            lower_bound--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left_bound &lt;= right_bound) &#123;</span><br><span class="line">            <span class="comment">// 在左侧从下向上遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lower_bound; i &gt;= upper_bound; i--) &#123;</span><br><span class="line">                res.add(matrix[i][left_bound]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左边界右移</span></span><br><span class="line">            left_bound++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这题和力扣第 59 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵 II</a>」不一样，因为这题矩阵有可能是长方型的，所以我们在执行循环的时候，得先判断边距，比如，从上往下走时，左右边距得大于1，从左往下走时，上下边距得大于1。</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p>
<table>
<thead>
<tr>
<th align="center">LeetCode</th>
<th align="center">力扣</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutation-in-string/">567. Permutation in String</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></td>
<td align="center">🔴</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/MPnaiL/">剑指 Offer II 014. 字符串中的变位词</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/VabMRr/">剑指 Offer II 015. 字符串中的所有变位词</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wtcaE1/">剑指 Offer II 016. 不含重复字符的最长子字符串</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/M1oyTv/">剑指 Offer II 017. 含有所有字符的最短字符串</a></td>
<td align="center">🔴</td>
</tr>
</tbody></table>
<p>关于双指针的快慢指针和左右指针的用法，可以参见前文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/shuang-zhi-fa4bd/">双指针技巧汇总</a>，本文就解决一类最难掌握的双指针技巧：滑动窗口技巧。总结出一套框架，可以保你闭着眼睛都能写出正确的解法。</p>
<p>说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。</p>
<p>其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。</p>
<p><strong>所以今天我就写一套滑动窗口算法的代码框架，我连再哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出 bug</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="comment">//初始化窗口为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line">		<span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，虽然滑动窗口代码框架中有一个嵌套的 while 循环，但算法的时间复杂度依然是 <code>O(N)</code>，其中 <code>N</code> 是输入字符串&#x2F;数组的长度。</p>
<p>为什么呢？简单说，指针 <code>left, right</code> 不会回退（它们的值只增不减），所以字符串&#x2F;数组中的每个元素都只会进入窗口一次，然后被移出窗口一次，不会说有某些元素多次进入和离开窗口，所以算法的时间复杂度就和字符串&#x2F;数组的长度成正比。后文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/suan-fa-sh-05f25/">算法时空复杂度分析实用指南</a> 有具体讲时间复杂度的估算，这里就不展开了。</p>
<p>言归正传，下面就直接上<strong>四道</strong>力扣原题来套这个框架，其中第一道题会详细说明其原理，后面四道就直接闭眼睛秒杀了。</p>
<p>因为滑动窗口很多时候都是在处理字符串相关的问题，而 Java 处理字符串不方便，所以本文代码为 C++ 实现。不会用到什么特定的编程语言技巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：</p>
<p><code>unorder	ed_map</code> 就是哈希表（字典），相当于 Java 的 <code>HashMap</code>，它的一个方法 <code>count(key)</code> 相当于 Java 的 <code>containsKey(key)</code> 可以判断键 key 是否存在。</p>
<p>可以使用方括号访问键对应的值 <code>map[key]</code>。需要注意的是，如果该 <code>key</code> 不存在，C++ 会自动创建这个 key，并把 <code>map[key]</code> 赋值为 0。所以代码中多次出现的 <code>map[key]++</code> 相当于 Java 的 <code>map.put(key, map.getOrDefault(key, 0) + 1)</code>。</p>
<p>另外，Java 中的 Integer 和 String 这种包装类不能直接用 <code>==</code> 进行相等判断，而应该使用类的 <code>equals</code> 方法，这个语言特性坑了不少读者，在代码部分我会给出具体提示。</p>
<h3 id="一、最小覆盖子串"><a href="#一、最小覆盖子串" class="headerlink" title="一、最小覆盖子串"></a>一、最小覆盖子串</h3><p>先来看看力扣第 76 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>」难度 Hard：</p>
<p><strong>滑动窗口算法的思路是这样</strong>：</p>
<p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p>
<blockquote>
<p>Tip</p>
<p>理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 <code>left = right = 0</code> 时区间 <code>[0, 0)</code> 中没有元素，但只要让 <code>right</code> 向右移动（扩大）一位，区间 <code>[0, 1)</code> 就包含一个元素 <code>0</code> 了。如果你设置为两端都开的区间，那么让 <code>right</code> 向右移动一位后开区间 <code>(0, 1)</code> 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 <code>[0, 0]</code> 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</p>
</blockquote>
<p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p>
<p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，<code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 <code>T</code> 中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录窗口内的有效字符是否覆盖了子串t</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vaild</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need.put(t.charAt(i), need.getOrDefault(t.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">                window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (window.get(c).equals(need.get(c))) vaild++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (vaild == need.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(d).equals(need.get(d))) vaild--;</span><br><span class="line">                    window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、字符串排列"><a href="#二、字符串排列" class="headerlink" title="二、字符串排列"></a>二、字符串排列</h3><p>这是力扣第 567 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a>」，难度中等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 cpp 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String t, String s)</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c)))</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.length()) &#123;</span><br><span class="line">            <span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d)))</span><br><span class="line">                    valid--;</span><br><span class="line">                window.put(d, window.getOrDefault(d, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到符合条件的子串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、找所有字母异位词"><a href="#三、找所有字母异位词" class="headerlink" title="三、找所有字母异位词"></a>三、找所有字母异位词</h3><p>这是力扣第 438 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a>」，难度中等：</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>本文探索几个最差管用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，<code>mid</code>是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p>
<p>另外再声明一下，对于二分搜索的每一个场景，本文还会探讨多种代码写法，目的是为了让你理解出现这些细微差异的本质原因，最起码你看到别人的代码时不会懵逼。实际上这些写法没有优劣之分，你喜欢哪种就用哪种好了。</p>
<h3 id="零、二分查找框架"><a href="#零、二分查找框架" class="headerlink" title="#零、二分查找框架"></a><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/wo-xie-le--9c7a4/#%E9%9B%B6%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6">#</a>零、二分查找框架</h3><p><strong>左闭右闭 [ left, right ]</strong></p>
<table>
<thead>
<tr>
<th align="center">条件\问题</th>
<th align="center">寻找一个数</th>
<th align="center">寻找左侧边界</th>
<th align="center">寻找右侧边界</th>
</tr>
</thead>
<tbody><tr>
<td align="center">初始化</td>
<td align="center">right &#x3D; nums.length - 1</td>
<td align="center">right &#x3D; nums.length - 1</td>
<td align="center">right &#x3D; nums.length - 1</td>
</tr>
<tr>
<td align="center">结束条件</td>
<td align="center">while(left &lt;&#x3D; right)</td>
<td align="center">right &#x3D; nums.length - 1</td>
<td align="center">right &#x3D; nums.length - 1</td>
</tr>
<tr>
<td align="center">递推条件</td>
<td align="center">left &#x3D; mid + 1; right &#x3D; mid - 1</td>
<td align="center">left &#x3D; mid + 1; right &#x3D; mid - 1</td>
<td align="center">left &#x3D; mid + 1; right &#x3D; mid - 1</td>
</tr>
<tr>
<td align="center">找到时</td>
<td align="center">if (nums[mid] &#x3D;&#x3D; target)<br>    return mid;</td>
<td align="center">if (nums[mid] &#x3D;&#x3D; target)<br>    right &#x3D; mid - 1;</td>
<td align="center">if (nums[mid] &#x3D;&#x3D; target)<br>      left &#x3D; mid + 1;</td>
</tr>
<tr>
<td align="center">最终返回</td>
<td align="center">return -1</td>
<td align="center">return nums[left] &#x3D;&#x3D; target ? left : -1;</td>
<td align="center">return nums[right] &#x3D;&#x3D; target ? right : -1;</td>
</tr>
</tbody></table>
<p><strong>左闭右开 [ left, right )</strong></p>
<table>
<thead>
<tr>
<th align="center">条件\问题</th>
<th align="center">寻找一个数</th>
<th align="center">寻找左侧边界</th>
<th align="center">寻找右侧边界</th>
</tr>
</thead>
<tbody><tr>
<td align="center">初始化</td>
<td align="center">right &#x3D; nums.length</td>
<td align="center">right &#x3D; nums.length</td>
<td align="center">right &#x3D; nums.length</td>
</tr>
<tr>
<td align="center">结束条件</td>
<td align="center">while(left &lt; right)</td>
<td align="center">while(left &lt; right)</td>
<td align="center">while(left &lt; right)</td>
</tr>
<tr>
<td align="center">递推条件</td>
<td align="center">left &#x3D; mid + 1; right &#x3D; mid</td>
<td align="center">left &#x3D; mid + 1; right &#x3D; mid</td>
<td align="center">left &#x3D; mid + 1; right &#x3D; mid</td>
</tr>
<tr>
<td align="center">找到时</td>
<td align="center">if (nums[mid] &#x3D;&#x3D; target)<br>     right &#x3D; mid;</td>
<td align="center">if(nums[mid] &#x3D;&#x3D; target)<br>right &#x3D; mid;</td>
<td align="center">if(nums[mid] &#x3D;&#x3D; target)<br>left &#x3D; mid + 1;</td>
</tr>
<tr>
<td align="center">返回</td>
<td align="center">return -1;</td>
<td align="center">return left;</td>
<td align="center">return left - 1;</td>
</tr>
</tbody></table>
<p>基本框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ...;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>()&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析二分查找的一个技巧是：不要出现else，而是把所有情况用else if写清楚，这样可以清楚地展现所有细节。</p>
<p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p>
<p><strong>另外提前说明一下，计算 <code>mid</code> 时需要防止溢出</strong>，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大，直接相加导致溢出的情况。</p>
<h3 id="一、寻找一个数（基本的二分搜索）"><a href="#一、寻找一个数（基本的二分搜索）" class="headerlink" title="一、寻找一个数（基本的二分搜索）"></a>一、寻找一个数（基本的二分搜索）</h3><p>这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p>
<p>704.二分查找<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">力扣链接</a></p>
<p>我的初始写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[n] == target) <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (nums[n] &lt; target)&#123;start = n + <span class="number">1</span>; n = (start + end) / <span class="number">2</span>;&#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;end = n - <span class="number">1</span>; n = (start + end ) / <span class="number">2</span>;&#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误原因：这里n一开始定义为nums.length - 1，则遍历的过程是先判断，再分，因此start或者end，一开始就定错了，导致后面的遍历都不是二分了。所以需要先二分，也就是先设置n，正确的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[n] == target) <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (nums[n] &lt; target)&#123;start = n + <span class="number">1</span>; n = (start + end) / <span class="number">2</span>;&#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;end = n - <span class="number">1</span>; n = (start + end ) / <span class="number">2</span>;&#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码优化之后如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**1、为什么 while 循环的条件中是 &lt;&#x3D;，而不是 &lt;**？</p>
<p>答：因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p>
<p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>。因为索引大小为 <code>nums.length</code> 是越界的，所以我们把 <code>right</code> 这一边视为开区间。</p>
<p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间</strong>。</p>
<p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    <span class="keyword">return</span> mid; </span><br></pre></td></tr></table></figure>

<p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。</p>
<p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p>
<p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[right, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<p>当然，如果你非要用 <code>while(left &lt; right)</code> 也可以，我们已经知道了出错的原因，就打个补丁好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断</strong>？</p>
<p>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p>
<p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？</p>
<p>当然是去搜索区间 <code>[left, mid-1]</code> 或者区间 <code>[mid+1, right]</code> 对不对？<strong>因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除</strong>。</p>
<p><strong>3、此算法有什么缺陷</strong>？</p>
<p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p>
<p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p>
<p>这样的需求很常见，<strong>你也许会说，找到一个 <code>target</code>，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了</strong>。</p>
<p>我们后续的算法就来讨论这两种二分查找的算法。</p>
<h3 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="#二、寻找左侧边界的二分搜索"></a><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/wo-xie-le--9c7a4/#%E4%BA%8C%E3%80%81%E5%AF%BB%E6%89%BE%E5%B7%A6%E4%BE%A7%E8%BE%B9%E7%95%8C%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2">#</a>二、寻找左侧边界的二分搜索</h3><p>以下是最常见的代码形式，其中的标记是需要注意的细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么 while 中是 <code>&lt;</code> 而不是 <code>&lt;=</code></strong>?</p>
<p>答：用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code>。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。</p>
<p><code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</p>
<blockquote>
<p>Info</p>
<p>这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：<strong>刚才的 <code>right</code> 不是 <code>nums.length - 1</code> 吗，为啥这里非要写成 <code>nums.length</code> 使得「搜索区间」变成左闭右开呢</strong>？</p>
<p>因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。</p>
</blockquote>
<p><strong>2、为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办</strong>？</p>
<p>答：其实很简单，在返回的时候额外判断一下 <code>nums[left]</code> 是否等于 <code>target</code> 就行了，如果不等于，就说明 <code>target</code> 不存在。需要注意的是，访问数组索引之前要保证索引不越界：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果索引越界，说明数组中无目标元素，返回 -1</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、为什么 <code>left = mid + 1</code>，<code>right = mid</code> ？和之前的算法不一样</strong>？</p>
<p>答：这个很好解释，因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步应该去 <code>mid</code> 的左侧或者右侧区间搜索，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</p>
<p><strong>4、为什么该算法能够搜索左侧边界</strong>？</p>
<p>答：关键在于对于 <code>nums[mid] == target</code> 这种情况的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure>

<p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 <code>[left, mid)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p>
<p>**5、为什么返回 <code>left</code> 而不是 <code>right</code>**？</p>
<p>答：都是一样的，因为 while 终止的条件是 <code>left == right</code>。</p>
<p><strong>6、能不能想办法把 <code>right</code> 变成 <code>nums.length - 1</code>，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了</strong>。</p>
<p>答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：</p>
<p>因为你非要让搜索区间两端都闭，所以 <code>right</code> 应该初始化为 <code>nums.length - 1</code>，while 的终止条件应该是 <code>left == right + 1</code>，也就是其中应该用 <code>&lt;=</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if else ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 <code>left</code> 和 <code>right</code> 的更新逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    <span class="comment">// 收缩右侧边界</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和刚才相同，如果想在找不到 <code>target</code> 的时候返回 -1，那么检查一下 <code>nums[left]</code> 和 <code>target</code> 是否相等即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时 target 比所有数都大，返回 -1</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>至此，整个算法就写完了，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line">    <span class="comment">// 如果越界，target 肯定不存在，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 <code>left</code> 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。</p>
<h3 id="三、寻找右侧边界的二分查找"><a href="#三、寻找右侧边界的二分查找" class="headerlink" title="三、寻找右侧边界的二分查找"></a>三、寻找右侧边界的二分查找</h3><p>类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>1、为什么这个算法能够找到右侧边界</strong>？</p>
<p>答：类似地，关键点还是这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的左边界 <code>left</code>，使得区间不断向右靠拢，达到锁定右侧边界的目的。</p>
<p><strong>2、为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code> 才对</strong>。</p>
<p>答：首先，while 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。</p>
<p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在锁定右边界时的这个条件判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增大 left，锁定右侧边界</span></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这样想: mid = left - 1</span></span><br></pre></td></tr></table></figure>

<p>因为我们对 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，就是说 while 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</p>
<p>至于为什么 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，当然是为了把 <code>nums[mid]</code> 排除出搜索区间，这里就不再赘述。</p>
<p><strong>3、为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办</strong>？</p>
<p>答：只要在最后判断一下 <code>nums[left-1]</code> 是不是 <code>target</code> 就行了，类似之前的左侧边界搜索，做一点额外的判断即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line"><span class="comment">// left - 1 索引越界的话 target 肯定不存在</span></span><br><span class="line"><span class="keyword">if</span> (left - <span class="number">1</span> &lt; <span class="number">0</span> || left - <span class="number">1</span> &gt;= nums.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断一下 nums[left - 1] 是不是 target</span></span><br><span class="line"><span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? (left - <span class="number">1</span>) : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了</strong>。</p>
<p>答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 这里改成收缩左侧边界即可</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后改成返回 left - 1</span></span><br><span class="line">    <span class="keyword">if</span> (left - <span class="number">1</span> &lt; <span class="number">0</span> || left - <span class="number">1</span> &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? (left - <span class="number">1</span>) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，由于 while 的结束条件为 <code>right == left - 1</code>，所以你把上述代码中的 <code>left - 1</code> 都改成 <code>right</code> 也没有问题，这样可能更有利于看出来这是在「搜索右侧边界」：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 这里改成收缩左侧边界即可</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后改成返回 right</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || right &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right] == target ? right : -<span class="number">1</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？</p>
<h2 id="常数时间删除-x2F-查找元素"><a href="#常数时间删除-x2F-查找元素" class="headerlink" title="常数时间删除&#x2F;查找元素"></a>常数时间删除&#x2F;查找元素</h2><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ol>
<li>双指针技巧<ol>
<li>合并两个有序链表</li>
<li>链表的分解</li>
<li>合并 <code>k</code> 个有序链表</li>
<li>寻找单链表的倒数第 <code>k</code> 个节点</li>
<li>寻找单链表的中点</li>
<li>判断单链表是否包含环并找出环起点</li>
<li>判断两个单链表是否相交并找出交点</li>
</ol>
</li>
<li>递归魔法：反转单链表</li>
<li>K个一组反转链表</li>
<li>判断回文链表</li>
</ol>
<h2 id="双指针技巧秒杀七道链表题目"><a href="#双指针技巧秒杀七道链表题目" class="headerlink" title="双指针技巧秒杀七道链表题目"></a>双指针技巧秒杀七道链表题目</h2><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p>
<table>
<thead>
<tr>
<th align="center">LeetCode</th>
<th align="center">力扣</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></td>
<td align="center">🔴</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-list/">86. Partition List</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/middle-of-the-linked-list/">876. Middle of the Linked List</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/SLwz0R/">剑指 Offer II 021. 删除链表的倒数第 n 个结点</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/c32eOV/">剑指 Offer II 022. 链表中环的入口节点</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3u1WK4/">剑指 Offer II 023. 两个链表的第一个重合节点</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/vvXgSW/">剑指 Offer II 078. 合并排序链表</a></td>
<td align="center">🔴</td>
</tr>
</tbody></table>
<p>本文就总结一下单链表的基本技巧，每个技巧都对应着至少一道算法题：</p>
<ol>
<li>合并两个有序链表</li>
<li>链表的分解</li>
<li>合并 <code>k</code> 个有序链表</li>
<li>寻找单链表的倒数第 <code>k</code> 个节点</li>
<li>寻找单链表的中点</li>
<li>判断单链表是否包含环并找出环起点</li>
<li>判断两个单链表是否相交并找出交点</li>
</ol>
<p>这些解法都用到了双指针技巧，所以说对于单链表相关的题目，双指针的运用是非常广泛的，下面我们就来一个一个看。</p>
<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>这是最基本的链表技巧，力扣第 21 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a>」就是这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), p = dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line">        <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span> (p1.val &gt; p2.val) &#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形象地理解，这个算法的逻辑类似于拉拉链，<code>l1, l2</code> 类似于拉链两侧的锯齿，指针 <code>p</code> 就好像拉链的拉索，将两个有序链表合并；或者说这个过程像蛋白酶合成蛋白质，<code>l1, l2</code> 就好比两条氨基酸，而指针 <code>p</code> 就好像蛋白酶，将氨基酸组合成蛋白质。</p>
<p><strong>代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 <code>dummy</code> 节点</strong>。你可以试试，如果不使用 <code>dummy</code> 虚拟节点，代码会复杂一些，需要额外处理指针 <code>p</code> 为空的情况。而有了 <code>dummy</code> 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p>
<blockquote>
<p>，什么时候需要用虚拟头结点？我这里总结下：<strong>当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理</strong>。</p>
<p>比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。</p>
</blockquote>
<h3 id="单链表的分解"><a href="#单链表的分解" class="headerlink" title="单链表的分解"></a>单链表的分解</h3><p>直接看下力扣第 86 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">分隔链表</a>」：</p>
<p>在合并两个有序链表时让你合二为一，而这里需要分解让你把原链表一分为二。具体来说，我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 <code>x</code>，另一个链表中的元素都大于等于 <code>x</code>，最后再把这两条链表接到一起，就得到了题目想要的结果。</p>
<p>整体逻辑和合并有序链表非常相似，细节直接看代码吧，注意虚拟头结点的运用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 存放小于 x 的链表的虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 存放大于等于 x 的链表的虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// p1, p2 指针负责生成结果链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> dummy1, p2 = dummy2;</span><br><span class="line">    <span class="comment">// p 负责遍历原链表，类似合并两个有序链表的逻辑</span></span><br><span class="line">    <span class="comment">// 这里是将一个链表分解成两个链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val &gt;= x) &#123;</span><br><span class="line">            p2.next = p;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p1.next = p;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能直接head = head.next;因为head链表的节点同时被p1和p2连接，所以要先断开head.next</span></span><br><span class="line">        <span class="comment">// p = p.next</span></span><br><span class="line">        <span class="comment">// 断开原链表中的每个节点的 next 指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> p.next;</span><br><span class="line">        p.next = <span class="literal">null</span>;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接两个链表</span></span><br><span class="line">    p1.next = dummy2.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy1.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意Warning！如果直接<code>p = p.next</code>会出现如下的后果：</p>
<p><img src="/master/2023/10/25/leetcodenote/7.png"></p>
<p>所以必须先删除原链表的指针</p>
<p>总的来说，**<u>如果我们需要把原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，那么断开节点和原链表之间的链接可能是必要的。</u><strong>那其实我们可以养成一个好习惯，但凡遇到这种情况，就把原链表的节点断开，这样就不会出错了。个人见解：</strong><u>如果修改了原链表的指针，则不需要断开原连接，否则需要断开原连接</u>**。</p>
<h3 id="合并-k-个有序链表"><a href="#合并-k-个有序链表" class="headerlink" title="合并 k 个有序链表"></a>合并 k 个有序链表</h3><p>看下力扣第 23 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a>」：</p>
<p>合并 <code>k</code> 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 <code>k</code> 个节点中的最小节点，接到结果链表上？</p>
<p>这里我们就要用到 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-daeca/er-cha-dui-1a386/">优先级队列（二叉堆）</a> 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 <code>k</code> 个节点中的最小节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法是面试常考题，它的时间复杂度是多少呢？</p>
<p>优先队列 <code>pq</code> 中的元素个数最多是 <code>k</code>，所以一次 <code>poll</code> 或者 <code>add</code> 方法的时间复杂度是 <code>O(logk)</code>；所有的链表节点都会被加入和弹出 <code>pq</code>，<strong>所以算法整体的时间复杂度是 <code>O(Nlogk)</code>，其中 <code>k</code> 是链表的条数，<code>N</code> 是这些链表的节点总数</strong>。</p>
<h3 id="单链表的倒数第-k-个节点"><a href="#单链表的倒数第-k-个节点" class="headerlink" title="单链表的倒数第 k 个节点"></a>单链表的倒数第 k 个节点</h3><p>很多链表相关的算法题都会用到这个技巧，比如说力扣第 19 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a>」：</p>
<p>从前往后寻找单链表的第 <code>k</code> 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 <code>k</code> 个节点呢？</p>
<p>那你可能说，假设链表有 <code>n</code> 个节点，倒数第 <code>k</code> 个节点就是正数第 <code>n - k + 1</code> 个节点，不也是一个 for 循环的事儿吗？</p>
<p>是的，但是算法题一般只给你一个 <code>ListNode</code> 头结点代表一条单链表，你不能直接得出这条链表的长度 <code>n</code>，而需要先遍历一遍链表算出 <code>n</code> 的值，然后再遍历链表计算第 <code>n - k + 1</code> 个节点。</p>
<p>也就是说，这个解法需要遍历两次链表才能得到出倒数第 <code>k</code> 个节点。</p>
<p>那么，我们能不能<strong>只遍历一次链表</strong>，就算出倒数第 <code>k</code> 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。</p>
<p>这个解法就比较巧妙了，假设 <code>k = 2</code>，思路如下：</p>
<p>首先，我们先让一个指针 <code>p1</code> 指向链表的头节点 <code>head</code>，然后走 <code>k</code> 步：</p>
<p>现在的 <code>p1</code>，只要再走 <code>n - k</code> 步，就能走到链表末尾的空指针了对吧？</p>
<p>趁这个时候，再用一个指针 <code>p2</code> 指向链表头节点 <code>head</code>：</p>
<p>接下来就很显然了，让 <code>p1</code> 和 <code>p2</code> 同时向前走，<code>p1</code> 走到链表末尾的空指针时前进了 <code>n - k</code> 步，<code>p2</code> 也从 <code>head</code> 开始前进了 <code>n - k</code> 步，停留在第 <code>n - k + 1</code> 个节点上，即恰好停链表的倒数第 <code>k</code> 个节点上：</p>
<p>这样，只遍历了一次链表，就获得了倒数第 <code>k</code> 个节点 <code>p2</code>。</p>
<p>上述逻辑的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p2.next = p2.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意，由于我们需要删除第n个节点，所以我们得去到第n-1个节点。处理的技巧是，p1从head开始走，p2从dummy开始走。</p>
<ul>
<li>时间复杂度：O*(*L)，其中 L是链表的长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h3 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h3><p>力扣第 876 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">链表的中间结点</a>」就是这个题目，问题的关键也在于我们无法直接得到单链表的长度 <code>n</code>，常规方法也是先遍历链表计算 <code>n</code>，再遍历一次得到第 <code>n / 2</code> 个节点，也就是中间节点。</p>
<p>如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：</p>
<p>我们让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点 <code>head</code>。</p>
<p><strong>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点</strong>。</p>
<p>上述思路的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p>
<p>另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。</p>
<h3 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h3><p>判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：</p>
<p>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。</p>
<p>如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast</code> 最终和 <code>slow</code> 相遇，那肯定是 <code>fast</code> 超过了 <code>slow</code> 一圈，说明链表中含有环。</p>
<p>只需要把寻找链表中点的代码稍加修改就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个问题还有进阶版，也是力扣第 142 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 II</a>」：如果链表中含有环，如何计算这个环的起点？</p>
<p>为了避免读者迷惑，举个例子，环的起点是指下面这幅图中的节点 2：</p>
<p><img src="/master/2023/10/25/leetcodenote/8.png"></p>
<p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
<p>为什么要这样呢？这里简单说一下其中的原理。</p>
<p>我们假设快慢指针相遇时，慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：</p>
<p><img src="/master/2023/10/25/leetcodenote/9.jpeg"></p>
<p><code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步其实就是 <code>fast</code> 指针在环里转圈圈，所以 <code>k</code> 的值就是环长度的「整数倍」。</p>
<p>假设相遇点距环的起点的距离为 <code>m</code>，那么结合上图的 <code>slow</code> 指针，环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</p>
<p>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。因为结合上图的 <code>fast</code> 指针，从相遇点开始走k步可以转回到相遇点，那走 <code>k - m</code> 步肯定就走到环起点了：</p>
<p><img src="/master/2023/10/25/leetcodenote/10.jpeg"></p>
<p>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后一定会相遇，相遇之处就是环的起点了。</p>
<h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><p>这个问题有意思，也是力扣第 160 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a>」函数签名如下：</p>
<p>给你输入两个链表的头结点 <code>headA</code> 和 <code>headB</code>，这两个链表可能存在相交。</p>
<p>如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。</p>
<p>比如题目给我们举的例子，如果输入的两个链表如下图：</p>
<p><img src="/master/2023/10/25/leetcodenote/11.png"></p>
<p>那么我们的算法应该返回 <code>c1</code> 这个节点。</p>
<p>这个题直接的想法可能是用 <code>HashSet</code> 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p>
<p>如果不用额外的空间，只使用两个指针，你如何做呢？</p>
<p>难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：</p>
<p>如果用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，并不能<strong>同时</strong>走到公共节点，也就无法得到相交节点 <code>c1</code>。</p>
<p>**解决这个问题的关键是，通过某些方式，让 <code>p1</code> 和 <code>p2</code> 能够同时到达相交节点 <code>c1</code>**。</p>
<p>解决这个题目的方法有三种：</p>
<ol>
<li><p>逻辑相连</p>
<p>我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p>
<p>如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code>：</p>
<p><img src="/master/2023/10/25/leetcodenote/12.jpeg"></p>
<p>那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？</p>
<p>这个逻辑可以覆盖这种情况的，相当于 <code>c1</code> 节点是 null 空指针嘛，可以正确返回 null。</p>
<p>按照这个思路，可以写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">startA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">startB</span> <span class="operator">=</span> headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(headA != headB)&#123;</span><br><span class="line">            <span class="keyword">if</span>(headA != <span class="literal">null</span>)headA = headA.next;</span><br><span class="line">            <span class="keyword">else</span> headA = startB;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(headB != <span class="literal">null</span>)headB = headB.next;</span><br><span class="line">            <span class="keyword">else</span> headB = startA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>头尾相连转换成是否包含环</p>
<p>如果把两条链表首尾相连，那么「寻找两条链表的交点」的问题转换成了前面讲的「寻找环起点」的问题：</p>
<p><img src="/master/2023/10/25/leetcodenote/13.png"></p>
<p>不过需要注意的是，这道题说不让你改变原始链表的结构，所以你把题目输入的链表转化成环形链表求解之后记得还要改回来，否则无法通过。</p>
</li>
<li><p>先算长度在预走</p>
<p>可以通过预先计算两条链表的长度来做到这一点,在让长的先走他们长度之差的步数，再一起走。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = headA;</span><br><span class="line">        p2 = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lenA - lenB; i++)&#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lenB - lenA; i++)&#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            <span class="comment">//if(p1 == null || p2 == null)return null;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h2><p>反转单链表包括对链表的整体反转和链表的部分反转，方法可以分为迭代和递归。</p>
<p>首先，我们看最简单的情况，对链表进行反转，看leetcode题目:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/submissions/">反转链表</a></p>
<p><img src="/master/2023/10/25/leetcodenote/14.png"></p>
<h3 id="迭代方法："><a href="#迭代方法：" class="headerlink" title="迭代方法："></a><strong>迭代方法：</strong></h3><p>反转链表，我们当然不能先遍历到结尾再反转，只能边遍历边反转。</p>
<p>所以问题的关键是，我们每遍历一个节点，就修改它的next指针，同时为了处理后面的链表，所以得先保存后面的链表。</p>
<p><img src="/master/2023/10/25/leetcodenote/15.png"></p>
<p>详细的方法见代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//前继节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//后集节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">post</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//保存后面的链表</span></span><br><span class="line">            post = curr.next;</span><br><span class="line">            <span class="comment">//把当前节点的指针指向前继节点</span></span><br><span class="line">            curr.next = pre;</span><br><span class="line">            <span class="comment">//操作完毕，向后移动</span></span><br><span class="line">            pre = curr;</span><br><span class="line">            <span class="comment">//操作完毕，向后移动</span></span><br><span class="line">            curr = post;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>链表的操作难点在于处理头节点和尾节点的边界问题，如何用统一的方法遍历整个链表需要周到的考虑以及持续的练习。</p>
<p>处理头节点的方法是可以在头节点前加一个头节点，pre(dummy)，处理尾节点的方法主要是处理curr.next.next情况，避免产生null.next。</p>
<h3 id="递归方法："><a href="#递归方法：" class="headerlink" title="递归方法："></a><strong>递归方法：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归的写法可能比较难理解，理解时，</p>
<ul>
<li><p>可以先抽象地理解这个递归操作的作用：做了什么操作？返回的是什么？</p>
</li>
<li><p>模拟时，可以先去到栈底，理解结束条件，然后理解递归体的操作，最后理解返回的是什么</p>
</li>
<li><p>其中调用后继递归可能出现在递归体操作或返回条件中，要看实际需求进行处理，这里的last一直保存着最后的节点。</p>
</li>
</ul>
<p>递归三要素：</p>
<ul>
<li>结束条件</li>
<li>递归体操作</li>
<li>返回条件</li>
</ul>
<p>比如这段代码：<strong>输入一个节点 <code>head</code>，将「以 <code>head</code> 为起点」的链表反转，并返回反转之后的头结点</strong>。</p>
<p><img src="/master/2023/10/25/leetcodenote/16.jpg"></p>
<p>并且根据函数定义，<code>reverse</code> 函数会返回反转之后的头结点，我们用变量 <code>last</code> 接收了。</p>
<h3 id="反转链表前-N-个节点"><a href="#反转链表前-N-个节点" class="headerlink" title="反转链表前 N 个节点"></a>反转链表前 N 个节点</h3><p><img src="/master/2023/10/25/leetcodenote/17.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 后驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line">ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseN(head.next, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">// 让反转之后的 head 节点和后面的节点连起来</span></span><br><span class="line">    head.next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决思路和反转整个链表差不多，只要稍加修改即可：</p>
<p>具体的区别：</p>
<p>1、base case 变为 <code>n == 1</code>，反转一个元素，就是它本身，同时<strong>要记录后驱节点</strong>。</p>
<p>2、刚才我们直接把 <code>head.next</code> 设置为 null，因为整个链表反转后原来的 <code>head</code> 变成了整个链表的最后一个节点。但现在 <code>head</code> 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 <code>successor</code>（第 <code>n + 1</code> 个节点），反转之后将 <code>head</code> 连接上。</p>
<p>我们用刚才理解递归整个链表的思路的来理解这个代码。</p>
<p>首先，这个递归的作用是，将链表反转，并保存后继节点，返回头节点。</p>
<p>然后，在栈底，保管后继节点，返回头节点。</p>
<p>递归体中，用last保存最后的节点，执行反转操作，每代栈帧保存successor。</p>
<h3 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h3><p>现在解决的问题是，给一个索引区间 <code>[m, n]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p>
<p>首先，如果 <code>m == 1</code>，就相当于反转链表开头的 <code>n</code> 个元素嘛，也就是我们刚才实现的功能：</p>
<p>如果 <code>m != 1</code> 怎么办？如果我们把 <code>head</code> 的索引视为 1，那么我们是想从第 <code>m</code> 个元素开始反转对吧；如果把 <code>head.next</code> 的索引视为 1 呢？那么相对于 <code>head.next</code>，反转的区间应该是从第 <code>m - 1</code> 个元素开始的；那么对于 <code>head.next.next</code> 呢……</p>
<p>区别于迭代思想，这就是递归思想，所以我们可以完成代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.next = reverseBetween(head.next, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何-K-个一组反转链表"><a href="#如何-K-个一组反转链表" class="headerlink" title="如何 K 个一组反转链表"></a>如何 K 个一组反转链表</h3><p>力扣第 25 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a>」</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> head, b = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="literal">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(a,b);</span><br><span class="line"></span><br><span class="line">        a.next =  reverseKGroup(b,k);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head, ListNode b)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">post</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != b)&#123;</span><br><span class="line">            post = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line"></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = post;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉了之前的链表部分翻转之后，这道题其实就是递归地对链表进行迭代的部分翻转。问题的关键是<code>ListNode last = reverseList(a,b)</code>和<code> a.next =  reverseKGroup(b,k)</code>，用last指针保存[a,b)反转之后的头节点，用a.next连接部分反转之后的头节点，其中(b,k)表示了递归一直往后进行递归。</p>
<h3 id="判断回文链表"><a href="#判断回文链表" class="headerlink" title="判断回文链表"></a>判断回文链表</h3><p>看下力扣第 234 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a>」：</p>
<p>那么最简单的办法就是，把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。关于如何反转链表，可以参见前文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/">递归翻转链表的一部分</a>。</p>
<p>其实，<strong>借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表</strong>，下面来具体聊聊。</p>
<p>对于二叉树的几种遍历方式，我们再熟悉不过了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历代码</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序遍历代码</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/">学习数据结构的框架思维</a> 中说过，链表兼具递归结构，树结构不过是链表的衍生。那么，<strong>链表其实也可以有前序遍历和后序遍历</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历代码</span></span><br><span class="line">    traverse(head.next);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个框架有什么指导意义呢？如果我想正序打印链表中的 <code>val</code> 值，可以在前序遍历位置写代码；反之，**<u>如果想倒序遍历链表，就可以在后序遍历位置操作：</u>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 倒序打印单链表中的元素值 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    traverse(head.next);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">    print(head.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到这了，其实可以稍作修改，模仿双指针实现回文判断的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左侧指针</span></span><br><span class="line">ListNode left;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">return</span> traverse(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(ListNode right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> traverse(right.next);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">    res = res &amp;&amp; (right.val == left.val);</span><br><span class="line">    left = left.next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的核心逻辑是什么呢？<strong>实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的</strong>，只不过我们利用的是递归函数的堆栈而已，如下 GIF 所示：</p>
<p><img src="/master/2023/10/25/leetcodenote/18.gif"></p>
<p>当然，无论造一条反转链表还是利用后序遍历，算法的时间和空间复杂度都是 O(N)。下面我们想想，能不能不用额外的空间，解决这个问题呢？</p>
<p>更好的思路是这样的：</p>
<p><strong>1、先通过 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/shuang-zhi-0f7cc/">双指针技巧</a> 中的快慢指针来找到链表的中点</strong>：</p>
<p><strong>2、如果<code>fast</code>指针没有指向<code>null</code>，说明链表长度为奇数，<code>slow</code>还要再前进一步</strong>：</p>
<p><strong>3、从<code>slow</code>开始反转后面的链表，现在就可以开始比较回文串了</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    ListNode slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">null</span>)</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> reverse(slow);</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="纲领篇"><a href="#纲领篇" class="headerlink" title="纲领篇"></a>纲领篇</h2><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p>
<table>
<thead>
<tr>
<th align="center">LeetCode</th>
<th align="center">力扣</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></td>
<td align="center">🟢</td>
</tr>
</tbody></table>
<p>先在开头总结一下，二叉树解题的思维模式分两类：</p>
<p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p>
<p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p>
<p>无论使用哪种思维模式，你都需要思考：</p>
<p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做</strong>？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p>
<h3 id="二叉树的重要性"><a href="#二叉树的重要性" class="headerlink" title="二叉树的重要性"></a><strong>二叉树的重要性</strong></h3><p>举个例子，比如两个经典排序算法 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/kuai-su-pa-39aa2/">快速排序</a> 和 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/gui-bing-p-1387f/">归并排序</a>，对于它俩，你有什么理解？</p>
<p><strong>如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了</strong>。</p>
<p>为什么快速排序和归并排序能和二叉树扯上关系？我们来简单分析一下他们的算法思想和代码框架：</p>
<p>快速排序的逻辑是，若要对 <code>nums[lo..hi]</code> 进行排序，我们先找一个分界点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p]</code>，然后递归地去 <code>nums[lo..p-1]</code> 和 <code>nums[p+1..hi]</code> 中寻找新的分界点，最后整个数组就被排序了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">/****** 前序遍历位置 ******/</span></span><br><span class="line">    <span class="comment">// 通过交换元素构建分界点 p</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">    <span class="comment">/************************/</span></span><br><span class="line"></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？</p>
<p>再说说归并排序的逻辑，若要对 <code>nums[lo..hi]</code> 进行排序，我们先对 <code>nums[lo..mid]</code> 排序，再对 <code>nums[mid+1..hi]</code> 排序，最后把这两个有序的子数组合并，整个数组就排好序了。</p>
<p>归并排序的代码框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo..hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 排序 nums[lo..mid]</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    <span class="comment">// 排序 nums[mid+1..hi]</span></span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">    <span class="comment">// 合并 nums[lo..mid] 和 nums[mid+1..hi]</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">    <span class="comment">/*********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。</p>
<h3 id="深入理解前中后序"><a href="#深入理解前中后序" class="headerlink" title="深入理解前中后序"></a><strong>深入理解前中后序</strong></h3><p>首先，回顾一下 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/">学习数据结构和算法的框架思维</a> 中说到的二叉树遍历框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不管所谓前中后序，单看 <code>traverse</code> 函数，你说它在做什么事情？</p>
<p>其实它就是一个能够遍历二叉树所有节点的一个函数，和你遍历数组或者链表本质上没有区别：</p>
<p>单链表和数组的遍历可以是迭代的，也可以是递归的，<strong>二叉树这种结构无非就是二叉链表</strong>，由于没办法简单改写成迭代形式，<strong>所以一般说二叉树的遍历框架都是指递归的形式</strong>。</p>
<p><u><strong>所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候</strong>，那么进一步，你把代码写在不同位置，代码执行的时机也不同：</u></p>
<p>比如说，如果让你<strong>倒序打印</strong>一条单链表上所有节点的值，你怎么搞？</p>
<p>实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 递归遍历单链表，倒序打印链表元素 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(head.next);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    print(head.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么说回二叉树也是一样的，只不过多了一个中序位置罢了。</p>
<p>因此，<strong>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点</strong>，绝不仅仅是三个顺序不同的 List：</p>
<ol>
<li><p>前序位置的代码在刚刚进入一个二叉树节点的时候执行；</p>
</li>
<li><p>后序位置的代码在将要离开一个二叉树节点的时候执行；</p>
</li>
<li><p>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</p>
</li>
</ol>
<p>画成图，前中后序三个位置在二叉树上是这样：</p>
<p><img src="/master/2023/10/25/leetcodenote/19.jpeg"></p>
<p><strong>你可以发现每个节点都有「唯一」属于自己的前中后序位置</strong>，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。</p>
<p>说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现：</p>
<p><strong>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作</strong>。</p>
<h3 id="两种解题思路"><a href="#两种解题思路" class="headerlink" title="两种解题思路"></a><strong>两种解题思路</strong></h3><p>前文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/wo-de-shua-5fe0c/">我的算法学习心得</a> 说过：</p>
<p>**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">回溯算法核心框架</a> 和 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/">动态规划核心框架</a>**。</p>
<blockquote>
<p>这里说一下我的函数命名习惯：二叉树中用<strong>遍历思路</strong>解题时函数签名一般是 <code>void traverse(...)</code>，没有返回值，靠更新<u>外部变量</u>来计算结果，而用<strong>分解问题</strong>思路解题时函数名根据该函数具体功能而定，而且一般会有返回值，<u>返回值是子问题的计算结果</u>。</p>
<p>与此对应的，你会发现我在 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">回溯算法核心框架</a> 中给出的函数签名一般也是没有返回值的 <code>void backtrack(...)</code>，而在 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/">动态规划核心框架</a> 中给出的函数签名是带有返回值的 <code>dp</code> 函数。这也说明它俩和二叉树之间千丝万缕的联系。</p>
<p>虽然函数命名没有什么硬性的要求，但我还是建议你也遵循我的这种风格，这样更能突出函数的作用和解题的思维模式，便于你自己理解和运用。</p>
</blockquote>
<p>当时我是用二叉树的最大深度这个问题来举例，重点在于把这两种思路和动态规划和回溯算法进行对比，而本文的重点在于分析这两种思路如何解决二叉树的题目。</p>
<p>力扣第 104 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a>」就是最大深度的题目，所谓最大深度就是根节点到「最远」叶子节点的最长路径上的节点数。</p>
<p><strong>遍历二叉树的思路：</strong></p>
<p>显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录遍历到的节点的深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	traverse(root);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 前序位置</span></span><br><span class="line">	depth++;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达叶子节点，更新最大深度</span></span><br><span class="line">		res = Math.max(res, depth);</span><br><span class="line">    &#125;</span><br><span class="line">	traverse(root.left);</span><br><span class="line">	traverse(root.right);</span><br><span class="line">	<span class="comment">// 后序位置</span></span><br><span class="line">	depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法应该很好理解，但为什么需要在前序位置增加 <code>depth</code>，在后序位置减小 <code>depth</code>？</p>
<p>因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，<code>depth</code> 记录当前递归到的节点深度，你把 <code>traverse</code> 理解成在二叉树上游走的一个指针，所以当然要这样维护。</p>
<p>至于对 <code>res</code> 的更新，你放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即 <code>depth</code> 自增之后，自减之前）就行了。</p>
<p><strong>分解问题计算答案的思路</strong></p>
<p>你也很容易发现一棵二叉树的最大深度可以通过子树的最大深度推导出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 利用定义，计算左右子树的最大深度</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">	<span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">	<span class="comment">// 整棵树的最大深度等于左右子树的最大深度取最大值，</span></span><br><span class="line">    <span class="comment">// 然后再加上根节点自己</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？</p>
<p>因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。</p>
<p>如果你理解了最大深度这个问题的两种思路，<strong>那么我们再回头看看最基本的二叉树前中后序遍历</strong></p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>我们熟悉的解法就是用「遍历」的思路，我想应该没什么好说的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">preorderTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    res.add(root.val);</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但你是否能够用「分解问题」的思路，来计算前序遍历的结果？</p>
<p>换句话说，不要用像 <code>traverse</code> 这样的辅助函数和任何外部变量，单纯用题目给的 <code>preorderTraverse</code> 函数递归解题，你会不会？</p>
<p>我们知道前序遍历的特点是，根节点的值排在首位，接着是左子树的前序遍历结果，最后是右子树的前序遍历结果：</p>
<p><img src="/master/2023/10/25/leetcodenote/20.jpeg"></p>
<p>那这不就可以分解问题了么，<strong>一棵二叉树的前序遍历结果 &#x3D; 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果</strong>。</p>
<p>所以，你可以这样实现前序遍历算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">preorderTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历的结果，root.val 在第一个</span></span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="comment">// 利用函数定义，后面接着左子树的前序遍历结果</span></span><br><span class="line">    res.addAll(preorderTraverse(root.left));</span><br><span class="line">    <span class="comment">// 利用函数定义，最后接着右子树的前序遍历结果</span></span><br><span class="line">    res.addAll(preorderTraverse(root.right));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序和后序遍历也是类似的，只要把 <code>add(root.val)</code> 放到中序和后序对应的位置就行了。</p>
<p>综上，遇到一道二叉树的题目时的通用思考过程是：</p>
<p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现。</p>
<p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</p>
<p><strong>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</strong>。</p>
<h3 id="后序位置的特殊之处"><a href="#后序位置的特殊之处" class="headerlink" title="后序位置的特殊之处"></a>后序位置的特殊之处</h3><p>说后序位置之前，先简单说下中序和前序。</p>
<p>中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。</p>
<p>前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。</p>
<p>你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：</p>
<p>这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。</p>
<p><strong>但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据</strong>。</p>
<p>举具体的例子，现在给你一棵二叉树，我问你两个简单的问题：</p>
<p>1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？</p>
<p>2、如何打印出每个节点的左右子树各有多少节点？</p>
<p>第一个问题可以这样写代码：</p>
<p>第一个问题可以这样写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    printf(<span class="string">&quot;节点 %s 在第 %d 层&quot;</span>, root, level);</span><br><span class="line">    traverse(root.left, level + <span class="number">1</span>);</span><br><span class="line">    traverse(root.right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用</span></span><br><span class="line">traverse(root, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>第二个问题可以这样写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树，返回这棵二叉树的节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> count(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> count(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    printf(<span class="string">&quot;节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点&quot;</span>,</span><br><span class="line">            root, leftCount, rightCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这两个问题的根本区别在于：一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案</strong>。</p>
<p>结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。</p>
<p><strong>那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</p>
<p>接下来看下后序位置是如何在实际的题目中发挥作用的，简单聊下力扣第 543 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径</a>」，让你计算一棵二叉树的最长直径长度。</p>
<p>所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度。最长「直径」并不一定要穿过根结点，比如下面这棵二叉树：</p>
<p><img src="/master/2023/10/25/leetcodenote/21.png"></p>
<p>它的最长直径是 3，即 <code>[4,2,1,3]</code>，<code>[4,2,1,9]</code> 或者 <code>[5,2,1,3]</code> 这几条「直径」的长度。</p>
<p>解决这题的关键在于，<strong>每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和</strong>。</p>
<p>现在让我求整棵树中的最长「直径」，那直截了当的思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的「直径」，最后把所有「直径」求个最大值即可。</p>
<p>这就出现了刚才探讨的情况，<strong>前序位置无法获取子树信息，所以只能让每个节点调用 <code>maxDepth</code> 函数去算子树的深度</strong>。</p>
<p>那如何优化？我们应该把计算「直径」的逻辑放在后序位置，准确说应该是放在 <code>maxDepth</code> 的后序位置，因为 <code>maxDepth</code> 的后序位置是知道左右子树的最大深度的。</p>
<p>所以，稍微改一下代码逻辑即可得到更好的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录最大直径的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 后序位置，顺便计算最大直径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">myDiameter</span> <span class="operator">=</span> leftMax + rightMax;</span><br><span class="line">        maxDiameter = Math.max(maxDiameter, myDiameter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这下时间复杂度只有 <code>maxDepth</code> 函数的 O(N) 了。</p>
<p>讲到这里，照应一下前文：遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。</p>
<p>反过来，如果你写出了类似一开始的那种递归套递归的解法，大概率也需要反思是不是可以通过后序遍历优化了。</p>
<h3 id="以树的视角看动归-x2F-回溯-x2F-DFS算法的区别和联系"><a href="#以树的视角看动归-x2F-回溯-x2F-DFS算法的区别和联系" class="headerlink" title="以树的视角看动归&#x2F;回溯&#x2F;DFS算法的区别和联系"></a>以树的视角看动归&#x2F;回溯&#x2F;DFS算法的区别和联系</h3><p>前文我说动态规划&#x2F;回溯算法就是二叉树算法两种不同思路的表现形式，相信能看到这里的读者应该也认可了我这个观点。但有细心的读者经常问我：东哥，你的理解思路让我豁然开朗，但你好像一直没讲过 DFS 算法？</p>
<p>其实我在 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-san-zha-24031/bao-li-sou-96f79/yi-wen-mia-4f482/">一文秒杀所有岛屿题目</a> 中就是用的 DFS 算法，但我确实没有单独用一篇文章讲 DFS 算法，<strong>因为 DFS 算法和回溯算法非常类似，只是在细节上有所区别</strong>。</p>
<p>这个细节上的差别是什么呢？其实就是「做选择」和「撤销选择」到底在 for 循环外面还是里面的区别，DFS 算法在外面，回溯算法在里面。</p>
<p>为什么有这个区别？还是要结合着二叉树理解。这一部分我就把回溯算法、DFS 算法、动态规划三种经典的算法思想，以及它们和二叉树算法的联系和区别，用一句话来说明：</p>
<p><strong>动归&#x2F;DFS&#x2F;回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同</strong>：</p>
<ul>
<li><strong>动态规划算法属于分解问题的思路，它的关注点在整棵「子树」</strong>。</li>
<li><strong>回溯算法属于遍历的思路，它的关注点在节点间的「树枝」</strong>。</li>
<li><strong>DFS 算法属于遍历的思路，它的关注点在单个「节点」</strong>。</li>
</ul>
<p>怎么理解？我分别举三个例子你就懂了：</p>
<p><strong>第一个例子</strong>，给你一棵二叉树，请你用分解问题的思路写一个 <code>count</code> 函数，计算这棵二叉树共有多少个节点。代码很简单，上文都写过了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树，返回这棵二叉树的节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我这个节点关心的是我的两个子树的节点总数分别是多少</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> count(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> count(root.right);</span><br><span class="line">    <span class="comment">// 后序位置，左右子树节点数加上自己就是整棵树的节点数</span></span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>你看，这就是动态规划分解问题的思路，它的着眼点永远是结构相同的整个子问题，类比到二叉树上就是「子树」</strong>。</p>
<p>你再看看具体的动态规划问题，比如 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/">动态规划框架套路详解</a> 中举的斐波那契的例子，我们的关注点在一棵棵子树的返回值上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二个例子</strong>，给你一棵二叉树，请你用遍历的思路写一个 <code>traverse</code> 函数，打印出遍历这棵二叉树的过程，你看下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    printf(<span class="string">&quot;从节点 %s 进入节点 %s&quot;</span>, root, root.left);</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    printf(<span class="string">&quot;从节点 %s 回到节点 %s&quot;</span>, root.left, root);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;从节点 %s 进入节点 %s&quot;</span>, root, root.right);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    printf(<span class="string">&quot;从节点 %s 回到节点 %s&quot;</span>, root.right, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>你看，这就是回溯算法遍历的思路，它的着眼点永远是在节点之间移动的过程，类比到二叉树上就是「树枝」</strong>。</p>
<p>你再看看具体的回溯算法问题，比如 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-56e11/">回溯算法秒杀排列组合子集的九种题型</a> 中讲到的全排列，我们的关注点在一条条树枝上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯算法核心部分代码</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯算法框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入下一层回溯树</span></span><br><span class="line">        backtrack(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三个例子</strong>，我给你一棵二叉树，请你写一个 <code>traverse</code> 函数，把这棵二叉树上的每个节点的值都加一。很简单吧，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 遍历过的每个节点的值加一</span></span><br><span class="line">    root.val++;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>你看，这就是 DFS 算法遍历的思路，它的着眼点永远是在单一的节点上，类比到二叉树上就是处理每个「节点」</strong>。</p>
<p>好，请你仔细品一下上面三个简单的例子，是不是像我说的：动态规划关注整棵「子树」，回溯算法关注节点间的「树枝」，DFS 算法关注单个「节点」。</p>
<p>有了这些铺垫，你就很容易理解为什么回溯算法和 DFS 算法代码中「做选择」和「撤销选择」的位置不同了，看下面两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS 算法把「做选择」「撤销选择」的逻辑放在 for 循环外面</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    print(<span class="string">&quot;我已经进入节点 %s 啦&quot;</span>, root)</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        dfs(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    print(<span class="string">&quot;我将要离开节点 %s 啦&quot;</span>, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯算法把「做选择」「撤销选择」的逻辑放在 for 循环里面</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        print(<span class="string">&quot;我站在节点 %s 到节点 %s 的树枝上&quot;</span>, root, child)</span><br><span class="line">        backtrack(child);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        print(<span class="string">&quot;我将要离开节点 %s 到节点 %s 的树枝上&quot;</span>, child, root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吧，你回溯算法必须把「做选择」和「撤销选择」的逻辑放在 for 循环里面，否则怎么拿到「树枝」的两个端点？</p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>二叉树题型主要是用来培养递归思维的，而层序遍历属于迭代遍历，也比较简单，这里就过一下代码框架吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵二叉树的根节点，层序遍历这棵二叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面 while 循环和 for 循环分管从上到下和从左到右的遍历：</p>
<p>后文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/bfs-suan-f-463fd/">BFS 算法框架</a> 就是从二叉树的层序遍历扩展出来的，常用于求无权图的<strong>最短路径</strong>问题。</p>
<p>当然这个框架还可以灵活修改，题目不需要记录层数（步数）时可以去掉上述框架中的 for 循环，比如后文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/dijkstra-s-6d0b2/">Dijkstra 算法</a> 中计算加权图的最短路径问题，详细探讨了 BFS 算法的扩展。</p>
<p>值得一提的是，有些很明显需要用层序遍历技巧的二叉树的题目，也可以用递归遍历的方式去解决，而且技巧性会更强，非常考察你对前中后序的把控。</p>
<h2 id="思路篇"><a href="#思路篇" class="headerlink" title="思路篇"></a>思路篇</h2><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p>
<table>
<thead>
<tr>
<th align="center">LeetCode</th>
<th align="center">力扣</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></td>
<td align="center">🟢</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></td>
<td align="center">🟢</td>
</tr>
</tbody></table>
<p>本文就以几道比较简单的题目为例，带你实践运用这几条总纲，理解「遍历」的思维和「分解问题」的思维有何区别和联系。</p>
<h3 id="第一题、翻转二叉树"><a href="#第一题、翻转二叉树" class="headerlink" title="第一题、翻转二叉树"></a>第一题、翻转二叉树</h3><p>我们先从简单的题开始，看看力扣第 226 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a>」，输入一个二叉树根节点 <code>root</code>，让你把整棵树镜像翻转。</p>
<p>不难发现，只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。</p>
<p>那么现在开始在心中默念二叉树解题总纲：</p>
<p><strong>1、这题能不能用「遍历」的思维模式解决</strong>？</p>
<p>可以，我写一个 <code>traverse</code> 函数遍历每个节点，让每个节点的左右子节点颠倒过来就行了。</p>
<p>单独抽出一个节点，需要让它做什么？让它把自己的左右子节点交换一下。</p>
<p>需要在什么时候做？好像前中后序位置都可以。</p>
<p>综上，可以写出如下解法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历二叉树，交换每个节点的子节点</span></span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">    <span class="comment">// 每一个节点需要做的事就是交换它的左右子节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历框架，去遍历左右子树的节点</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、这题能不能用「分解问题」的思维模式解决</strong>？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点</span></span><br><span class="line">TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用函数定义，先翻转左右子树</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后交换左右子节点</span></span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我可以用 <code>invertTree(x.left)</code> 先把 <code>x</code> 的左子树翻转，再用 <code>invertTree(x.right)</code> 把 <code>x</code> 的右子树翻转，最后把 <code>x</code> 的左右子树交换，这恰好完成了以 <code>x</code> 为根的整棵二叉树的翻转，即完成了 <code>invertTree(x)</code> 的定义。</p>
<h3 id="第二题、填充节点的右侧指针"><a href="#第二题、填充节点的右侧指针" class="headerlink" title="第二题、填充节点的右侧指针"></a>第二题、填充节点的右侧指针</h3><p>这是力扣第 116 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">填充每个二叉树节点的右侧指针</a>」</p>
<p>题目的意思就是把二叉树的每一层节点都用 <code>next</code> 指针连接起来：</p>
<p>而且题目说了，输入是一棵「完美二叉树」，形象地说整棵二叉树是一个正三角形，除了最右侧的节点 <code>next</code> 指针会指向 <code>null</code>，其他节点的右侧一定有相邻的节点。</p>
<p>这道题怎么做呢？来默念二叉树解题总纲：</p>
<p><strong>1、这题能不能用「遍历」的思维模式解决</strong>？</p>
<p>很显然，一定可以。</p>
<p>每个节点要做的事也很简单，把自己的 <code>next</code> 指针指向右侧节点就行了。</p>
<p>也许你会模仿上一道题，直接写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左子节点的 next 指针指向右子节点</span></span><br><span class="line">    root.left.next = root.right;</span><br><span class="line"></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这段代码其实有很大问题，因为它只能把相同父节点的两个节点穿起来</p>
<p>节点 5 和节点 6 不属于同一个父节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的，但是问题出在哪里？</p>
<p><strong>传统的 <code>traverse</code> 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「空隙」</strong>。</p>
<p>所以我们可以在二叉树的基础上进行抽象，你把图中的每一个方框看做一个节点：</p>
<p><img src="/master/2023/10/25/leetcodenote/22.png"></p>
<p><strong>这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点</strong>。</p>
<p>现在，我们只要实现一个 <code>traverse</code> 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历「三叉树」，连接相邻节点</span></span><br><span class="line">    traverse(root.left, root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三叉树遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node node1, Node node2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传入的两个节点穿起来</span></span><br><span class="line">    node1.next = node2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接相同父节点的两个子节点</span></span><br><span class="line">    traverse(node1.left, node1.right);</span><br><span class="line">    traverse(node2.left, node2.right);</span><br><span class="line">    <span class="comment">// 连接跨越父节点的两个子节点</span></span><br><span class="line">    traverse(node1.right, node2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>traverse</code> 函数遍历整棵「三叉树」，将所有相邻节的二叉树节点都连接起来，也就避免了我们之前出现的问题，把这道题完美解决。</p>
<p><strong>2、这题能不能用「分解问题」的思维模式解决</strong>？</p>
<p>嗯，好像没有什么特别好的思路，所以这道题无法使用「分解问题」的思维来解决。</p>
<h3 id="第三题、将二叉树展开为链表"><a href="#第三题、将二叉树展开为链表" class="headerlink" title="第三题、将二叉树展开为链表"></a>第三题、将二叉树展开为链表</h3><p>这是力扣第 114 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">将二叉树展开为链表</a>」</p>
<p><strong>1、这题能不能用「遍历」的思维模式解决</strong>？</p>
<p><code>flatten</code> 函数的签名，返回类型为 <code>void</code>，也就是说题目希望我们在原地把二叉树拉平成链表。</p>
<p>这样一来，没办法通过简单的二叉树遍历来解决这道题了。</p>
<p><strong>2、这题能不能用「分解问题」的思维模式解决</strong>？</p>
<p>对于一个节点 <code>x</code>，可以执行以下流程：</p>
<p>1、先利用 <code>flatten(x.left)</code> 和 <code>flatten(x.right)</code> 将 <code>x</code> 的左右子树拉平。</p>
<p>2、将 <code>x</code> 的右子树接到左子树下方，然后将整个左子树作为右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：将以 root 为根的树拉平为链表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用定义，把左右子树拉平</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**** 后序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、将左子树作为右子树</span></span><br><span class="line">    root.left = <span class="literal">null</span>;</span><br><span class="line">    root.right = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    p.right = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造篇"><a href="#构造篇" class="headerlink" title="构造篇"></a>构造篇</h2><p>读完本文，你不仅学会了算法套路，还可以顺便解决如下题目：</p>
<table>
<thead>
<tr>
<th align="center">LeetCode</th>
<th align="center">力扣</th>
<th align="center">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversalopen in new window</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树open in new window</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversalopen in new window</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树open in new window</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree/">654. Maximum Binary Treeopen in new window</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树open in new window</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. Construct Binary Tree from Preorder and Postorder Traversalopen in new window</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树open in new window</a></td>
<td align="center">🟠</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树open in new window</a></td>
<td align="center">🟠</td>
</tr>
</tbody></table>
<p><strong>二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 &#x3D; 根节点 + 构造左子树 + 构造右子树</strong>。</p>
<p>接下来直接看题。</p>
<h3 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h3><p>先来道简单的，这是力扣第 654 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">最大二叉树open in new window</a>」</p>
<p>每个二叉树节点都可以认为是一棵子树的根节点，对于根节点，首先要做的当然是把想办法把自己先构造出来，然后想办法构造自己的左右子树。</p>
<p>所以，我们要遍历数组把找到最大值 <code>maxVal</code>，从而把根节点 <code>root</code> 做出来，然后对 <code>maxVal</code> 左边的数组和右边的数组进行递归构建，作为 <code>root</code> 的左右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line">TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点</span></span><br><span class="line">TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到数组中的最大值和对应的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>, maxVal = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxVal &lt; nums[i]) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            maxVal = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先构造出根节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">    <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">    root.left = build(nums, lo, index - <span class="number">1</span>);</span><br><span class="line">    root.right = build(nums, index + <span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过前序和中序遍历结果构造二叉树"><a href="#通过前序和中序遍历结果构造二叉树" class="headerlink" title="通过前序和中序遍历结果构造二叉树"></a>通过前序和中序遍历结果构造二叉树</h3><p>力扣第 105 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序和中序遍历序列构造二叉树open in new window</a>」就是这道经典题目，面试笔试中常考：</p>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://huangjm0508.gitee.io">HUANG jm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://huangjm0508.gitee.io/2023/10/25/leetcodenote/">https://huangjm0508.gitee.io/2023/10/25/leetcodenote/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://huangjm0508.gitee.io" target="_blank">HUANGjm 's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/master/tags/leetcode/">leetcode</a></div><div class="post_share"><div class="social-share" data-image="https://img0.baidu.com/it/u=2515196433,1042495811&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=400&amp;h=230" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/master/2023/11/06/SpringBoot2/" title="SpringBoot2"><img class="cover" src="https://img1.baidu.com/it/u=376870289,2951595201&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=854&amp;h=521" onerror="onerror=null;src='/master/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot2</div></div></a></div><div class="next-post pull-right"><a href="/master/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="https://img2.baidu.com/it/u=1182103572,357915882&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="onerror=null;src='/master/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/master/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUANG jm</div><div class="author-info__description">越努力越幸运</div></div><div class="card-info-data site-data is-center"><a href="/master/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/master/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/master/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！这里是我的学习生活分享!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E7%A7%92%E6%9D%80%E4%B8%83%E9%81%93%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE"><span class="toc-number">1.1.</span> <span class="toc-text">双指针技巧秒杀七道数组题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">快慢指针技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">左右指针的常用算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7-%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">小而美的算法技巧:前缀和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.1.</span> <span class="toc-text">一维数组的前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.2.</span> <span class="toc-text">二维数组的前缀和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">小而美的算法技巧:差分数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86-%E8%BF%87%E7%A8%8B%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.4.</span> <span class="toc-text">花式遍历(过程模拟)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA-x2F-%E9%80%86%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">顺&#x2F;逆时针旋转矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E8%9E%BA%E6%97%8B%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">矩阵的螺旋遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.5.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">1.5.1.</span> <span class="toc-text">一、最小覆盖子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%88%97"><span class="toc-number">1.5.2.</span> <span class="toc-text">二、字符串排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%89%BE%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">1.5.3.</span> <span class="toc-text">三、找所有字母异位词</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.6.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6"><span class="toc-number">1.6.1.</span> <span class="toc-text">零、二分查找框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B0%EF%BC%88%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">一、寻找一个数（基本的二分搜索）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AF%BB%E6%89%BE%E5%B7%A6%E4%BE%A7%E8%BE%B9%E7%95%8C%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">1.6.3.</span> <span class="toc-text">二、寻找左侧边界的二分搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AF%BB%E6%89%BE%E5%8F%B3%E4%BE%A7%E8%BE%B9%E7%95%8C%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.6.4.</span> <span class="toc-text">三、寻找右侧边界的二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4-x2F-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.7.</span> <span class="toc-text">常数时间删除&#x2F;查找元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E7%A7%92%E6%9D%80%E4%B8%83%E9%81%93%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE"><span class="toc-number">2.1.</span> <span class="toc-text">双指针技巧秒杀七道链表题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E8%A7%A3"><span class="toc-number">2.1.2.</span> <span class="toc-text">单链表的分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">合并 k 个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">单链表的倒数第 k 个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9"><span class="toc-number">2.1.5.</span> <span class="toc-text">单链表的中点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF"><span class="toc-number">2.1.6.</span> <span class="toc-text">判断链表是否包含环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="toc-number">2.1.7.</span> <span class="toc-text">两个链表是否相交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">反转单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.2.1.</span> <span class="toc-text">迭代方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.2.2.</span> <span class="toc-text">递归方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8D-N-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.3.</span> <span class="toc-text">反转链表前 N 个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-number">2.2.4.</span> <span class="toc-text">反转链表的一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.5.</span> <span class="toc-text">如何 K 个一组反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.6.</span> <span class="toc-text">判断回文链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%B2%E9%A2%86%E7%AF%87"><span class="toc-number">3.1.</span> <span class="toc-text">纲领篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">3.1.1.</span> <span class="toc-text">二叉树的重要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">深入理解前中后序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">3.1.3.</span> <span class="toc-text">两种解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.4.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84"><span class="toc-number">3.1.5.</span> <span class="toc-text">后序位置的特殊之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E6%A0%91%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E5%8A%A8%E5%BD%92-x2F-%E5%9B%9E%E6%BA%AF-x2F-DFS%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">3.1.6.</span> <span class="toc-text">以树的视角看动归&#x2F;回溯&#x2F;DFS算法的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.7.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E7%AF%87"><span class="toc-number">3.2.</span> <span class="toc-text">思路篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98%E3%80%81%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.2.1.</span> <span class="toc-text">第一题、翻转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98%E3%80%81%E5%A1%AB%E5%85%85%E8%8A%82%E7%82%B9%E7%9A%84%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88"><span class="toc-number">3.2.2.</span> <span class="toc-text">第二题、填充节点的右侧指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98%E3%80%81%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">第三题、将二叉树展开为链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%AF%87"><span class="toc-number">3.3.</span> <span class="toc-text">构造篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.3.1.</span> <span class="toc-text">构造最大二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.3.2.</span> <span class="toc-text">通过前序和中序遍历结果构造二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">回溯算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">6.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">7.</span> <span class="toc-text">图论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/master/2023/11/24/SpringBoottheory/" title="SpringBoot2原理篇"><img src="https://img1.baidu.com/it/u=376870289,2951595201&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=854&amp;h=521" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="SpringBoot2原理篇"/></a><div class="content"><a class="title" href="/master/2023/11/24/SpringBoottheory/" title="SpringBoot2原理篇">SpringBoot2原理篇</a><time datetime="2023-11-24T03:04:14.234Z" title="发表于 2023-11-24 11:04:14">2023-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/11/06/SpringBoot2/" title="SpringBoot2"><img src="https://img1.baidu.com/it/u=376870289,2951595201&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=854&amp;h=521" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="SpringBoot2"/></a><div class="content"><a class="title" href="/master/2023/11/06/SpringBoot2/" title="SpringBoot2">SpringBoot2</a><time datetime="2023-11-06T11:56:32.652Z" title="发表于 2023-11-06 19:56:32">2023-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/10/25/leetcodenote/" title="leetcode日记"><img src="https://img0.baidu.com/it/u=2515196433,1042495811&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=400&amp;h=230" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="leetcode日记"/></a><div class="content"><a class="title" href="/master/2023/10/25/leetcodenote/" title="leetcode日记">leetcode日记</a><time datetime="2023-10-25T07:11:57.000Z" title="发表于 2023-10-25 15:11:57">2023-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://img2.baidu.com/it/u=1182103572,357915882&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/master/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-10-23T07:12:46.933Z" title="发表于 2023-10-23 15:12:46">2023-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/05/19/datastructandalgorithm/" title="数据结构和算法"><img src="https://img0.baidu.com/it/u=311636268,727562660&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="数据结构和算法"/></a><div class="content"><a class="title" href="/master/2023/05/19/datastructandalgorithm/" title="数据结构和算法">数据结构和算法</a><time datetime="2023-05-19T06:41:24.469Z" title="发表于 2023-05-19 14:41:24">2023-05-19</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 By HUANG jm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/master/js/utils.js"></script><script src="/master/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>