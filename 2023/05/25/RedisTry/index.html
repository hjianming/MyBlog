<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis实战 | HUANGjm 's blog</title><meta name="author" content="HUANG jm"><meta name="copyright" content="HUANG jm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内容概述 短信登录 这部分会使用Redis共享session来实现 但其实我在之前的瑞吉外卖的项目优化部分就做过了，用Redis替换session来存储邮箱验证码   商户查询缓存 这部分要理解缓存击穿，缓存穿透，缓存雪崩等问题，对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容   优惠券秒杀 这部分我们可以学会Redis的计数器功能，结合Lua(之前一直想学Lua然后写饥荒m">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis实战">
<meta property="og:url" content="https://hjianming.github.io/2023/05/25/RedisTry/index.html">
<meta property="og:site_name" content="HUANGjm &#39;s blog">
<meta property="og:description" content="内容概述 短信登录 这部分会使用Redis共享session来实现 但其实我在之前的瑞吉外卖的项目优化部分就做过了，用Redis替换session来存储邮箱验证码   商户查询缓存 这部分要理解缓存击穿，缓存穿透，缓存雪崩等问题，对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容   优惠券秒杀 这部分我们可以学会Redis的计数器功能，结合Lua(之前一直想学Lua然后写饥荒m">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=3910186754,1957799350&fm=253&fmt=auto&app=138&f=JPEG?w=991&h=500">
<meta property="article:published_time" content="2023-05-25T07:11:57.000Z">
<meta property="article:modified_time" content="2024-04-08T14:29:56.870Z">
<meta property="article:author" content="HUANG jm">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=3910186754,1957799350&fm=253&fmt=auto&app=138&f=JPEG?w=991&h=500"><link rel="shortcut icon" href="/master/img/favicon.png"><link rel="canonical" href="https://hjianming.github.io/2023/05/25/RedisTry/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/master/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/master/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-08 22:29:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/master/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/master/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/master/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/master/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/master/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/master/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/master/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/master/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/master/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/master/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/master/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/master/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/master/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=3910186754,1957799350&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=991&amp;h=500')"><nav id="nav"><span id="blog-info"><a href="/master/" title="HUANGjm 's blog"><span class="site-name">HUANGjm 's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/master/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/master/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/master/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/master/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/master/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/master/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/master/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/master/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/master/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/master/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-25T07:11:57.000Z" title="发表于 2023-05-25 15:11:57">2023-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-08T14:29:56.870Z" title="更新于 2024-04-08 22:29:56">2024-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/master/categories/redis/">redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h2><ul>
<li><code>短信登录</code><ul>
<li>这部分会使用Redis共享session来实现</li>
<li>但其实我在之前的瑞吉外卖的项目优化部分就做过了，用Redis替换session来存储邮箱验证码</li>
</ul>
</li>
<li><code>商户查询缓存</code><ul>
<li>这部分要理解缓存击穿，缓存穿透，缓存雪崩等问题，对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</li>
</ul>
</li>
<li><code>优惠券秒杀</code><ul>
<li>这部分我们可以学会Redis的计数器功能，结合Lua(之前一直想学Lua然后写饥荒mod)完成高性能的Redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</li>
</ul>
</li>
<li><code>附近的商户</code><ul>
<li>利用Redis的GEOHash(新数据结构，前面没有应用场景就没介绍)来完成对于地理坐标的操作</li>
</ul>
</li>
<li><code>UV统计</code><ul>
<li>主要是使用Redis来完成统计功能</li>
</ul>
</li>
<li><code>用户签到</code><ul>
<li>使用Redis的BitMap数据统计功能</li>
</ul>
</li>
<li><code>好友关注</code><ul>
<li>基于Set集合的关注、取消关注，共同关注等等功能，这部分在上篇的练习题中出现过，这次我们在项目中来使用一下</li>
</ul>
</li>
<li><code>达人探店</code><ul>
<li>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</li>
</ul>
</li>
</ul>
<h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>在实现功能之前，我们先来导入项目，让项目跑起来</p>
<h4 id="导入SQL"><a href="#导入SQL" class="headerlink" title="导入SQL"></a>导入SQL</h4><p>黑马已经在资料中提供好了SQL文件，这里简单分析一下提供的表</p>
<table>
<thead>
<tr>
<th align="center">表</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tb_user</td>
<td align="center">用户表</td>
</tr>
<tr>
<td align="center">tb_user_info</td>
<td align="center">用户详情表</td>
</tr>
<tr>
<td align="center">tb_shop</td>
<td align="center">商户信息表</td>
</tr>
<tr>
<td align="center">tb_shop_type</td>
<td align="center">商户类型表</td>
</tr>
<tr>
<td align="center">tb_blog</td>
<td align="center">用户日记表（达人探店日记)</td>
</tr>
<tr>
<td align="center">tb_follow</td>
<td align="center">用户关注表</td>
</tr>
<tr>
<td align="center">tb_voucher</td>
<td align="center">优惠券表</td>
</tr>
<tr>
<td align="center">tb_voucher_order</td>
<td align="center">优惠券的订单表</td>
</tr>
</tbody></table>
<h4 id="有关当前模型"><a href="#有关当前模型" class="headerlink" title="有关当前模型"></a>有关当前模型</h4><ul>
<li>该项目采用的是前后端分离开发模式</li>
<li>手机或者app端发起请求，请求我们的Nginx服务器，Nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开Tomcat访问Redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游Tomcat服务器，打散流量，我们都知道一台4核8G的Tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过Nginx的负载均衡分流后，利用集群支撑起整个项目，同时Nginx在部署了前端项目后，更是可以做到动静分离，进一步降低Tomcat服务的压力，这些功能都得靠Nginx起作用，所以Nginx是整个项目中重要的一环。</li>
<li>在Tomcat支撑起并发流量后，我们如果让Tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6353709216f2c2beb134e44b.jpg"><img src="https://pic1.imgdb.cn/item/6353709216f2c2beb134e44b.jpg" alt="img"></a></p>
<h4 id="导入后端项目"><a href="#导入后端项目" class="headerlink" title="导入后端项目"></a>导入后端项目</h4><ul>
<li>黑马已经提供好了后端项目源码压缩包，我们将其解压之后，放到自己的workspace里</li>
<li>然后修改MySQL和Reids的连接要素为自己的，随后启动项目</li>
<li>访问<a target="_blank" rel="noopener" href="http://localhost:8081/shop-type/list">http://localhost:8081/shop-type/list</a> ，如果可以看到JSON数据，则说明导入成功</li>
</ul>
<h4 id="导入前端工程"><a href="#导入前端工程" class="headerlink" title="导入前端工程"></a>导入前端工程</h4><ul>
<li>黑马已经提供好了前端项目源码压缩包，我们将其解压之后，放到自己的workSpace里</li>
<li>然后在nginx所在目录打开一个cmd窗口，输入命令，即可启动项目</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">start nginx.exe</span><br></pre></td></tr></table></figure>

<ul>
<li>访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> ，打开开发者模式，可以看到页面<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6353775b16f2c2beb140da1d.jpg"><img src="https://pic1.imgdb.cn/item/6353775b16f2c2beb140da1d.jpg" alt="img"></a></li>
</ul>
<h3 id="基于Session实现登录流程"><a href="#基于Session实现登录流程" class="headerlink" title="基于Session实现登录流程"></a>基于Session实现登录流程</h3><ol>
<li>发送验证码<br>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号<br>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</li>
<li>短信验证码登录、注册<br>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</li>
<li>校验登录状态<br>用户在请求的时候，会从cookie中携带JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并放行</li>
</ol>
<h3 id="实现发送短信验证码功能"><a href="#实现发送短信验证码功能" class="headerlink" title="实现发送短信验证码功能"></a>实现发送短信验证码功能</h3><ul>
<li>输入手机号，点击发送验证码按钮，查看发送的请求</li>
</ul>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/user/code?phone=15832165478">http://localhost:8080/api/user/code?phone=15832165478</a><br>请求方法: POST</p>
</blockquote>
<ul>
<li>看样子是调用UserController中的code方法，携带参数是<code>phone</code>，看黑马提供的源码也证实了我的猜想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">    * 发送手机验证码</span><br><span class="line">    */</span><br><span class="line">@PostMapping(&quot;code&quot;)</span><br><span class="line">public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) &#123;</span><br><span class="line">    // TODO 发送短信验证码并保存验证码</span><br><span class="line">    return Result.fail(&quot;功能未完成&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是黑马这里并不会真的使用短信服务发送验证码，只是随机生成了一个验证码，那我这里为了后期项目能真的部署上线，还是打算用邮箱验证</li>
<li>由于黑马这里貌似没有设置前端的手机号正则判断，所以我们只需要去数据库中修改phone的字段类型，将varchar(11)改为varchar(100)</li>
<li>导入邮箱验证需要的maven坐标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/javax.activation/activation --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.activation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activation&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/javax.mail/mail --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.mail&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mail&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-email&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后编写一个工具类，用于发送邮件验证码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import javax.mail.Authenticator;</span><br><span class="line">import javax.mail.MessagingException;</span><br><span class="line">import javax.mail.PasswordAuthentication;</span><br><span class="line">import javax.mail.Session;</span><br><span class="line">import javax.mail.Transport;</span><br><span class="line">import javax.mail.internet.InternetAddress;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">import javax.mail.internet.MimeMessage.RecipientType;</span><br><span class="line"></span><br><span class="line">public class MailUtils &#123;</span><br><span class="line">    public static void main(String[] args) throws MessagingException &#123;</span><br><span class="line">        //可以在这里直接测试方法，填自己的邮箱即可</span><br><span class="line">        sendTestMail(&quot;1586385296@qq.com&quot;, new MailUtils().achieveCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sendTestMail(String email, String code) throws MessagingException &#123;</span><br><span class="line">        // 创建Properties 类用于记录邮箱的一些属性</span><br><span class="line">        Properties props = new Properties();</span><br><span class="line">        // 表示SMTP发送邮件，必须进行身份验证</span><br><span class="line">        props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);</span><br><span class="line">        //此处填写SMTP服务器</span><br><span class="line">        props.put(&quot;mail.smtp.host&quot;, &quot;smtp.qq.com&quot;);</span><br><span class="line">        //端口号，QQ邮箱端口587</span><br><span class="line">        props.put(&quot;mail.smtp.port&quot;, &quot;587&quot;);</span><br><span class="line">        // 此处填写，写信人的账号</span><br><span class="line">        props.put(&quot;mail.user&quot;, &quot;1586385296@qq.com&quot;);</span><br><span class="line">        // 此处填写16位STMP口令</span><br><span class="line">        props.put(&quot;mail.password&quot;, &quot;tXXXXXXXXXfgjb&quot;);</span><br><span class="line">        // 构建授权信息，用于进行SMTP进行身份验证</span><br><span class="line">        Authenticator authenticator = new Authenticator() &#123;</span><br><span class="line">            protected PasswordAuthentication getPasswordAuthentication() &#123;</span><br><span class="line">                // 用户名、密码</span><br><span class="line">                String userName = props.getProperty(&quot;mail.user&quot;);</span><br><span class="line">                String password = props.getProperty(&quot;mail.password&quot;);</span><br><span class="line">                return new PasswordAuthentication(userName, password);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 使用环境属性和授权信息，创建邮件会话</span><br><span class="line">        Session mailSession = Session.getInstance(props, authenticator);</span><br><span class="line">        // 创建邮件消息</span><br><span class="line">        MimeMessage message = new MimeMessage(mailSession);</span><br><span class="line">        // 设置发件人</span><br><span class="line">        InternetAddress form = new InternetAddress(props.getProperty(&quot;mail.user&quot;));</span><br><span class="line">        message.setFrom(form);</span><br><span class="line">        // 设置收件人的邮箱</span><br><span class="line">        InternetAddress to = new InternetAddress(email);</span><br><span class="line">        message.setRecipient(RecipientType.TO, to);</span><br><span class="line">        // 设置邮件标题</span><br><span class="line">        message.setSubject(&quot;Kyle&#x27;s Blog 邮件测试&quot;);</span><br><span class="line">        // 设置邮件的内容体</span><br><span class="line">        message.setContent(&quot;尊敬的用户:你好!\n注册验证码为:&quot; + code + &quot;(有效期为一分钟,请勿告知他人)&quot;, &quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        // 最后当然就是发送邮件啦</span><br><span class="line">        Transport.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String achieveCode() &#123;  //由于数字 1 、 0 和字母 O 、l 有时分不清楚，所以，没有数字 1 、 0</span><br><span class="line">        String[] beforeShuffle = new String[]&#123;&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;,</span><br><span class="line">                &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;a&quot;,</span><br><span class="line">                &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;,</span><br><span class="line">                &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(beforeShuffle);//将数组转换为集合</span><br><span class="line">        Collections.shuffle(list);  //打乱集合顺序</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (String s : list) &#123;</span><br><span class="line">            sb.append(s); //将集合转化为字符串</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.substring(3, 8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改sendCode方法，逻辑如下<ul>
<li>验证手机号&#x2F;邮箱格式<ul>
<li>不正确则返回错误信息</li>
<li>正确则发送验证码</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 发送手机验证码</span><br><span class="line">*/</span><br><span class="line">@PostMapping(&quot;/code&quot;)</span><br><span class="line">public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) throws MessagingException &#123;</span><br><span class="line">    // TODO 发送短信验证码并保存验证码</span><br><span class="line">    if (RegexUtils.isEmailInvalid(phone)) &#123;</span><br><span class="line">        return Result.fail(&quot;邮箱格式不正确&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    String code = MailUtils.achieveCode();</span><br><span class="line">    session.setAttribute(phone, code);</span><br><span class="line">    log.info(&quot;发送登录验证码：&#123;&#125;&quot;, code);</span><br><span class="line">    MailUtils.sendTestMail(phone, code);</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后输入邮箱，发送验证码，看看能否接收到验证码</li>
<li>测试没有问题之后，我们继续来编写登录功能，点击登录按钮，查看发送的请求</li>
</ul>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a><br>请求方法: POST</p>
</blockquote>
<ul>
<li>看样子是UserController中的login方法，携带的参数也就是我们的邮箱和验证码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON</span><br><span class="line">&#123;phone: &quot;1586385296@qq.com&quot;, code: &quot;iMPKc&quot;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>黑马提供的代码如下，看样子是把邮箱和验证码封装到了LoginFormDto中</p>
</li>
<li><p>login</p>
</li>
<li><p>LoginFormDTO</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * 登录功能</span><br><span class="line"> * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span><br><span class="line"> */</span><br><span class="line">@PostMapping(&quot;/login&quot;)</span><br><span class="line">public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session)&#123;</span><br><span class="line">    // TODO 实现登录功能</span><br><span class="line">    return Result.fail(&quot;功能未完成&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>修改login方法，逻辑如下</p>
<ul>
<li>校验手机号&#x2F;邮箱<ul>
<li>不正确则返回错误信息</li>
<li>正确则继续校验验证码<ul>
<li>不一致则报错</li>
<li>一致则先根据手机号&#x2F;邮箱查询用户<ul>
<li>用户不存在则创建</li>
<li>存在则继续执行程序</li>
</ul>
</li>
<li>保存用户信息到session中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>login</p>
</li>
<li><p>createUserWithPhone</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 登录功能</span><br><span class="line">*</span><br><span class="line">* @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span><br><span class="line">*/</span><br><span class="line">@PostMapping(&quot;/login&quot;)</span><br><span class="line">public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session) &#123;</span><br><span class="line">    // TODO 实现登录功能</span><br><span class="line">    //获取登录账号</span><br><span class="line">    String phone = loginForm.getPhone();</span><br><span class="line">    //获取登录验证码</span><br><span class="line">    String code = loginForm.getCode();</span><br><span class="line">    //获取session中的验证码</span><br><span class="line">    Object cacheCode = session.getAttribute(phone);</span><br><span class="line"></span><br><span class="line">    //1. 校验邮箱</span><br><span class="line">    if (RegexUtils.isEmailInvalid(phone)) &#123;</span><br><span class="line">        //2. 不符合格式则报错</span><br><span class="line">        return Result.fail(&quot;邮箱格式不正确！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 校验验证码</span><br><span class="line">    log.info(&quot;code:&#123;&#125;,cacheCode&#123;&#125;&quot;, code, cacheCode);</span><br><span class="line">    if (code == null || !cacheCode.toString().equals(code)) &#123;</span><br><span class="line">        //4. 不一致则报错</span><br><span class="line">        return Result.fail(&quot;验证码不一致！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //5. 根据账号查询用户是否存在</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(User::getPhone, phone);</span><br><span class="line">    User user = userService.getOne(queryWrapper);</span><br><span class="line">    //6. 如果不存在则创建</span><br><span class="line">    if (user == null) &#123;</span><br><span class="line">        // 创建的逻辑封装成了一个方法</span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    //7. 保存用户信息到session中</span><br><span class="line">    session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现登录拦截功能"><a href="#实现登录拦截功能" class="headerlink" title="实现登录拦截功能"></a>实现登录拦截功能</h3><ul>
<li>这部分需要用到拦截器的知识，我在前面的SSM整合篇做过详细介绍</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6335135c16f2c2beb100182d.jpg"><img src="https://pic1.imgdb.cn/item/6335135c16f2c2beb100182d.jpg" alt="img"></a></p>
<p>SSM整合</p>
<p><a target="_blank" rel="noopener" href="https://cyborg2077.github.io/2022/09/10/SSMIntegration/">https://cyborg2077.github.io/2022/09/10/SSMIntegration/</a></p>
<ul>
<li><p>创建一个LoginInterceptor类，实现HandlerInterceptor接口，重写其中的两个方法，前置拦截器和完成处理方法，前置拦截器主要用于我们登陆之前的权限校验，完成处理方法是用于处理登录后的信息，避免内存泄露</p>
</li>
<li><p>LoginInterceptor</p>
</li>
<li><p>UserHolder</p>
</li>
<li><p>MvcConfig</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        //1. 获取session</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        //2. 获取session中的用户信息</span><br><span class="line">        User user = (User) session.getAttribute(&quot;user&quot;);</span><br><span class="line">        //3. 判断用户是否存在</span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            //4. 不存在，则拦截</span><br><span class="line">            response.setStatus(401);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //5. 存在，保存用户信息到ThreadLocal，UserHolder是提供好了的工具类</span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line">        //6. 放行</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>顺便再写一下me方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@GetMapping(&quot;/me&quot;)</span><br><span class="line">public Result me() &#123;</span><br><span class="line">    // TODO 获取当前登录的用户并返回</span><br><span class="line">    User user = UserHolder.getUser();</span><br><span class="line">    return Result.ok(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><ul>
<li>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JSON</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;success&quot;:true,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;id&quot;:1010,</span><br><span class="line">        &quot;phone&quot;:&quot;1586385296@qq.com&quot;,</span><br><span class="line">        &quot;password&quot;:&quot;&quot;,</span><br><span class="line">        &quot;nickName&quot;:&quot;user_i1b3ir09&quot;,</span><br><span class="line">        &quot;icon&quot;:&quot;&quot;,</span><br><span class="line">        &quot;createTime&quot;:&quot;2022-10-22T14:20:33&quot;,</span><br><span class="line">        &quot;updateTime&quot;:&quot;2022-10-22T14:20:33&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserDto类如下，将User对象中的属性拷贝给UserDto，就可以避免暴露用户的隐藏信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Data</span><br><span class="line">public class UserDTO &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String nickName;</span><br><span class="line">    private String icon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改UserHolder，将其User类型都换为UserDto</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public class UserHolder &#123;</span><br><span class="line">    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void saveUser(UserDTO user)&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static UserDTO getUser()&#123;</span><br><span class="line">        return tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void removeUser()&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改login方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DIFF</span><br><span class="line"></span><br><span class="line">   @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session) &#123;</span><br><span class="line">        // TODO 实现登录功能</span><br><span class="line">        //获取登录账号</span><br><span class="line">        String phone = loginForm.getPhone();</span><br><span class="line">        //获取登录验证码</span><br><span class="line">        String code = loginForm.getCode();</span><br><span class="line">        //获取session中的验证码</span><br><span class="line">        Object cacheCode = session.getAttribute(phone);</span><br><span class="line"></span><br><span class="line">        //1. 校验邮箱</span><br><span class="line">        if (RegexUtils.isEmailInvalid(phone)) &#123;</span><br><span class="line">            //2. 不符合格式则报错</span><br><span class="line">            return Result.fail(&quot;邮箱格式不正确！！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //3. 校验验证码</span><br><span class="line">        log.info(&quot;code:&#123;&#125;,cacheCode&#123;&#125;&quot;, code, cacheCode);</span><br><span class="line">        if (code == null || !cacheCode.toString().equals(code)) &#123;</span><br><span class="line">            //4. 不一致则报错</span><br><span class="line">            return Result.fail(&quot;验证码不一致！！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //5. 根据账号查询用户是否存在</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(User::getPhone, phone);</span><br><span class="line">        User user = userService.getOne(queryWrapper);</span><br><span class="line">        //6. 如果不存在则创建</span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line">        //7. 保存用户信息到session中</span><br><span class="line">-       session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">+       UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">+       session.setAttribute(&quot;user&quot;, userDTO);</span><br><span class="line">        return Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改拦截器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DIFF</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        //1. 获取session</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        //2. 获取session中的用户信息</span><br><span class="line">-       User user = (User) session.getAttribute(&quot;user&quot;);</span><br><span class="line">+       UserDTO user = (UserDTO) session.getAttribute(&quot;user&quot;);</span><br><span class="line">        //3. 判断用户是否存在</span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            //4. 不存在，则拦截</span><br><span class="line">            response.setStatus(401);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //5. 存在，保存用户信息到ThreadLocal，UserHolder是提供好了的工具类</span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line">        //6. 放行</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启服务器，登录后查看此时的用户信息，敏感信息已经不存在了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSON</span><br><span class="line">&#123;</span><br><span class="line">    &quot;success&quot;:true,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;id&quot;:1016,</span><br><span class="line">        &quot;nickName&quot;:&quot;user_zkhf7cfv&quot;,</span><br><span class="line">        &quot;icon&quot;:&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h3><ul>
<li>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</li>
<li>但是这种方案具有两个大问题<ol>
<li>每台服务器中都有完整的一份session数据，服务器压力过大。</li>
<li>session拷贝数据时，可能会出现延迟</li>
</ol>
</li>
<li>所以我们后面都是基于Redis来完成，我们把session换成Redis，Redis数据本身就是共享的，就可以避免session共享的问题了</li>
</ul>
<h3 id="Redis替代session的业务流程"><a href="#Redis替代session的业务流程" class="headerlink" title="Redis替代session的业务流程"></a>Redis替代session的业务流程</h3><h4 id="设计key结构"><a href="#设计key结构" class="headerlink" title="设计key结构"></a>设计key结构</h4><ul>
<li>首先我们来思考一下该用什么数据结构来存储数据</li>
<li>由于存入的数据比较简单，我们可以使用String或者Hash<ul>
<li>如果使用String，以JSON字符串来保存数据，会额外占用部分空间</li>
<li>如果使用Hash，则它的value中只会存储数据本身</li>
</ul>
</li>
<li>如果不是特别在意内存，直接使用String就好了</li>
</ul>
<h4 id="设计key的具体细节"><a href="#设计key的具体细节" class="headerlink" title="设计key的具体细节"></a>设计key的具体细节</h4><ul>
<li>我们这里就采用的是简单的K-V键值对方式</li>
<li>但是对于key的处理，不能像session一样用phone或code来当做key</li>
<li>因为Redis的key是共享的，code可能会重复，phone这种敏感字段也不适合存储到Redis中</li>
<li>在设计key的时候，我们需要满足两点<ol>
<li>key要有唯一性</li>
<li>key要方便携带</li>
</ol>
</li>
<li>所以我们在后台随机生成一个token，然后让前端带着这个token就能完成我们的业务逻辑了</li>
</ul>
<h4 id="整体访问流程"><a href="#整体访问流程" class="headerlink" title="整体访问流程"></a>整体访问流程</h4><ul>
<li>当注册完成后，用户去登录，然后校验用户提交的手机号&#x2F;邮箱和验证码是否一致<ul>
<li>如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到Redis，并生成一个token作为Redis的key</li>
</ul>
</li>
<li>当我们校验用户是否登录时，回去携带着token进行访问，从Redis中获取token对应的value，判断是否存在这个数据<ul>
<li>如果不存在，则拦截</li>
<li>如果存在，则将其用户信息(userDto)保存到threadLocal中，并放行</li>
</ul>
</li>
</ul>
<h3 id="基于Redis实现短信登录"><a href="#基于Redis实现短信登录" class="headerlink" title="基于Redis实现短信登录"></a>基于Redis实现短信登录</h3><ul>
<li>由于前面已经分析过业务逻辑了，所以这里我们直接开始写代码，在此之前我们要在UserController中注入<code>StringRedisTemplate</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改sendCode方法</p>
</li>
<li><p>修改sendCode方法</p>
</li>
<li><p>RedisConstants</p>
</li>
</ul>
<p>这里的key使用用<code>login:code:email</code>的形式，并设置有效期2分钟，我们也可以定义一个常量类来替换这里的<code>login:code:</code>和<code>2</code>，让代码显得更专业一点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DIFF</span><br><span class="line"></span><br><span class="line">@PostMapping(&quot;/code&quot;)</span><br><span class="line">public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) throws MessagingException &#123;</span><br><span class="line">    // TODO 发送短信验证码并保存验证码</span><br><span class="line">    if (RegexUtils.isEmailInvalid(phone)) &#123;</span><br><span class="line">        return Result.fail(&quot;邮箱格式不正确&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    String code = MailUtils.achieveCode();</span><br><span class="line">-   session.setAttribute(phone, code);</span><br><span class="line">-   stringRedisTemplate.opsForValue().set(&quot;login:code:&quot; + phone, code, 2, TimeUnit.MINUTES);</span><br><span class="line">+   stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">    log.info(&quot;发送登录验证码：&#123;&#125;&quot;, code);</span><br><span class="line">//        MailUtils.sendTestMail(phone, code);</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>修改login方法</p>
</li>
<li><p>DIFF</p>
</li>
<li><p>修改后代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">DIFF</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session) &#123;</span><br><span class="line">        // TODO 实现登录功能</span><br><span class="line">        //获取登录账号</span><br><span class="line">        String phone = loginForm.getPhone();</span><br><span class="line">        //获取登录验证码</span><br><span class="line">        String code = loginForm.getCode();</span><br><span class="line">-       //获取session中的验证码</span><br><span class="line">-       Object cacheCode = session.getAttribute(phone);</span><br><span class="line">+       //获取redis中的验证码</span><br><span class="line">+       String sessionCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + userCode);</span><br><span class="line">        //1. 校验邮箱</span><br><span class="line">        if (RegexUtils.isEmailInvalid(phone)) &#123;</span><br><span class="line">            //2. 不符合格式则报错</span><br><span class="line">            return Result.fail(&quot;邮箱格式不正确！！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //3. 校验验证码</span><br><span class="line">        log.info(&quot;code:&#123;&#125;,cacheCode&#123;&#125;&quot;, code, cacheCode);</span><br><span class="line">        if (code == null || !cacheCode.toString().equals(code)) &#123;</span><br><span class="line">            //4. 不一致则报错</span><br><span class="line">            return Result.fail(&quot;验证码不一致！！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //5. 根据账号查询用户是否存在</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(User::getPhone, phone);</span><br><span class="line">        User user = userService.getOne(queryWrapper);</span><br><span class="line">        //6. 如果不存在则创建</span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line">-       //7. 保存用户信息到session中</span><br><span class="line">+       //7. 保存用户信息到Redis中</span><br><span class="line">+       //7.1 随机生成token，作为登录令牌</span><br><span class="line">+       String token = UUID.randomUUID().toString();</span><br><span class="line">+       //7.2 将UserDto对象转为HashMap存储</span><br><span class="line">+       UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">+       HashMap&lt;String, String &gt; userMap = new HashMap&lt;&gt;();</span><br><span class="line">+       userMap.put(&quot;icon&quot;, userDTO.getIcon());</span><br><span class="line">+       userMap.put(&quot;id&quot;, String.valueOf(userDTO.getId()));</span><br><span class="line">+       userMap.put(&quot;nickName&quot;, userDTO.getNickName(    ));</span><br><span class="line">+       //7.3 存储</span><br><span class="line">+       String tokenKey = LOGIN_USER_KEY + token;</span><br><span class="line">+       stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">+       //7.4 设置token有效期为30分钟</span><br><span class="line">+       stringRedisTemplate.expire(tokenKey, 30, TimeUnit.MINUTES);</span><br><span class="line">+       //7.5 登陆成功则删除验证码信息</span><br><span class="line">+       stringRedisTemplate.delete(LOGIN_CODE_KEY + phone);</span><br><span class="line">-       session.setAttribute(&quot;user&quot;, userDTO);</span><br><span class="line">+       //8. 返回token</span><br><span class="line">+       return Result.ok(token);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="解决状态登录刷新问题"><a href="#解决状态登录刷新问题" class="headerlink" title="解决状态登录刷新问题"></a>解决状态登录刷新问题</h3><h4 id="初始方案"><a href="#初始方案" class="headerlink" title="初始方案"></a>初始方案</h4><ul>
<li>我们可以通过拦截器拦截到的请求，来证明用户是否在操作，如果用户没有任何操作30分钟，则token会消失，用户需要重新登录</li>
<li>通过查看请求，我们发现我们存的token在请求头里，那么我们就在拦截器里来刷新token的存活时间</li>
</ul>
<blockquote>
<p>authorization: 6867061d-a8d0-4e60-b92f-97f7d698a1ca</p>
</blockquote>
<ul>
<li>修改我们的登陆拦截器<code>LoginInterceptor</code>类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    //1. 获取请求头中的token</span><br><span class="line">    String token = request.getHeader(&quot;authorization&quot;);</span><br><span class="line">    //2. 如果token是空，则未登录，拦截</span><br><span class="line">    if (StrUtil.isBlank(token)) &#123;</span><br><span class="line">        response.setStatus(401);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    String key = RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">    //3. 基于token获取Redis中的用户数据</span><br><span class="line">    Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">    //4. 判断用户是否存在，不存在，则拦截</span><br><span class="line">    if (userMap.isEmpty()) &#123;</span><br><span class="line">        response.setStatus(401);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //5. 将查询到的Hash数据转化为UserDto对象</span><br><span class="line">    UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);</span><br><span class="line">    //6. 将用户信息保存到ThreadLocal</span><br><span class="line">    UserHolder.saveUser(userDTO);</span><br><span class="line">    //7. 刷新tokenTTL，这里的存活时间根据需要自己设置，这里的常量值我改为了30分钟</span><br><span class="line">    stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6353edd016f2c2beb1f967f0.jpg"><img src="https://pic1.imgdb.cn/item/6353edd016f2c2beb1f967f0.jpg" alt="img"></a></p>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><ul>
<li>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6353ef1416f2c2beb1fb5e48.jpg"><img src="https://pic1.imgdb.cn/item/6353ef1416f2c2beb1fb5e48.jpg" alt="img"></a></p>
<ul>
<li>新建一个<code>RefreshTokenInterceptor</code>类，其业务逻辑与之前的<code>LoginInterceptor</code>类似，就算遇到用户未登录，也继续放行，交给<code>LoginInterceptor</code>处理<br>由于这个对象是我们手动在WebConfig里创建的，所以这里不能用@AutoWired自动装配，只能声明一个私有的，到了WebConfig里再自动装配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public class RefreshTokenInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    //这里并不是自动装配，因为RefreshTokenInterceptor是我们手动在WebConfig里new出来的</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        //1. 获取请求头中的token</span><br><span class="line">        String token = request.getHeader(&quot;authorization&quot;);</span><br><span class="line">        //2. 如果token是空，直接放行，交给LoginInterceptor处理</span><br><span class="line">        if (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        //3. 基于token获取Redis中的用户数据</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        //4. 判断用户是否存在，不存在，也放行，交给LoginInterceptor</span><br><span class="line">        if (userMap.isEmpty()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //5. 将查询到的Hash数据转化为UserDto对象</span><br><span class="line">        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);</span><br><span class="line">        //6. 将用户信息保存到ThreadLocal</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        //7. 刷新tokenTTL，这里的存活时间根据需要自己设置，这里的常量值我改为了30分钟</span><br><span class="line">        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改我们之前的<code>LoginInterceptor</code>类，只需要判断用户是否存在，不存在，则拦截，存在则放行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        //判断用户是否存在</span><br><span class="line">        if (UserHolder.getUser()==null)&#123;</span><br><span class="line">            //不存在则拦截</span><br><span class="line">            response.setStatus(401);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //存在则放行</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>WebConfig</code>配置类，拦截器的执行顺序可以由order来指定，如果未设置拦截路径，则默认是拦截所有路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    //到了这里才能自动装配</span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        &quot;/user/code&quot;,</span><br><span class="line">                        &quot;/user/login&quot;,</span><br><span class="line">                        &quot;/blog/hot&quot;,</span><br><span class="line">                        &quot;/shop/**&quot;,</span><br><span class="line">                        &quot;/shop-type/**&quot;,</span><br><span class="line">                        &quot;/upload/**&quot;,</span><br><span class="line">                        &quot;/voucher/**&quot;</span><br><span class="line">                ).order(1);</span><br><span class="line">        //RefreshTokenInterceptor是我们手动new出来的</span><br><span class="line">        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).order(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>那么至此，大功告成，我们重启服务器，登录，然后去Redis的图形化界面查看token的ttl，如果每次切换界面之后，ttl都会重置，那么说明我们的代码没有问题</li>
</ul>
<h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h3><ul>
<li><p>什么是缓存？</p>
<ul>
<li>缓存就像自行车、越野车的避震器</li>
</ul>
</li>
<li><p>举个例子</p>
<ul>
<li>越野车、山地自行车都有<code>避震器</code>，防止车体加速之后因惯性，在<code>U</code>型地形上飞跃硬着陆导致<code>损坏</code>，像个弹簧意义</li>
</ul>
</li>
<li><p>同样，在实际开发中，系统也需要<code>避震器</code>，防止过高的数据量猛冲系统，导致其操作线程无法及时处理信息而瘫痪</p>
</li>
<li><p>在实际开发中，对企业来讲，产品口碑、用户评价都是致命的，所以企业非常重视缓存技术</p>
</li>
<li><p><code>缓存</code>(Cache)就是数据交换的<code>缓冲区</code>，俗称的缓存就是缓冲区内的数据，一般从数据库中获取，存储于本地，例如</p>
</li>
<li><p>本地用高并发</p>
</li>
<li><p>用于Redis等缓存</p>
</li>
<li><p>本地缓存</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Static final ConcurrentHashMap&lt;K,V&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>



<ul>
<li>由于其被<code>static</code>修饰，所以随着类的加载而加载到内存之中，作为本地缓存，由于其又被<code>final</code>修饰，所以其引用之间的关系是固定的，不能改变，因此不用担心复制导致缓存失败</li>
</ul>
<h4 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h4><ul>
<li><p>言简意赅：速度快，好用</p>
</li>
<li><p>缓存数据存储于代码中，而代码运行在内存中，内存的读写性能远高于磁盘，缓存可以大大降低用户访问并发量带来的服务器读写压力</p>
</li>
<li><p>实际开发中，企业的数据量，少则几十万，多则几千万，这么大的数据量，如果没有缓存来作为<code>避震器</code>系统是几乎撑不住的，所以企业会大量运用缓存技术</p>
</li>
<li><p>但是缓存也会增加代码复杂度和运营成本</p>
</li>
<li><pre><code>缓存的作用
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  1. 降低后端负载</span><br><span class="line">  2. 提高读写效率，降低响应时间</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  缓存的成本</span><br></pre></td></tr></table></figure>

1. 数据一致性成本
2. 代码维护成本
3. 运维成本（一般采用服务器集群，需要多加机器，机器就是钱）
</code></pre>
</li>
</ul>
<h4 id="如何使用缓存"><a href="#如何使用缓存" class="headerlink" title="如何使用缓存"></a>如何使用缓存</h4><ul>
<li>实际开发中，会构筑多级缓存来时系统运行速度进一步提升，例如：本地缓存与Redis中的缓存并发使用</li>
<li><code>浏览器缓存：</code>主要是存在于浏览器端的缓存</li>
<li><code>应用层缓存：</code>可以分为toncat本地缓存，例如之前提到的map或者是使用Redis作为缓存</li>
<li><code>数据库缓存：</code>在数据库中有一片空间是buffer pool，增改查数据都会先加载到mysql的缓存中</li>
<li><code>CPU缓存：</code>当代计算机最大的问题就是CPU性能提升了，但是内存读写速度没有跟上，所以为了适应当下的情况，增加了CPU的L1，L2，L3级的缓存</li>
</ul>
<h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><ul>
<li>我们先启动前端和后端的项目，登陆之后随便访问一个商户，查看浏览器发送的请求</li>
</ul>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/shop/10">http://localhost:8080/api/shop/10</a><br>请求方法: GET</p>
</blockquote>
<ul>
<li>不出意外是<code>ShopController</code>里的业务逻辑，而且restFul风格的</li>
<li>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库肯定慢</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">    * 根据id查询商铺信息</span><br><span class="line">    * @param id 商铺id</span><br><span class="line">    * @return 商铺详情数据</span><br><span class="line">    */</span><br><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    return Result.ok(shopService.getById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以我们可以在客户端与数据库之间加上一个Redis缓存，先从Redis中查询，如果没有查到，再去MySQL中查询，同时查询完毕之后，将查询到的数据也存入Redis，这样当下一个用户来进行查询的时候，就可以直接从Redis中获取到数据</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6354a19216f2c2beb1b095dd.jpg"><img src="https://pic1.imgdb.cn/item/6354a19216f2c2beb1b095dd.jpg" alt="img"></a></p>
<h4 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h4><ul>
<li>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入Redis。<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6354a1aa16f2c2beb1b0aa83.jpg"><img src="https://pic1.imgdb.cn/item/6354a1aa16f2c2beb1b0aa83.jpg" alt="img"></a></li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li><p>代码思路：如果Redis缓存里有数据，那么直接返回，如果缓存中没有，则去查询数据库，然后存入Redis</p>
</li>
<li><p>Controller层</p>
</li>
<li><p>Servie层</p>
</li>
<li><p>ServieImpl层</p>
</li>
</ul>
<p>业务逻辑我们写到Service中，需要在Service层创建这个<code>queryById</code>方法，然后去ServiceImpl中实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    return shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>重启服务器，访问商户信息，观察控制台日志输出，后续刷新页面，不会出现SQL语句查询商户信息，去Redis图形化界面中查看，可以看到缓存的商户信息数据</li>
</ul>
<h4 id="趁热打铁"><a href="#趁热打铁" class="headerlink" title="趁热打铁"></a>趁热打铁</h4><ul>
<li><p>完成了商户数据缓存之后，我们尝试做一下商户类型数据缓存</p>
</li>
<li><p>Controller层</p>
</li>
<li><p>Service层</p>
</li>
<li><p>ServiceImpl层</p>
</li>
</ul>
<p>业务逻辑依旧是写在Service中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@GetMapping(&quot;list&quot;)</span><br><span class="line">public Result queryTypeList() &#123;</span><br><span class="line">    return typeService.queryList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IShopService extends IService&lt;Shop&gt; &#123;</span><br><span class="line">    Result queryById(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result queryById(Long id) &#123;</span><br><span class="line">    //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    //如果不为空（查询到了），则转为Shop类型直接返回</span><br><span class="line">    if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        Shop shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        return Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    //否则去数据库中查</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    //查不到返回一个错误信息或者返回空都可以，根据自己的需求来</span><br><span class="line">    if (shop == null)&#123;</span><br><span class="line">        return Result.fail(&quot;店铺不存在！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //查到了则转为json字符串</span><br><span class="line">    String jsonStr = JSONUtil.toJsonStr(shop);</span><br><span class="line">    //并存入redis</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr);</span><br><span class="line">    //最终把查询到的商户信息返回给前端</span><br><span class="line">    return Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><ul>
<li>缓存更新是Redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们想Redis插入太多数据，此时就可能会导致缓存中数据过多，所以Redis会对部分数据进行更新，或者把它成为淘汰更合适</li>
<li><code>内存淘汰</code>：Redis自动进行，当Redis内存大道我们设定的<code>max-memery</code>时，会自动触发淘汰机制，淘汰掉一些不重要的数据（可以自己设置策略方式）</li>
<li><code>超时剔除</code>：当我们给Redis设置了过期时间TTL之后，Redis会将超时的数据进行删除，方便我们继续使用缓存</li>
<li><code>主动更新</code>：我们可以手动调用方法把缓存删除掉，通常用于解决缓存和数据库不一致问题</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">内存淘汰</th>
<th align="center">超时剔除</th>
<th align="center">主动更新</th>
</tr>
</thead>
<tbody><tr>
<td align="center">说明</td>
<td align="center">不用自己维护， 利用Redis的内存淘汰机制， 当内存不足时自动淘汰部分数据。 下次查询时更新缓存。</td>
<td align="center">给缓存数据添加TTL时间， 到期后自动删除缓存。 下次查询时更新缓存。</td>
<td align="center">编写业务逻辑， 在修改数据库的同时， 更新缓存。</td>
</tr>
<tr>
<td align="center">一致性</td>
<td align="center">差</td>
<td align="center">一般</td>
<td align="center">好</td>
</tr>
<tr>
<td align="center">维护成本</td>
<td align="center">无</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
</tbody></table>
<ul>
<li>业务场景<ul>
<li>低一致性需求：使用内存淘汰机制，例如店铺类型的查询缓存（因为这个很长一段时间都不需要更新）</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案，例如店铺详情查询的缓存</li>
</ul>
</li>
</ul>
<h4 id="数据库和缓存不一致解决方案"><a href="#数据库和缓存不一致解决方案" class="headerlink" title="数据库和缓存不一致解决方案"></a>数据库和缓存不一致解决方案</h4><ul>
<li>由于我们的缓存数据源来自数据库，而数据库的数据是会发生变化的，因此，如果当数据库中数据发生变化，而缓存却没有同步，此时就会有一致性问题存在，其后果是<ul>
<li>用户使用缓存中的过时数据，就会产生类似多线程数据安全问题，从而影响业务，产品口碑等</li>
</ul>
</li>
<li>那么如何解决这个问题呢？有如下三种方式<ol>
<li>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库之后再去更新缓存，也称之为双写方案</li>
<li>Read&#x2F;Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高</li>
<li>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，最终实现一致性。但是维护这样的一个异步的任务很复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了</li>
</ol>
</li>
</ul>
<h4 id="数据库和缓存不一致采用什么方案"><a href="#数据库和缓存不一致采用什么方案" class="headerlink" title="数据库和缓存不一致采用什么方案"></a>数据库和缓存不一致采用什么方案</h4><ul>
<li>综上所述，在企业的实际应用中，还是方案一最可靠，但是方案一的调用者该如何处理呢？</li>
<li>如果采用方案一，假设我们每次操作完数据库之后，都去更新一下缓存，但是如果中间并没有人查询数据，那么这个更新动作只有最后一次是有效的，中间的更新动作意义不大，所以我们可以把缓存直接删除，等到有人再次查询时，再将缓存中的数据加载出来</li>
<li>对比删除缓存与更新缓存<ul>
<li><code>更新缓存</code>：每次更新数据库都需要更新缓存，无效写操作较多</li>
<li><code>删除缓存</code>：更新数据库时让缓存失效，再次查询时更新缓存</li>
</ul>
</li>
<li>如何保证缓存与数据库的操作同时成功&#x2F;同时失败<ul>
<li><code>单体系统：</code>将缓存与数据库操作放在同一个事务</li>
<li><code>分布式系统：</code>利用TCC等分布式事务方案</li>
</ul>
</li>
<li>先操作缓存还是先操作数据库？我们来仔细分析一下这两种方式的线程安全问题</li>
<li>先删除缓存，再操作数据库<br>删除缓存的操作很快，但是更新数据库的操作相对较慢，如果此时有一个线程2刚好进来查询缓存，由于我们刚刚才删除缓存，所以线程2需要查询数据库，并写入缓存，但是我们更新数据库的操作还未完成，所以线程2查询到的数据是脏数据，出现线程安全问题<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6354be3e16f2c2beb1d11bd0.jpg"><img src="https://pic1.imgdb.cn/item/6354be3e16f2c2beb1d11bd0.jpg" alt="img"></a></li>
<li>先操作数据库，再删除缓存<br>线程1在查询缓存的时候，缓存TTL刚好失效，需要查询数据库并写入缓存，这个操作耗时相对较短（相比较于上图来说），但是就在这么短的时间内，线程2进来了，更新数据库，删除缓存，但是线程1虽然查询完了数据（更新前的旧数据），但是还没来得及写入缓存，所以线程2的更新数据库与删除缓存，并没有影响到线程1的查询旧数据，写入缓存，造成线程安全问题<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6354be5316f2c2beb1d130c0.jpg"><img src="https://pic1.imgdb.cn/item/6354be5316f2c2beb1d130c0.jpg" alt="img"></a></li>
<li>虽然这二者都存在线程安全问题，但是相对来说，后者出现线程安全问题的概率相对较低，所以我们最终采用后者<code>先操作数据库，再删除缓存</code>的方案</li>
</ul>
<h3 id="实现商铺缓存与数据库双写一致"><a href="#实现商铺缓存与数据库双写一致" class="headerlink" title="实现商铺缓存与数据库双写一致"></a>实现商铺缓存与数据库双写一致</h3><ul>
<li><p>核心思路如下</p>
<ul>
<li>修改ShopController中的业务逻辑，满足以下要求</li>
</ul>
<ol>
<li>根据id查询店铺时，如果缓存未命中，则查询数据库，并将数据库结果写入缓存，并设置TTL</li>
<li>根据id修改店铺时，先修改数据库，再删除缓存</li>
</ol>
</li>
<li><p>修改ShopService的queryById方法，写入缓存时设置一下TTL</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result queryById(Long id) &#123;</span><br><span class="line">    //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    //如果不为空（查询到了），则转为Shop类型直接返回</span><br><span class="line">    if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        Shop shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        return Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    //否则去数据库中查</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    //查不到返回一个错误信息或者返回空都可以，根据自己的需求来</span><br><span class="line">    if (shop == null)&#123;</span><br><span class="line">        return Result.fail(&quot;店铺不存在！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //查到了则转为json字符串</span><br><span class="line">    String jsonStr = JSONUtil.toJsonStr(shop);</span><br><span class="line">    //并存入redis，设置TTL</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr,CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    //最终把查询到的商户信息返回给前端</span><br><span class="line">    return Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改update方法</p>
</li>
<li><p>之前的update方法</p>
</li>
<li><p>修改后的update方法</p>
</li>
<li><p>Service层</p>
</li>
<li><p>ServiceImpl层</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 更新商铺信息</span><br><span class="line">    *</span><br><span class="line">    * @param shop 商铺数据</span><br><span class="line">    * @return 无</span><br><span class="line">    */</span><br><span class="line">@PutMapping</span><br><span class="line">public Result updateShop(@RequestBody Shop shop) &#123;</span><br><span class="line">    // 写入数据库</span><br><span class="line">    shopService.updateById(shop);</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>修改完毕之后我们重启服务器进行测试，首先随便挑一个顺眼的数据，我这里就是拿餐厅数据做测试，，我们先访问该餐厅，将该餐厅的数据缓存到Redis中，之后使用POSTMAN发送PUT请求，请求路径<a target="_blank" rel="noopener" href="http://localhost:8080/api/shop/">http://localhost:8080/api/shop/</a> ，携带JSON数据如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JSON</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;area&quot;: &quot;大关&quot;,</span><br><span class="line">  &quot;openHours&quot;: &quot;10:00-22:00&quot;,</span><br><span class="line">  &quot;sold&quot;: 4215,</span><br><span class="line">  &quot;address&quot;: &quot;金华路锦昌文华苑29号&quot;,</span><br><span class="line">  &quot;comments&quot;: 3035,</span><br><span class="line">  &quot;avgPrice&quot;: 80,</span><br><span class="line">  &quot;score&quot;: 37,</span><br><span class="line">  &quot;name&quot;: &quot;476茶餐厅&quot;,</span><br><span class="line">  &quot;typeId&quot;: 1,</span><br><span class="line">  &quot;id&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之后再Redis图形化页面刷新数据，发现该餐厅的数据确实不在Redis中了，之后我们刷新网页，餐厅名会被改为<code>476茶餐厅</code>，然后我们再去Redis中刷新，发现新数据已经被缓存了</li>
<li>那么现在功能就实现完毕了，只有当我们刷新页面的时候，才会重新查询数据库，并将数据缓存到Redis，中途无论修改多少次，只要不刷新页面访问，Redis中都不会更新数据</li>
</ul>
<h3 id="缓存穿透问题的解决思路"><a href="#缓存穿透问题的解决思路" class="headerlink" title="缓存穿透问题的解决思路"></a>缓存穿透问题的解决思路</h3><ul>
<li><code>缓存穿透</code>：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远都不会生效（只有数据库查到了，才会让redis缓存，但现在的问题是查不到），会频繁的去访问数据库。</li>
<li>常见的结局方案有两种<ol>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：额外的内存消耗，可能造成短期的不一致</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用啥哦，没有多余的key</li>
<li>缺点：实现复杂，可能存在误判</li>
</ul>
</li>
</ol>
</li>
<li><code>缓存空对象</code>思路分析：当我们客户端访问不存在的数据时，会先请求redis，但是此时redis中也没有数据，就会直接访问数据库，但是数据库里也没有数据，那么这个数据就穿透了缓存，直击数据库。但是数据库能承载的并发不如redis这么高，所以如果大量的请求同时都来访问这个不存在的数据，那么这些请求就会访问到数据库，简单的解决方案就是哪怕这个数据在数据库里不存在，我们也把这个这个数据存在redis中去（这就是为啥说会有<code>额外的内存消耗</code>），这样下次用户过来访问这个不存在的数据时，redis缓存中也能找到这个数据，不用去查数据库。可能造成的<code>短期不一致</code>是指在空对象的存活期间，我们更新了数据库，把这个空对象变成了正常的可以访问的数据，但由于空对象的TTL还没过，所以当用户来查询的时候，查询到的还是空对象，等TTL过了之后，才能访问到正确的数据，不过这种情况很少见罢了</li>
<li><code>布隆过滤</code>思路分析：布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，根据哈希思想去判断当前这个要查询的数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库里一定会存在这个数据，从数据库中查询到数据之后，再将其放到redis中。如果布隆过滤器判断这个数据不存在，则直接返回。这种思想的优点在于节约内存空间，但存在误判，误判的原因在于：布隆过滤器使用的是哈希思想，只要是哈希思想，都可能存在哈希冲突</li>
</ul>
<h3 id="编码解决商品查询的缓存穿透问题"><a href="#编码解决商品查询的缓存穿透问题" class="headerlink" title="编码解决商品查询的缓存穿透问题"></a>编码解决商品查询的缓存穿透问题</h3><ul>
<li>核心思路如下</li>
<li>在原来的逻辑中，我们如果发现这个数据在MySQL中不存在，就直接返回一个错误信息了，但是这样存在缓存穿透问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result queryById(Long id) &#123;</span><br><span class="line">    //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    //如果不为空（查询到了），则转为Shop类型直接返回</span><br><span class="line">    if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        Shop shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        return Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    //否则去数据库中查</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    //查不到返回一个错误信息或者返回空都可以，根据自己的需求来</span><br><span class="line">    if (shop == null)&#123;</span><br><span class="line">        return Result.fail(&quot;店铺不存在！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //查到了则转为json字符串</span><br><span class="line">    String jsonStr = JSONUtil.toJsonStr(shop);</span><br><span class="line">    //并存入redis，设置TTL</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr,CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    //最终把查询到的商户信息返回给前端</span><br><span class="line">    return Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在的逻辑是：如果这个数据不存在，将这个数据写入到Redis中，并且将value设置为空字符串，然后设置一个较短的TTL，返回错误信息。当再次发起查询时，先去Redis中判断value是否为空字符串，如果是空字符串，则说明是刚刚我们存的不存在的数据，直接返回错误信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result queryById(Long id) &#123;</span><br><span class="line">    //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    //如果不为空（查询到了），则转为Shop类型直接返回</span><br><span class="line">    if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        Shop shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        return Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果查询到的是空字符串，则说明是我们缓存的空数据</span><br><span class="line">    if (shopjson != null) &#123;</span><br><span class="line">        return Result.fail(&quot;店铺不存在！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //否则去数据库中查</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    //查不到，则将空字符串写入Redis</span><br><span class="line">    if (shop == null) &#123;</span><br><span class="line">        //这里的常量值是2分钟</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        return Result.fail(&quot;店铺不存在！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //查到了则转为json字符串</span><br><span class="line">    String jsonStr = JSONUtil.toJsonStr(shop);</span><br><span class="line">    //并存入redis，设置TTL</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    //最终把查询到的商户信息返回给前端</span><br><span class="line">    return Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>缓存穿透产生的原因是什么？<ul>
<li>用户请求的数据在缓存中和在数据库中都不存在，不断发起这样的请求，会给数据库带来巨大压力</li>
</ul>
</li>
<li>缓存产投的解决方案有哪些？<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id复杂度，避免被猜测id规律（可以采用雪花算法）</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩问题及解决思路"><a href="#缓存雪崩问题及解决思路" class="headerlink" title="缓存雪崩问题及解决思路"></a>缓存雪崩问题及解决思路</h3><ul>
<li>缓存雪崩是指在同一时间段，大量缓存的key同时失效，或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</li>
<li>解决方案<ul>
<li>给不同的Key的TTL添加随机值，让其在不同时间段分批失效</li>
<li>利用Redis集群提高服务的可用性（使用一个或者多个哨兵(<code>Sentinel</code>)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。 ）</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存（浏览器访问静态资源时，优先读取浏览器本地缓存；访问非静态资源（ajax查询数据）时，访问服务端；请求到达Nginx后，优先读取Nginx本地缓存；如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）；如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库）</li>
</ul>
</li>
</ul>
<h3 id="缓存击穿问题及解决思路"><a href="#缓存击穿问题及解决思路" class="headerlink" title="缓存击穿问题及解决思路"></a>缓存击穿问题及解决思路</h3><ul>
<li>缓存击穿也叫热点Key问题，就是一个被<code>高并发访问</code>并且<code>缓存重建业务较复杂</code>的key突然失效了，那么无数请求访问就会在瞬间给数据库带来巨大的冲击</li>
<li>举个不太恰当的例子：一件秒杀中的商品的key突然失效了，大家都在疯狂抢购，那么这个瞬间就会有无数的请求访问去直接抵达数据库，从而造成缓存击穿</li>
<li>常见的解决方案有两种<ol>
<li>互斥锁</li>
<li>逻辑过期</li>
</ol>
</li>
<li><code>逻辑分析</code>：假设线程1在查询缓存之后未命中，本来应该去查询数据库，重建缓存数据，完成这些之后，其他线程也就能从缓存中加载这些数据了。但是在线程1还未执行完毕时，又进来了线程2、3、4同时来访问当前方法，那么这些线程都不能从缓存中查询到数据，那么他们就会在同一时刻访问数据库，执行SQL语句查询，对数据库访问压力过大<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6354f77716f2c2beb1225032.jpg"><img src="https://pic1.imgdb.cn/item/6354f77716f2c2beb1225032.jpg" alt="img"></a></li>
<li><code>解决方案一</code>：互斥锁</li>
<li>利用锁的互斥性，假设线程过来，只能一个人一个人的访问数据库，从而避免对数据库频繁访问产生过大压力，但这也会影响查询的性能，将查询的性能从并行变成了串行，我们可以采用tryLock方法+double check来解决这个问题</li>
<li>线程1在操作的时候，拿着锁把房门锁上了，那么线程2、3、4就不能都进来操作数据库，只有1操作完了，把房门打开了，此时缓存数据也重建好了，线程2、3、4直接从redis中就可以查询到数据。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6354f76816f2c2beb1223b47.jpg"><img src="https://pic1.imgdb.cn/item/6354f76816f2c2beb1223b47.jpg" alt="img"></a></p>
<ul>
<li><code>解决方案二</code>：逻辑过期方案</li>
<li>方案分析：我们之所以会出现缓存击穿问题，主要原因是在于我们对key设置了TTL，如果我们不设置TTL，那么就不会有缓存击穿问题，但是不设置TTL，数据又会一直占用我们的内存，所以我们可以采用逻辑过期方案</li>
<li>我们之前是TTL设置在redis的value中，注意：这个过期时间并不会直接作用于Redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断当前数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的进程他会开启一个新线程去进行之前的重建缓存数据的逻辑，直到新开的线程完成者逻辑之后，才会释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程2拿着锁，所以线程3无法获得锁，线程3也直接返回数据（但只能返回旧数据，牺牲了数据一致性，换取性能上的提高），只有等待线程2重建缓存数据之后，其他线程才能返回正确的数据</li>
<li>这种方案巧妙在于，异步构建缓存数据，缺点是在重建完缓存数据之前，返回的都是脏数据<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6354f97716f2c2beb124e950.jpg"><img src="https://pic1.imgdb.cn/item/6354f97716f2c2beb124e950.jpg" alt="img"></a></li>
</ul>
<h3 id="对比互斥锁与逻辑删除"><a href="#对比互斥锁与逻辑删除" class="headerlink" title="对比互斥锁与逻辑删除"></a>对比互斥锁与逻辑删除</h3><ul>
<li><code>互斥锁方案</code>：由于保证了互斥性，所以数据一致，且实现简单，只是加了一把锁而已，也没有其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁的情况，就可能死锁，所以只能串行执行，性能会受到影响</li>
<li><code>逻辑过期方案</code>：线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构缓存数据，但是在重构数据完成之前，其他线程只能返回脏数据，且实现起来比较麻烦</li>
</ul>
<table>
<thead>
<tr>
<th align="center">解决方案</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">互斥锁</td>
<td align="center">没有额外的内存消耗 保证一致性 实现简单</td>
<td align="center">线程需要等待，性能受影响 可能有死锁风险</td>
</tr>
<tr>
<td align="center">逻辑过期</td>
<td align="center">线程无需等待，性能较好</td>
<td align="center">不保证一致性 有额外内存消耗 实现复杂</td>
</tr>
</tbody></table>
<h3 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h3><ul>
<li><p><code>核心思路</code>：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是，进行查询之后，如果没有从缓存中查询到数据，则进行互斥锁的获取，获取互斥锁之后，判断是否获取到了锁，如果没获取到，则休眠一段时间，过一会儿再去尝试，知道获取到锁为止，才能进行查询</p>
</li>
<li><p>如果获取到了锁的线程，则进行查询，将查询到的数据写入Redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行数据库的逻辑，防止缓存击穿<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6354fb8116f2c2beb127ac8b.jpg"><img src="https://pic1.imgdb.cn/item/6354fb8116f2c2beb127ac8b.jpg" alt="img"></a></p>
</li>
<li><p><code>操作锁的代码</code></p>
</li>
<li><p>核心思路就是利用redis的setnx方法来表示获取锁，如果redis没有这个key，则插入成功，返回1，如果已经存在这个key，则插入失败，返回0。在StringRedisTemplate中返回true&#x2F;false，我们可以根据返回值来判断是否有线程成功获取到了锁</p>
</li>
<li><p>tryLock</p>
</li>
<li><p>unlock</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private boolean tryLock(String key) &#123;</span><br><span class="line">    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);</span><br><span class="line">    //避免返回值为null，我们这里使用了BooleanUtil工具类</span><br><span class="line">    return BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>然后这里先把我们之前写的缓存穿透代码修改一下，提取成一个独立的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Shop queryWithPassThrough(Long id) &#123;</span><br><span class="line">    //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    //如果不为空（查询到了），则转为Shop类型直接返回</span><br><span class="line">    if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        Shop shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        return shop;</span><br><span class="line">    &#125;</span><br><span class="line">    if (shopjson != null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //否则去数据库中查</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    //查不到，则将空值写入Redis</span><br><span class="line">    if (shop == null) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //查到了则转为json字符串</span><br><span class="line">    String jsonStr = JSONUtil.toJsonStr(shop);</span><br><span class="line">    //并存入redis，设置TTL</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    //最终把查询到的商户信息返回给前端</span><br><span class="line">    return shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>之后编写我们的互斥锁代码，其实与缓存穿透代码类似，只需要在上面稍加修改即可</p>
</li>
<li><p>DIFF</p>
</li>
<li><p>修改后代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">DIFF</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">-   public Shop queryWithPassThrough(Long id) &#123;</span><br><span class="line">+   public Shop queryWithMutex(Long id) &#123;</span><br><span class="line">        //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">        //如果不为空（查询到了），则转为Shop类型直接返回</span><br><span class="line">        if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            Shop shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            return shop;</span><br><span class="line">        &#125;</span><br><span class="line">        if (shopjson != null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则去数据库中查</span><br><span class="line">+       //从这里，用try/catch/finally包裹</span><br><span class="line">+       //获取互斥锁</span><br><span class="line">+       boolean flag = tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">+       //判断是否获取成功</span><br><span class="line">+       if (!flag) &#123;</span><br><span class="line">+           //失败，则休眠并重试</span><br><span class="line">+           Thread.sleep(50);</span><br><span class="line">+           return queryWithMutex(id);</span><br><span class="line">+       &#125;</span><br><span class="line">        Shop shop = getById(id);</span><br><span class="line">        //查不到，则将空值写入Redis</span><br><span class="line">        if (shop == null) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //查到了则转为json字符串</span><br><span class="line">        String jsonStr = JSONUtil.toJsonStr(shop);</span><br><span class="line">        //并存入redis，设置TTL</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">+       //try/catch/finally包裹到这里，然后把释放锁的操作放到finally里</span><br><span class="line">+       //释放互斥锁</span><br><span class="line">+       unlock(LOCK_SHOP_KEY + id);</span><br><span class="line">        //最终把查询到的商户信息返回给前端</span><br><span class="line">        return shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>最终修改<code>queryById</code>方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Override</span><br><span class="line">public Result queryById(Long id) &#123;</span><br><span class="line">    Shop shop = queryWithMutex(id);</span><br><span class="line">    if (shop == null) &#123;</span><br><span class="line">        return Result.fail(&quot;店铺不存在！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用Jmeter进行测试</p>
<ul>
<li><p>我们先来模拟一下缓存击穿的情景，缓存击穿是指在某时刻，一个热点数据的TTL到期了，此时用户不能从Redis中获取热点商品数据，然后就都得去数据库里查询，造成数据库压力过大。</p>
</li>
<li><p>那么我们首先将Redis中的热点商品数据删除，模拟TTL到期，然后用Jmeter进行压力测试，开100个线程来访问这个没有缓存的热点数据</p>
<ul>
<li>如果后台日志只输出了一条SQL语句，则说明我们的互斥锁是生效的，没有造成大量用户都去查询数据库，执行SQL语句</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ASCIIDOC</span><br><span class="line">: ==&gt;  Preparing: SELECT id,name,type_id,images,area,address,x,y,avg_price,sold,comments,score,open_hours,create_time,update_time FROM tb_shop WHERE id=?</span><br><span class="line">: ==&gt; Parameters: 2(Long)</span><br><span class="line">: &lt;==      Total: 1</span><br></pre></td></tr></table></figure>

<ul>
<li>如果日志输出了好多SQL语句，则说明我们的代码有问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6356424916f2c2beb1a493ea.jpg"><img src="https://pic1.imgdb.cn/item/6356424916f2c2beb1a493ea.jpg" alt="img"></a></p>
<h3 id="利用逻辑过期解决缓存击穿问题"><a href="#利用逻辑过期解决缓存击穿问题" class="headerlink" title="利用逻辑过期解决缓存击穿问题"></a>利用逻辑过期解决缓存击穿问题</h3><ul>
<li>需求：根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</li>
<li>思路分析：当用户开始查询redis时，判断是否命中<ul>
<li>如果没有命中则直接返回空数据，不查询数据库</li>
<li>如果命中，则将value取出，判断value中的过期时间是否满足<ul>
<li>如果没有过期，则直接返回redis中的数据</li>
<li>如果过期，则在开启独立线程后，直接返回之前的数据，独立线程去重构数据，重构完成后再释放互斥锁<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6355073c16f2c2beb1375808.jpg"><img src="https://pic1.imgdb.cn/item/6355073c16f2c2beb1375808.jpg" alt="img"></a></li>
</ul>
</li>
</ul>
</li>
<li>封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么新建一个类包含原有的数据和过期时间</li>
<li><code>步骤一</code></li>
<li>这里我们选择新建一个实体类，包含原有数据(用万能的Object)和过期时间，这样对原有的代码没有侵入性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Data</span><br><span class="line">public class RedisData&lt;T&gt; &#123;</span><br><span class="line">    private LocalDateTime expireTime;</span><br><span class="line">    private T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>步骤二</code></li>
<li>在ShopServiceImpl中新增方法，进行单元测试，看看能否写入数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void saveShop2Redis(Long id, Long expirSeconds) &#123;</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    RedisData redisData = new RedisData();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expirSeconds));</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写测试方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class HmDianPingApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ShopServiceImpl shopService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        shopService.saveShop2Redis(1L,1000L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行测试方法，去Redis图形化页面看到存入的value，确实包含了data和expireTime1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JSON</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;area&quot;: &quot;大关&quot;,</span><br><span class="line">    &quot;openHours&quot;: &quot;10:00-22:00&quot;,</span><br><span class="line">    &quot;sold&quot;: 4215,</span><br><span class="line">    &quot;images&quot;: &quot;https://qcloud.dpfile.com/pc/jiclIsCKmOI2arxKN1Uf0Hx3PucIJH8q0QSz-Z8llzcN56-_QiKuOvyio1OOxsRtFoXqu0G3iT2T27qat3WhLVEuLYk00OmSS1IdNpm8K8sG4JN9RIm2mTKcbLtc2o2vfCF2ubeXzk49OsGrXt_KYDCngOyCwZK-s3fqawWswzk.jpg,https://qcloud.dpfile.com/pc/IOf6VX3qaBgFXFVgp75w-KKJmWZjFc8GXDU8g9bQC6YGCpAmG00QbfT4vCCBj7njuzFvxlbkWx5uwqY2qcjixFEuLYk00OmSS1IdNpm8K8sG4JN9RIm2mTKcbLtc2o2vmIU_8ZGOT1OjpJmLxG6urQ.jpg&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;金华路锦昌文华苑29号&quot;,</span><br><span class="line">    &quot;comments&quot;: 3035,</span><br><span class="line">    &quot;avgPrice&quot;: 80,</span><br><span class="line">    &quot;updateTime&quot;: 1666502007000,</span><br><span class="line">    &quot;score&quot;: 37,</span><br><span class="line">    &quot;createTime&quot;: 1640167839000,</span><br><span class="line">    &quot;name&quot;: &quot;476茶餐厅&quot;,</span><br><span class="line">    &quot;x&quot;: 120.149192,</span><br><span class="line">    &quot;y&quot;: 30.316078,</span><br><span class="line">    &quot;typeId&quot;: 1,</span><br><span class="line">    &quot;id&quot;: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;expireTime&quot;: 1666519036559</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>步骤三</code>：正式代码<br>正式代码我们就直接照着流程图写就好了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">//这里需要声明一个线程池，因为下面我们需要新建一个现成来完成重构缓存</span><br><span class="line">private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Shop queryWithLogicalExpire(Long id) &#123;</span><br><span class="line">    //1. 从redis中查询商铺缓存</span><br><span class="line">    String json = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    //2. 如果未命中，则返回空</span><br><span class="line">    if (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 命中，将json反序列化为对象</span><br><span class="line">    RedisData redisData = JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    //3.1 将data转为Shop对象</span><br><span class="line">    JSONObject shopJson = (JSONObject) redisData.getData();</span><br><span class="line">    Shop shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    //3.2 获取过期时间</span><br><span class="line">    LocalDateTime expireTime = redisData.getExpireTime();</span><br><span class="line">    //4. 判断是否过期</span><br><span class="line">    if (LocalDateTime.now().isBefore(time)) &#123;</span><br><span class="line">        //5. 未过期，直接返回商铺信息</span><br><span class="line">        return shop;</span><br><span class="line">    &#125;</span><br><span class="line">    //6. 过期，尝试获取互斥锁</span><br><span class="line">    boolean flag = tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">    //7. 获取到了锁</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        //8. 开启独立线程</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                this.saveShop2Redis(id, LOCK_SHOP_TTL);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                unlock(LOCK_SHOP_KEY + id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //9. 直接返回商铺信息</span><br><span class="line">        return shop;</span><br><span class="line">    &#125;</span><br><span class="line">    //10. 未获取到锁，直接返回商铺信息</span><br><span class="line">    return shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用Jmeter进行测试</p>
<ul>
<li><p>先来复现一遍场景，当某个用户去Redis中访问缓存的数据时，发现该数据已经过期了，于是新开一个线程去重构缓存数据，但在重构完成之前，用户得到的数据都是脏数据，重构完成之后，才是新数据</p>
</li>
<li><p>那我们先使用<code>saveShop2Redis</code>方法，向redis中添加一个逻辑过期数据，设置过期时间为2秒，这样很快就过期了，</p>
</li>
<li><p>saveShop2Redis</p>
</li>
<li><p>Test</p>
</li>
</ul>
<p><code>JAVApublic void saveShop2Redis(Long id, Long expirSeconds) &#123;    Shop shop = getById(id);    RedisData redisData = new RedisData();    redisData.setData(shop);    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expirSeconds));    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));&#125; </code></p>
<ul>
<li>之后去数据库把这个数据修改一下，这样逻辑过期前和逻辑过期后的数据就不一致，当用户来访问数据的时候，需要花时间来进行重构缓存数据，但是在重构完成之前，都只能获得脏数据（也就是我们修改前的数据），只有当重构完毕之后，才能获得新数据（我们修改后的数据）</li>
<li>测试结果如下，同样是开了100个线程去访问逻辑过期数据，前面的用户只能看到脏数据，后面的用户看到的才是新数据<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6356558116f2c2beb1d8a832.jpg"><img src="https://pic1.imgdb.cn/item/6356558116f2c2beb1d8a832.jpg" alt="img"></a></li>
</ul>
</li>
</ul>
<h3 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h3><ul>
<li><p>基于StringRedisTemplate封装一个缓存工具类，需满足下列要求</p>
<ul>
<li>方法1：将任意Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void set(String key, Object value, Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2：将任意Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间，用于处理缓存击穿问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void setWithLogicExpire(String key, Object value, Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">    //由于需要设置逻辑过期时间，所以我们需要用到RedisData</span><br><span class="line">    RedisData&lt;Object&gt; redisData = new RedisData&lt;&gt;();</span><br><span class="line">    //redisData的data就是传进来的value对象</span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    //逻辑过期时间就是当前时间加上传进来的参数时间，用TimeUnit可以将时间转为秒，随后与当前时间相加</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">    //由于是逻辑过期，所以这里不需要设置过期时间，只存一下key和value就好了，同时注意value是ridisData类型</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法3：根据指定的Key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</p>
</li>
<li><p>原方法</p>
</li>
<li><p>改为通用方法</p>
</li>
<li><p>使用方法</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Shop queryWithPassThrough(Long id) &#123;</span><br><span class="line">    //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    //如果不为空（查询到了），则转为Shop类型直接返回</span><br><span class="line">    if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        return JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line">    if (shopjson != null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //否则去数据库中查</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    //查不到，则将空值写入Redis</span><br><span class="line">    if (shop == null) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //查到了则转为json字符串</span><br><span class="line">    String jsonStr = JSONUtil.toJsonStr(shop);</span><br><span class="line">    //并存入redis，设置TTL</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    //最终把查询到的商户信息返回给前端</span><br><span class="line">    return shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>方法4：根据指定的Key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public &lt;R, ID&gt; R queryWithLogicalExpire(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">    //1. 从redis中查询商铺缓存</span><br><span class="line">    String key = keyPrefix + id;</span><br><span class="line">    String json = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    //2. 如果未命中，则返回空</span><br><span class="line">    if (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 命中，将json反序列化为对象</span><br><span class="line">    RedisData redisData = JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">    LocalDateTime expireTime = redisData.getExpireTime();</span><br><span class="line">    //4. 判断是否过期</span><br><span class="line">    if (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        //5. 未过期，直接返回商铺信息</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    //6. 过期，尝试获取互斥锁</span><br><span class="line">    String lockKey = LOCK_SHOP_KEY + id;</span><br><span class="line">    boolean flag = tryLock(lockKey);</span><br><span class="line">    //7. 获取到了锁</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        //8. 开启独立线程</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                R tmp = dbFallback.apply(id);</span><br><span class="line">                this.setWithLogicExpire(key, tmp, time, timeUnit);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //9. 直接返回商铺信息</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    //10. 未获取到锁，直接返回商铺信息</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法5：根据指定的Key查询缓存，并反序列化为指定类型，需要利用互斥锁解决缓存击穿问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public &lt;R, ID&gt; R queryWithMutex(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">    //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">    String key = keyPrefix + id;</span><br><span class="line">    String json = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    //如果不为空（查询到了），则转为Shop类型直接返回</span><br><span class="line">    if (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">        return JSONUtil.toBean(json, type);</span><br><span class="line">    &#125;</span><br><span class="line">    if (json != null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    R r = null;</span><br><span class="line">    String lockKey = LOCK_SHOP_KEY + id;</span><br><span class="line">    try &#123;</span><br><span class="line">        //否则去数据库中查</span><br><span class="line">        boolean flag = tryLock(lockKey);</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            return queryWithMutex(keyPrefix, id, type, dbFallback, time, timeUnit);</span><br><span class="line">        &#125;</span><br><span class="line">        r = dbFallback.apply(id);</span><br><span class="line">        //查不到，则将空值写入Redis</span><br><span class="line">        if (r == null) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //并存入redis，设置TTL</span><br><span class="line">        this.set(key, r, time, timeUnit);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整代码如下</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">import cn.hutool.core.util.BooleanUtil;</span><br><span class="line">import cn.hutool.core.util.StrUtil;</span><br><span class="line">import cn.hutool.json.JSONObject;</span><br><span class="line">import cn.hutool.json.JSONUtil;</span><br><span class="line">import com.hmdp.entity.RedisData;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">import static com.hmdp.utils.RedisConstants.*;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class CacheClient &#123;</span><br><span class="line"></span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);</span><br><span class="line"></span><br><span class="line">    public CacheClient(StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String key, Object value, Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWithLogicExpire(String key, Object value, Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">        RedisData&lt;Object&gt; redisData = new RedisData&lt;&gt;();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;R, ID&gt; R queryWithPassThrough(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">        //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">        String key = keyPrefix + id;</span><br><span class="line">        String json = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        //如果不为空（查询到了），则转为R类型直接返回</span><br><span class="line">        if (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            return JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        if (json != null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则去数据库中查，查询逻辑用我们参数中注入的函数</span><br><span class="line">        R r = dbFallback.apply(id);</span><br><span class="line">        //查不到，则将空值写入Redis</span><br><span class="line">        if (r == null) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //查到了则转为json字符串</span><br><span class="line">        String jsonStr = JSONUtil.toJsonStr(r);</span><br><span class="line">        //并存入redis，设置TTL</span><br><span class="line">        this.set(key, jsonStr, time, timeUnit);</span><br><span class="line">        //最终把查询到的商户信息返回给前端</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;R, ID&gt; R queryWithLogicalExpire(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">        //1. 从redis中查询商铺缓存</span><br><span class="line">        String key = keyPrefix + id;</span><br><span class="line">        String json = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        //2. 如果未命中，则返回空</span><br><span class="line">        if (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //3. 命中，将json反序列化为对象</span><br><span class="line">        RedisData redisData = JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        LocalDateTime expireTime = redisData.getExpireTime();</span><br><span class="line">        //4. 判断是否过期</span><br><span class="line">        if (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            //5. 未过期，直接返回商铺信息</span><br><span class="line">            return r;</span><br><span class="line">        &#125;</span><br><span class="line">        //6. 过期，尝试获取互斥锁</span><br><span class="line">        String lockKey = LOCK_SHOP_KEY + id;</span><br><span class="line">        boolean flag = tryLock(lockKey);</span><br><span class="line">        //7. 获取到了锁</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            //8. 开启独立线程</span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    R tmp = dbFallback.apply(id);</span><br><span class="line">                    this.setWithLogicExpire(key, tmp, time, timeUnit);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            //9. 直接返回商铺信息</span><br><span class="line">            return r;</span><br><span class="line">        &#125;</span><br><span class="line">        //10. 未获取到锁，直接返回商铺信息</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;R, ID&gt; R queryWithMutex(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">        //先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span><br><span class="line">        String key = keyPrefix + id;</span><br><span class="line">        String json = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        //如果不为空（查询到了），则转为Shop类型直接返回</span><br><span class="line">        if (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            return JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        if (json != null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        R r = null;</span><br><span class="line">        String lockKey = LOCK_SHOP_KEY + id;</span><br><span class="line">        try &#123;</span><br><span class="line">            //否则去数据库中查</span><br><span class="line">            boolean flag = tryLock(lockKey);</span><br><span class="line">            if (!flag) &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">                return queryWithMutex(keyPrefix, id, type, dbFallback, time, timeUnit);</span><br><span class="line">            &#125;</span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            //查不到，则将空值写入Redis</span><br><span class="line">            if (r == null) &#123;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //并存入redis，设置TTL</span><br><span class="line">            this.set(key, r, time, timeUnit);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean tryLock(String key) &#123;</span><br><span class="line">        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);</span><br><span class="line">        return BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void unlock(String key) &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h2><h3 id="Redis实现全局唯一ID"><a href="#Redis实现全局唯一ID" class="headerlink" title="Redis实现全局唯一ID"></a>Redis实现全局唯一ID</h3><ul>
<li><p>在各类购物App中，都会遇到商家发放的优惠券</p>
</li>
<li><p>当用户抢购商品时，生成的订单会保存到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tb_voucher_order</span><br></pre></td></tr></table></figure>

<p>表中，而订单表如果使用数据库自增ID就会存在一些问题</p>
<ol>
<li>id规律性太明显</li>
<li>受单表数据量的限制</li>
</ol>
</li>
<li><p>如果我们的订单id有太明显的规律，那么对于用户或者竞争对手，就很容易猜测出我们的一些敏感信息，例如商城一天之内能卖出多少单，这明显不合适</p>
</li>
<li><p>随着我们商城的规模越来越大，MySQL的单表容量不宜超过500W，数据量过大之后，我们就要进行拆库拆表，拆分表了之后，他们从逻辑上讲，是同一张表，所以他们的id不能重复，于是乎我们就要保证id的唯一性</p>
</li>
<li><p>那么这就引出我们的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全局ID生成器</span><br></pre></td></tr></table></figure>

<p>了</p>
<ul>
<li>全局ID生成器是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足一下特性<ul>
<li>唯一性</li>
<li>高可用</li>
<li>高性能</li>
<li>递增性</li>
<li>安全性</li>
</ul>
</li>
</ul>
</li>
<li><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息</p>
</li>
<li><p>ID组成部分</p>
<ul>
<li>符号位：1bit，永远为0</li>
<li>时间戳：31bit，以秒为单位，可以使用69年（2^31秒约等于69年）</li>
<li>序列号：32bit，秒内的计数器，支持每秒传输2^32个不同ID</li>
</ul>
</li>
<li><p>那我们就根据我们分析的ID生成策略，来编写代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //设置一下起始时间，时间戳就是起始时间与当前时间的秒数差</span><br><span class="line">    LocalDateTime tmp = LocalDateTime.of(2022, 1, 1, 0, 0, 0);</span><br><span class="line">    System.out.println(tmp.toEpochSecond(ZoneOffset.UTC));</span><br><span class="line">    //结果为1640995200L</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class RedisIdWorker &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    //设置起始时间，我这里设定的是2022.01.01 00:00:00</span><br><span class="line">    public static final Long BEGIN_TIMESTAMP = 1640995200L;</span><br><span class="line">    //序列号长度</span><br><span class="line">    public static final Long COUNT_BIT = 32L;</span><br><span class="line"></span><br><span class="line">    public long nextId(String keyPrefix)&#123;</span><br><span class="line">        //1. 生成时间戳</span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        long currentSecond = now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        long timeStamp = currentSecond - BEGIN_TIMESTAMP;</span><br><span class="line">        //2. 生成序列号</span><br><span class="line">        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));</span><br><span class="line">        long count = stringRedisTemplate.opsForValue().increment(&quot;inc:&quot;+keyPrefix+&quot;:&quot;+date);</span><br><span class="line">        //3. 拼接并返回，简单位运算</span><br><span class="line">        return timeStamp &lt;&lt; COUNT_BIT | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h3><ul>
<li>每个店铺度可以发布优惠券，分为平价券和特价券，平价券可以任意购买，而特价券需要秒杀抢购</li>
<li>tb_voucher：优惠券的基本信息，优惠金额、使用规则等</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="center">Type</th>
<th align="center">Collation</th>
<th align="center">Null</th>
<th align="center">Key</th>
<th align="center">Default</th>
<th align="center">Extra</th>
<th align="center">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">bigint unsigned</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="center">(NULL)</td>
<td align="center">auto_increment</td>
<td align="center">主键</td>
</tr>
<tr>
<td align="center">shop_id</td>
<td align="center">bigint unsigned</td>
<td align="center">(NULL)</td>
<td align="center">YES</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">商铺id</td>
</tr>
<tr>
<td align="center">title</td>
<td align="center">varchar(255)</td>
<td align="center">utf8mb4_general_ci</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">代金券标题</td>
</tr>
<tr>
<td align="center">sub_title</td>
<td align="center">varchar(255)</td>
<td align="center">utf8mb4_general_ci</td>
<td align="center">YES</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">副标题</td>
</tr>
<tr>
<td align="center">rules</td>
<td align="center">varchar(1024)</td>
<td align="center">utf8mb4_general_ci</td>
<td align="center">YES</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">使用规则</td>
</tr>
<tr>
<td align="center">pay_value</td>
<td align="center">bigint unsigned</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">支付金额，单位是分。例如200代表2元</td>
</tr>
<tr>
<td align="center">actual_value</td>
<td align="center">bigint</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">抵扣金额，单位是分。例如200代表2元</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">tinyint unsigned</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center"></td>
<td align="center">0,普通券；1,秒杀券</td>
</tr>
<tr>
<td align="center">status</td>
<td align="center">tinyint unsigned</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1,上架; 2,下架; 3,过期</td>
</tr>
<tr>
<td align="center">create_time</td>
<td align="center">timestamp</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">CURRENT_TIMESTAMP</td>
<td align="center">DEFAULT_GENERATED</td>
<td align="center">创建时间</td>
</tr>
<tr>
<td align="center">update_time</td>
<td align="center">timestamp</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">CURRENT_TIMESTAMP</td>
<td align="center">DEFAULT_GENERATED on update CURRENT_TIMESTAMP</td>
<td align="center">更新时间</td>
</tr>
</tbody></table>
<ul>
<li>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="center">Type</th>
<th align="center">Collation</th>
<th align="center">Null</th>
<th align="center">Key</th>
<th align="center">Default</th>
<th align="center">Extra</th>
<th align="center">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="center">voucher_id</td>
<td align="center">bigint unsigned</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">关联的优惠券的id</td>
</tr>
<tr>
<td align="center">stock</td>
<td align="center">int</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">库存</td>
</tr>
<tr>
<td align="center">create_time</td>
<td align="center">timestamp</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">CURRENT_TIMESTAMP</td>
<td align="center">DEFAULT_GENERATED</td>
<td align="center">创建时间</td>
</tr>
<tr>
<td align="center">begin_time</td>
<td align="center">timestamp</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">CURRENT_TIMESTAMP</td>
<td align="center">DEFAULT_GENERATED</td>
<td align="center">生效时间</td>
</tr>
<tr>
<td align="center">end_time</td>
<td align="center">timestamp</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">CURRENT_TIMESTAMP</td>
<td align="center">DEFAULT_GENERATED</td>
<td align="center">失效时间</td>
</tr>
<tr>
<td align="center">update_time</td>
<td align="center">timestamp</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">CURRENT_TIMESTAMP</td>
<td align="center">DEFAULT_GENERATED on update CURRENT_TIMESTAMP</td>
<td align="center">更新时间</td>
</tr>
</tbody></table>
<ul>
<li><p>平价券由于优惠力度并不是很大，所以是可以任意领取</p>
</li>
<li><p>而代金券由于优惠力度大，所以像第二种券，就得限制数量，从表结构上也能看出，特价券除了具有优惠券的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p>
</li>
<li><p>添加优惠券的代码已经提供好了</p>
</li>
<li><p>新增普通券</p>
</li>
<li><p>新增秒杀券</p>
</li>
<li><p>新增秒杀券业务逻辑</p>
</li>
</ul>
<p>新增普通券，也就只是将普通券的信息保存到表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 新增普通券</span><br><span class="line"> * @param voucher 优惠券信息</span><br><span class="line"> * @return 优惠券id</span><br><span class="line"> */</span><br><span class="line">@PostMapping</span><br><span class="line">public Result addVoucher(@RequestBody Voucher voucher) &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    return Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>由于这里并没有后台管理页面，所以我们只能用POSTMAN模拟发送请求来新增秒杀券，请求路径<code>http://localhost:8081/voucher/seckill</code>， 请求方式POST，JSON数据如下，注意优惠券的截止日期设置，若优惠券过期，则不会在页面上显示。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JSON</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;shopId&quot;:1,</span><br><span class="line">    &quot;title&quot;:&quot;100元代金券&quot;,</span><br><span class="line">    &quot;subTitle&quot;:&quot;周一至周五可用&quot;,</span><br><span class="line">    &quot;rules&quot;:&quot;全场通用\\n无需预约\\n可无限叠加&quot;,</span><br><span class="line">    &quot;payValue&quot;:8000,</span><br><span class="line">    &quot;actualValue&quot;:10000,</span><br><span class="line">    &quot;type&quot;:1,</span><br><span class="line">    &quot;stock&quot;:100,</span><br><span class="line">    &quot;beginTime&quot;:&quot;2022-01-01T00:00:00&quot;,</span><br><span class="line">    &quot;endTime&quot;:&quot;2022-10-31T23:59:59&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>效果如下<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6358bbb316f2c2beb1b7967c.jpg"><img src="https://pic1.imgdb.cn/item/6358bbb316f2c2beb1b7967c.jpg" alt="img"></a></li>
</ul>
<h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><ul>
<li>我们点击<code>限时抢购</code>，然后查看发送的请求</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AWK</span><br><span class="line">请求网址: http://localhost:8080/api/voucher-order/seckill/13</span><br><span class="line">请求方法: POST</span><br></pre></td></tr></table></figure>

<ul>
<li>看样子是<code>VoucherOrderController</code>里的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/voucher-order&quot;)</span><br><span class="line">public class VoucherOrderController &#123;</span><br><span class="line">    @PostMapping(&quot;seckill/&#123;id&#125;&quot;)</span><br><span class="line">    public Result seckillVoucher(@PathVariable(&quot;id&quot;) Long voucherId) &#123;</span><br><span class="line">        return Result.fail(&quot;功能未完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>那我们现在来分析一下怎么抢优惠券</p>
<ul>
<li>首先提交优惠券id，然后查询优惠券信息</li>
<li>之后判断秒杀时间是否开始<ul>
<li>开始了，则判断是否有剩余库存<ul>
<li>有库存，那么删减一个库存<ul>
<li>然后创建订单</li>
</ul>
</li>
<li>无库存，则返回一个错误信息</li>
</ul>
</li>
<li>没开始，则返回一个错误信息</li>
</ul>
</li>
</ul>
</li>
<li><p>对应的流程图如下<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6358c21a16f2c2beb1bfd43a.jpg"><img src="https://pic1.imgdb.cn/item/6358c21a16f2c2beb1bfd43a.jpg" alt="img"></a></p>
</li>
<li><p>那现在我们就根据我们刚刚的分析和流程图，来编写对应的代码</p>
</li>
<li><p>VoucherOrderController</p>
</li>
<li><p>IVoucherOrderService</p>
</li>
<li><p>VoucherOrderServiceImpl</p>
</li>
</ul>
<p>具体的业务逻辑我们还是放到Service层里写，在Service层创建seckillVoucher方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/voucher-order&quot;)</span><br><span class="line">public class VoucherOrderController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private IVoucherOrderService voucherOrderService;</span><br><span class="line">    @PostMapping(&quot;/seckill/&#123;id&#125;&quot;)</span><br><span class="line">    public Result seckillVoucher(@PathVariable(&quot;id&quot;) Long voucherId) &#123;</span><br><span class="line">        return voucherOrderService.seckillVoucher(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><ul>
<li>我们之前的代码其实是有问题的，当遇到高并发场景时，会出现超卖现象，我们可以用Jmeter开200个线程来模拟抢优惠券的场景，URL为 localhost:8081&#x2F;voucher-order&#x2F;seckill&#x2F;13，请求方式为POST</li>
</ul>
<p>注意使用Jmeter进行压测时，需要携带我们登录的token<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635a168316f2c2beb193f83d.jpg"><img src="https://pic1.imgdb.cn/item/635a168316f2c2beb193f83d.jpg" alt="img"></a></p>
<ul>
<li>测试完毕之后，查看数据库中的订单表，我们明明只设置了100张优惠券，却有166条数据，去优惠券表查看，库存为-66，超卖了66张<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635a16d316f2c2beb19443a7.jpg"><img src="https://pic1.imgdb.cn/item/635a16d316f2c2beb19443a7.jpg" alt="img"></a></li>
<li>那么如何解决这个问题呢？先来看看我们的代码中是怎么写的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">//4. 判断库存是否充足</span><br><span class="line">if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">    return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//5. 扣减库存</span><br><span class="line">boolean success = seckillVoucherService.update().setSql(&quot;stock = stock - 1&quot;).eq(&quot;voucher_id&quot;, voucherId).update();</span><br><span class="line">if (!success) &#123;</span><br><span class="line">    return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>假设现在只剩下一张优惠券，线程1过来查询库存，判断库存数大于1，但还没来得及去扣减库存，此时库线程2也过来查询库存，发现库存数也大于1，那么这两个线程都会进行扣减库存操作，最终相当于是多个线程都进行了扣减库存，那么此时就会出现超卖问题</li>
<li>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案<ol>
<li>悲观锁<ul>
<li>悲观锁认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行</li>
<li>例如Synchronized、Lock等，都是悲观锁</li>
</ul>
</li>
<li>乐观锁<ul>
<li>乐观锁认为线程安全问题不一定会发生，因此不加锁，只是在更新数据的时候再去判断有没有其他线程对数据进行了修改<ul>
<li>如果没有修改，则认为自己是安全的，自己才可以更新数据</li>
<li>如果已经被其他线程修改，则说明发生了安全问题，此时可以重试或者异常</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>悲观锁：悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</li>
<li>乐观锁：乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如CAS</li>
<li>乐观锁的典型代表：就是CAS(Compare-And-Swap)，利用CAS进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">int var5;</span><br><span class="line">do &#123;</span><br><span class="line">    var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">&#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">return var5;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中do while是为了操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次</li>
</ul>
<hr>
<ul>
<li>该项目中的具体解决方式</li>
<li>这里并不需要真的来指定一下<code>版本号</code>，完全可以使用<code>stock</code>来充当版本号，在扣减库存时，比较查询到的优惠券库存和实际数据库中优惠券库存是否相同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DIFF</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    //1. 查询优惠券</span><br><span class="line">    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">    //2. 判断秒杀时间是否开始</span><br><span class="line">    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀还未开始，请耐心等待&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 判断秒杀时间是否结束</span><br><span class="line">    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //4. 判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //5. 扣减库存</span><br><span class="line">    boolean success = seckillVoucherService.update()</span><br><span class="line">            .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">            .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="line">+           .eq(&quot;stock&quot;,seckillVoucher.getStock())</span><br><span class="line">            .update();</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //6. 创建订单</span><br><span class="line">    VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">    //6.1 设置订单id</span><br><span class="line">    long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">    //6.2 设置用户id</span><br><span class="line">    Long id = UserHolder.getUser().getId();</span><br><span class="line">    //6.3 设置代金券id</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setUserId(id);</span><br><span class="line">    //7. 将订单数据保存到表中</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    //8. 返回订单id</span><br><span class="line">    return Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635a30ca16f2c2beb1ba8efd.jpg"><img src="https://pic1.imgdb.cn/item/635a30ca16f2c2beb1ba8efd.jpg" alt="img"></a></li>
<li>那么我们继续完善代码，修改我们的逻辑，在这种场景，我们可以只判断是否有剩余优惠券，即只要数据库中的库存大于0，都能顺利完成扣减库存操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">DIFF</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    //1. 查询优惠券</span><br><span class="line">    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">    //2. 判断秒杀时间是否开始</span><br><span class="line">    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀还未开始，请耐心等待&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 判断秒杀时间是否结束</span><br><span class="line">    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //4. 判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //5. 扣减库存</span><br><span class="line">    boolean success = seckillVoucherService.update()</span><br><span class="line">            .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">            .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="line">-           .eq(&quot;stock&quot;,seckillVoucher.getStock())</span><br><span class="line">+           .gt(&quot;stock&quot;, 0)</span><br><span class="line">            .update();</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //6. 创建订单</span><br><span class="line">    VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">    //6.1 设置订单id</span><br><span class="line">    long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">    //6.2 设置用户id</span><br><span class="line">    Long id = UserHolder.getUser().getId();</span><br><span class="line">    //6.3 设置代金券id</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setUserId(id);</span><br><span class="line">    //7. 将订单数据保存到表中</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    //8. 返回订单id</span><br><span class="line">    return Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启服务器，继续使用Jmeter进行测试，这次就能顺利将优惠券刚好抢空了</li>
</ul>
<h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><ul>
<li>需求：修改秒杀业务，要求同一个优惠券，一个用户只能抢一张</li>
<li>具体操作逻辑如下：我们在判断库存是否充足之后，根据我们保存的订单数据，判断用户订单是否已存在<ul>
<li>如果已存在，则不能下单，返回错误信息</li>
<li>如果不存在，则继续下单，获取优惠券</li>
</ul>
</li>
<li>初步代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">DIFF</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //1. 查询优惠券</span><br><span class="line">        queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">        SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">        //2. 判断秒杀时间是否开始</span><br><span class="line">        if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀还未开始，请耐心等待&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //3. 判断秒杀时间是否结束</span><br><span class="line">        if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀已经结束！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //4. 判断库存是否充足</span><br><span class="line">        if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">            return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">+       // 一人一单逻辑</span><br><span class="line">+       Long userId = UserHolder.getUser().getId();</span><br><span class="line">+       int count = query().eq(&quot;voucher_id&quot;, voucherId).eq(&quot;user_id&quot;, userId).count();</span><br><span class="line">+       if (count &gt; 0)&#123;</span><br><span class="line">+           return Result.fail(&quot;你已经抢过优惠券了哦&quot;);</span><br><span class="line">+       &#125;</span><br><span class="line">        //5. 扣减库存</span><br><span class="line">        boolean success = seckillVoucherService.update()</span><br><span class="line">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">                .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="line">                .gt(&quot;stock&quot;, 0)</span><br><span class="line">                .update();</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //6. 创建订单</span><br><span class="line">        VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">        //6.1 设置订单id</span><br><span class="line">        long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        //6.2 设置用户id</span><br><span class="line">        Long id = UserHolder.getUser().getId();</span><br><span class="line">        //6.3 设置代金券id</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        voucherOrder.setUserId(id);</span><br><span class="line">        //7. 将订单数据保存到表中</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        //8. 返回订单id</span><br><span class="line">        return Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>存在问题</code>：还是和之前一样，如果这个用户故意开多线程抢优惠券，那么在判断库存充足之后，执行一人一单逻辑之前，在这个区间如果进来了多个线程，还是可以抢多张优惠券的，那我们这里使用悲观锁来解决这个问题</li>
<li>初步代码，我们把一人一单逻辑之后的代码都提取到一个<code>createVoucherOrder</code>方法中，然后给这个方法加锁</li>
<li>不管哪一个线程（例如线程A），运行到这个方法时，都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A，没有的话，锁定调用者，然后直接运行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">private Result createVoucherOrder(Long voucherId) &#123;</span><br><span class="line">    // 一人一单逻辑</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    int count = query().eq(&quot;voucher_id&quot;, voucherId).eq(&quot;user_id&quot;, userId).count();</span><br><span class="line">    if (count &gt; 0) &#123;</span><br><span class="line">        return Result.fail(&quot;你已经抢过优惠券了哦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //5. 扣减库存</span><br><span class="line">    boolean success = seckillVoucherService.update()</span><br><span class="line">            .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">            .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="line">            .gt(&quot;stock&quot;, 0)</span><br><span class="line">            .update();</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //6. 创建订单</span><br><span class="line">    VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">    //6.1 设置订单id</span><br><span class="line">    long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">    //6.2 设置用户id</span><br><span class="line">    Long id = UserHolder.getUser().getId();</span><br><span class="line">    //6.3 设置代金券id</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setUserId(id);</span><br><span class="line">    //7. 将订单数据保存到表中</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    //8. 返回订单id</span><br><span class="line">    return Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是这样加锁，锁的细粒度太粗了，在使用锁的过程中，控制锁粒度是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会被锁住，现在的情况就是所有用户都公用这一把锁，串行执行，效率很低，我们现在要完成的业务是<code>一人一单</code>，所以这个锁，应该只加在单个用户上，用户标识可以用<code>userId</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public Result createVoucherOrder(Long voucherId) &#123;</span><br><span class="line">    // 一人一单逻辑</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    synchronized (userId.toString().intern()) &#123;</span><br><span class="line">        int count = query().eq(&quot;voucher_id&quot;, voucherId).eq(&quot;user_id&quot;, userId).count();</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            return Result.fail(&quot;你已经抢过优惠券了哦&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //5. 扣减库存</span><br><span class="line">        boolean success = seckillVoucherService.update()</span><br><span class="line">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">                .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="line">                .gt(&quot;stock&quot;, 0)</span><br><span class="line">                .update();</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //6. 创建订单</span><br><span class="line">        VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">        //6.1 设置订单id</span><br><span class="line">        long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        //6.2 设置用户id</span><br><span class="line">        Long id = UserHolder.getUser().getId();</span><br><span class="line">        //6.3 设置代金券id</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        voucherOrder.setUserId(id);</span><br><span class="line">        //7. 将订单数据保存到表中</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        //8. 返回订单id</span><br><span class="line">        return Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">    //执行到这里，锁已经被释放了，但是可能当前事务还未提交，如果此时有线程进来，不能确保事务不出问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于toString的源码是new String，所以如果我们只用<code>userId.toString()</code>拿到的也不是同一个用户，需要使用<code>intern()</code>，如果字符串常量池中已经包含了一个等于这个string对象的字符串（由equals（object）方法确定），那么将返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public static String toString(long i) &#123;</span><br><span class="line">    if (i == Long.MIN_VALUE)</span><br><span class="line">        return &quot;-9223372036854775808&quot;;</span><br><span class="line">    int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);</span><br><span class="line">    char[] buf = new char[size];</span><br><span class="line">    getChars(i, size, buf);</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是以上代码还是存在问题，问题的原因在于当前方法被Spring的事务控制，如果你在内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放了，这样也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    //1. 查询优惠券</span><br><span class="line">    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">    //2. 判断秒杀时间是否开始</span><br><span class="line">    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀还未开始，请耐心等待&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 判断秒杀时间是否结束</span><br><span class="line">    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //4. 判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    synchronized (userId.toString().intern()) &#123;</span><br><span class="line">        return createVoucherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务，这里可以使用<code>AopContext.currentProxy()</code>来获取当前对象的代理对象，然后再用代理对象调用方法，记得要去<code>IVoucherOrderService</code>中创建<code>createVoucherOrder</code>方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Long userId = UserHolder.getUser().getId();</span><br><span class="line">synchronized (userId.toString().intern()) &#123;</span><br><span class="line">    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    return proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是该方法会用到一个依赖，我们需要导入一下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>同时在启动类上加上<code>@EnableAspectJAutoProxy(exposeProxy = true)</code>注解</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@MapperScan(&quot;com.hmdp.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAspectJAutoProxy(exposeProxy = true)</span><br><span class="line">public class HmDianPingApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(HmDianPingApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启服务器，再次使用Jmeter测试，200个线程并发，但是只能抢到一张优惠券，目的达成</li>
</ul>
<h3 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h3><ul>
<li>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了<ol>
<li>我们将服务启动两份，端口分别为8081和8082</li>
<li>然后修改nginx的config目录下的nginx.conf文件，配置反向代理和负载均衡（默认轮询就行）</li>
</ol>
</li>
<li>具体操作，我们使用<code>POSTMAN</code>发送两次请求，header携带同一用户的token，尝试用同一账号抢两张优惠券，发现是可行的。</li>
<li>失败原因分析：由于我们部署了多个Tomcat，每个Tomcat都有一个属于自己的jvm，那么假设在服务器A的Tomcat内部，有两个线程，即线程1和线程2，这两个线程使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的。但是如果在Tomcat的内部，又有两个线程，但是他们的锁对象虽然写的和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2互斥<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635a5e3e16f2c2beb1289579.jpg"><img src="https://pic1.imgdb.cn/item/635a5e3e16f2c2beb1289579.jpg" alt="img"></a></li>
<li>这就是集群环境下，syn锁失效的原因，在这种情况下，我们需要使用分布式锁来解决这个问题，让锁不存在于每个jvm的内部，而是让所有jvm公用外部的一把锁（Redis）</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="基本原理和实现方式对比"><a href="#基本原理和实现方式对比" class="headerlink" title="基本原理和实现方式对比"></a>基本原理和实现方式对比</h3><ul>
<li><p>分布式锁：满足分布式系统或集群模式下多线程课件并且可以互斥的锁</p>
</li>
<li><p>分布式锁的核心思想就是让大家共用同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635a5e5516f2c2beb1292f05.jpg"><img src="https://pic1.imgdb.cn/item/635a5e5516f2c2beb1292f05.jpg" alt="img"></a></p>
</li>
<li><p>那么分布式锁应该满足一些什么条件呢？</p>
<ol>
<li>可见性：多个线程都能看到相同的结果。</li>
</ol>
<p>注意：这里说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p>
<ol>
<li>互斥：互斥是分布式锁的最基本条件，使得程序串行执行</li>
<li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li>
<li>高性能：由于加锁本身就让性能降低，所以对于分布式锁需要他较高的加锁性能和释放锁性能</li>
<li>安全性：安全也是程序中必不可少的一环</li>
</ol>
</li>
<li><p>常见的分布式锁有三种</p>
<ol>
<li>MySQL：MySQL本身就带有锁机制，但是由于MySQL的性能一般，所以采用分布式锁的情况下，使用MySQL作为分布式锁比较少见</li>
<li>Redis：Redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都是用Redis或者Zookeeper作为分布式锁，利用<code>SETNX</code>这个方法，如果插入Key成功，则表示获得到了锁，如果有人插入成功，那么其他人就回插入失败，无法获取到锁，利用这套逻辑完成<code>互斥</code>，从而实现分布式锁</li>
<li>Zookeeper：Zookeeper也是企业级开发中较好的一种实现分布式锁的方案，但本文是学Redis的，所以这里就不过多阐述了</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MySQL</th>
<th align="center">Redis</th>
<th align="center">Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td align="center">互斥</td>
<td align="center">利用mysql本身的互斥锁机制</td>
<td align="center">利用setnx这样的互斥命令</td>
<td align="center">利用节点的唯一性和有序性实现互斥</td>
</tr>
<tr>
<td align="center">高可用</td>
<td align="center">好</td>
<td align="center">好</td>
<td align="center">好</td>
</tr>
<tr>
<td align="center">高性能</td>
<td align="center">一般</td>
<td align="center">好</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">断开连接，自动释放锁</td>
<td align="center">利用锁超时时间，到期释放</td>
<td align="center">临时节点，断开连接自动释放</td>
</tr>
</tbody></table>
<h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="Redis分布式锁的实现核心思路"></a>Redis分布式锁的实现核心思路</h3><ul>
<li><p>实现分布式锁时需要实现两个基本方法</p>
<ol>
<li><p>获取锁</p>
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">SET lock thread01 NX EX 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放锁</p>
<ul>
<li>手动释放</li>
<li>超时释放：获取锁的时候添加一个超时时间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>核心思路</p>
<ul>
<li>我们利用redis的<code>SETNX</code>方法，当有多个线程进入时，我们就利用该方法来获取锁。第一个线程进入时，redis 中就有这个key了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁（返回了0）的线程，等待一定时间之后重试</li>
</ul>
</li>
</ul>
<h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><ul>
<li>锁的基本接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public interface ILock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 尝试获取锁</span><br><span class="line">     *</span><br><span class="line">     * @param timeoutSec 锁持有的超时时间，过期自动释放</span><br><span class="line">     * @return true表示获取锁成功，false表示获取锁失败</span><br><span class="line">     */</span><br><span class="line">    boolean tryLock(long timeoutSec);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放锁</span><br><span class="line">     */</span><br><span class="line">    void unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后创建一个SimpleRedisLock类实现接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public class SimpleRedisLock implements ILock &#123;</span><br><span class="line">    //锁的前缀</span><br><span class="line">    private static final String KEY_PREFIX = &quot;lock:&quot;;</span><br><span class="line">    //具体业务名称，将前缀和业务名拼接之后当做Key</span><br><span class="line">    private String name;</span><br><span class="line">    //这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long timeoutSec) &#123;</span><br><span class="line">        //获取线程标识</span><br><span class="line">        long threadId = Thread.currentThread().getId();</span><br><span class="line">        //获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span><br><span class="line">        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        //自动拆箱可能会出现null，这样写更稳妥</span><br><span class="line">        return Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        //通过DEL来删除锁</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改业务代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    //1. 查询优惠券</span><br><span class="line">    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">    //2. 判断秒杀时间是否开始</span><br><span class="line">    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀还未开始，请耐心等待&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 判断秒杀时间是否结束</span><br><span class="line">    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //4. 判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    // 创建锁对象</span><br><span class="line">    SimpleRedisLock redisLock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br><span class="line">    // 获取锁对象</span><br><span class="line">    boolean isLock = redisLock.tryLock(120);</span><br><span class="line">    // 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span><br><span class="line">    if (!isLock) &#123;</span><br><span class="line">        return Result.fail(&quot;不允许抢多张优惠券&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取代理对象</span><br><span class="line">        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        return proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Jmeter进行压力测试，请求头中携带登录用户的token，最终只能抢到一张优惠券</li>
</ul>
<h3 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h3><ul>
<li><pre><code>逻辑说明
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 持有锁的线程1在锁的内部出现了阻塞，导致他的锁TTL到期，自动释放</span><br><span class="line">  - 此时线程2也来尝试获取锁，由于线程1已经释放了锁，所以线程2可以拿到</span><br><span class="line">  - 但是现在线程1阻塞完了，继续往下执行，要开始释放锁了</span><br><span class="line">  - 那么此时就会将属于线程2的锁释放，这就是误删别人锁的情况</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  解决方案</span><br></pre></td></tr></table></figure>

- 解决方案就是在每个线程释放锁的时候，都判断一下这个锁是不是自己的，如果不属于自己，则不进行删除操作。
- 假设还是上面的情况，线程1阻塞，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1阻塞完了，继续往下执行，开始删除锁，但是线程1发现这把锁不是自己的，所以不进行删除锁的逻辑，当线程2执行到删除锁的逻辑时，如果TTL还未到期，则判断当前这把锁是自己的，于是删除这把锁
  [![img](https://pic1.imgdb.cn/item/635aa1b016f2c2beb1e68e4f.jpg)](https://pic1.imgdb.cn/item/635aa1b016f2c2beb1e68e4f.jpg)
</code></pre>
</li>
</ul>
<h3 id="解决Redis分布式锁误删问题"><a href="#解决Redis分布式锁误删问题" class="headerlink" title="解决Redis分布式锁误删问题"></a>解决Redis分布式锁误删问题</h3><ul>
<li>需求：修改之前的分布式锁实现</li>
<li>满足：在获取锁的时候存入线程标识（用UUID标识，在一个JVM中，ThreadId一般不会重复，但是我们现在是集群模式，有多个JVM，多个JVM之间可能会出现ThreadId重复的情况），在释放锁的时候先获取锁的线程标识，判断是否与当前线程标识一致<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
</li>
<li>核心逻辑：在存入锁的时候，放入自己的线程标识，在删除锁的时候，判断当前这把锁是不是自己存入的<ul>
<li>如果是，则进行删除</li>
<li>如果不是，则不进行删除</li>
</ul>
</li>
<li>具体实现代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;;</span><br><span class="line">@Override</span><br><span class="line">public boolean tryLock(long timeoutSec) &#123;</span><br><span class="line">    // 获取线程标识</span><br><span class="line">    String threadId = ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    // 获取锁</span><br><span class="line">    Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    return Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    // 获取当前线程的标识</span><br><span class="line">    String threadId = ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    // 获取锁中的标识</span><br><span class="line">    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    // 判断标识是否一致</span><br><span class="line">    if (threadId.equals(id)) &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h3><ul>
<li>更为极端的误删逻辑说明</li>
<li>假设线程1已经获取了锁，在判断标识一致之后，准备释放锁的时候，又出现了阻塞（例如JVM垃圾回收机制）</li>
<li>于是锁的TTL到期了，自动释放了</li>
<li>那么现在线程2趁虚而入，拿到了一把锁</li>
<li>但是线程1的逻辑还没执行完，那么线程1就会执行删除锁的逻辑</li>
<li>但是在阻塞前线程1已经判断了标识一致，所以现在线程1把线程2的锁给删了</li>
<li>那么就相当于判断标识那行代码没有起到作用</li>
<li>这就是删锁时的原子性问题</li>
<li>因为线程1的拿锁，判断标识，删锁，不是原子操作，所以我们要防止刚刚的情况</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635c85c916f2c2beb1236040.jpg"><img src="https://pic1.imgdb.cn/item/635c85c916f2c2beb1236040.jpg" alt="img"></a></p>
<h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><ul>
<li>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</li>
<li>Lua是一种编程语言，它的基本语法可以上菜鸟教程看看，链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></li>
<li>这里重点介绍Redis提供的调用函数，我们可以使用Lua去操作Redis，而且还能保证它的原子性，这样就可以实现<code>拿锁</code>，<code>判断标识</code>，<code>删锁</code>是一个原子性动作了</li>
<li>Redis提供的调用函数语法如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis.call(&#x27;命令名称&#x27;,&#x27;key&#x27;,&#x27;其他参数&#x27;, ...)</span><br></pre></td></tr></table></figure>

<ul>
<li>例如我们要执行<code>set name Kyle</code>，则脚本是这样</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">redis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;Kyle&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>例如我我们要执行<code>set name David</code>，在执行<code>get name</code>，则脚本如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">## 先执行set name David</span><br><span class="line">redis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;David&#x27;)</span><br><span class="line">## 再执行get name</span><br><span class="line">local name = redis.call(&#x27;get&#x27;, &#x27;name&#x27;)</span><br><span class="line">## 返回</span><br><span class="line">return name</span><br></pre></td></tr></table></figure>

<ul>
<li>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>例如，我们要调用<code>redis.call(&#39;set&#39;, &#39;name&#39;, &#39;Kyle&#39;) 0</code>这个脚本，语法如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">EVAL &quot;return redis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;Kyle&#x27;)&quot; 0</span><br></pre></td></tr></table></figure>

<ul>
<li>如果脚本中的key和value不想写死，可以作为参数传递，key类型参数会放入KEYS数组，其他参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组中获取这些参数</li>
</ul>
<p>注意：在Lua中，数组下标从1开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">EVAL &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot; 1 name Lucy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>那现在我们来使用Lua脚本来代替我们释放锁的逻辑</p>
</li>
<li><p>原逻辑</p>
</li>
<li><p>改写为Lua脚本01</p>
</li>
<li><p>改写为Lua脚本02</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    // 获取当前线程的标识</span><br><span class="line">    String threadId = ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    // 获取锁中的标识</span><br><span class="line">    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    // 判断标识是否一致</span><br><span class="line">    if (threadId.equals(id)) &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><ul>
<li>在RedisTemplate中，可以利用execute方法去执行lua脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public &lt;T&gt; T execute(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args) &#123;</span><br><span class="line">    return this.scriptExecutor.execute(script, keys, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对应的Java代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    UNLOCK_SCRIPT = new DefaultRedisScript();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>但是现在的分布式锁还存在一个问题：锁不住</p>
<ul>
<li>那什么是锁不住呢？<ul>
<li>如果锁的TTL快到期的时候，我们可以给它续期一下，比如续个30s，就好像是网吧上网，快没网费了的时候，让网管再给你续50块钱的，然后该玩玩，程序也继续往下执行</li>
<li>那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission了</li>
</ul>
</li>
</ul>
</li>
<li><p>小结：基于Redis分布式锁的实现思路</p>
<ul>
<li>利用SET NX EX获取锁，并设置过期时间，保存线程标识</li>
<li>释放锁时先判断线程标识是否与自己一致，一致则删除锁<ul>
<li>特性<ul>
<li>利用SET NX满足互斥性</li>
<li>利用SET EX保证故障时依然能释放锁，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式锁-Redisson"><a href="#分布式锁-Redisson" class="headerlink" title="分布式锁-Redisson"></a>分布式锁-Redisson</h2><ul>
<li>基于SETNX实现的分布式锁存在以下问题<ol>
<li>重入问题<ul>
<li>重入问题是指获取锁的线程，可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以可重入锁的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的</li>
</ul>
</li>
<li>不可重试<ul>
<li>我们编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁</li>
</ul>
</li>
<li>超时释放<ul>
<li>我们在加锁的时候增加了TTL，这样我们可以防止死锁，但是如果卡顿(阻塞)时间太长，也会导致锁的释放。虽然我们采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患</li>
</ul>
</li>
<li>主从一致性<ul>
<li>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题</li>
</ul>
</li>
</ol>
</li>
<li>那么什么是Redisson呢<ul>
<li>Redisson是一个在Redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现</li>
</ul>
</li>
<li>Redis提供了分布式锁的多种多样功能<ol>
<li>可重入锁(Reentrant Lock)</li>
<li>公平锁(Fair Lock)</li>
<li>联锁(MultiLock)</li>
<li>红锁(RedLock)</li>
<li>读写锁(ReadWriteLock)</li>
<li>信号量(Semaphore)</li>
<li>可过期性信号量(PermitExpirableSemaphore)</li>
<li>闭锁(CountDownLatch)</li>
</ol>
</li>
</ul>
<h3 id="Redisson入门"><a href="#Redisson入门" class="headerlink" title="Redisson入门"></a>Redisson入门</h3><ol>
<li>导入依赖</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.13.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>配置Redisson客户端，在config包下新建<code>RedissonConfig</code>类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">import org.redisson.Redisson;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.redisson.config.Config;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient() &#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">            .setAddress(&quot;redis://101.XXX.XXX.160:6379&quot;)</span><br><span class="line">            .setPassword(&quot;root&quot;);</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用Redisson的分布式锁</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Resource</span><br><span class="line">private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void testRedisson() throws InterruptedException &#123;</span><br><span class="line">    //获取可重入锁</span><br><span class="line">    RLock lock = redissonClient.getLock(&quot;anyLock&quot;);</span><br><span class="line">    //尝试获取锁，三个参数分别是：获取锁的最大等待时间(期间会重试)，锁的自动释放时间，时间单位</span><br><span class="line">    boolean success = lock.tryLock(1,10, TimeUnit.SECONDS);</span><br><span class="line">    //判断获取锁成功</span><br><span class="line">    if (success) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;执行业务&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>替换我们之前自己写的分布式锁</li>
</ol>
<ul>
<li>DIFF</li>
<li>修改后的代码</li>
</ul>
<p>这里要注入一下RedissonClient</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DIFF</span><br><span class="line"></span><br><span class="line">+   @Resource</span><br><span class="line">+   private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //1. 查询优惠券</span><br><span class="line">        queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">        SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">        //2. 判断秒杀时间是否开始</span><br><span class="line">        if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀还未开始，请耐心等待&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //3. 判断秒杀时间是否结束</span><br><span class="line">        if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀已经结束！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //4. 判断库存是否充足</span><br><span class="line">        if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">            return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">-       SimpleRedisLock redisLock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br><span class="line">+       RLock redisLock = redissonClient.getLock(&quot;order:&quot; + userId);</span><br><span class="line">-       boolean isLock = redisLock.tryLock(120);</span><br><span class="line">+       boolean isLock = redisLock.tryLock();</span><br><span class="line">        if (!isLock) &#123;</span><br><span class="line">            return Result.fail(&quot;不允许抢多张优惠券&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            return proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用Jmeter进行压力测试，依旧是只能抢到一张优惠券，满足我们的需求</li>
</ul>
<h3 id="Redisson可重入锁原理"><a href="#Redisson可重入锁原理" class="headerlink" title="Redisson可重入锁原理"></a>Redisson可重入锁原理</h3><ul>
<li><p>在Lock锁中，他是借助于等曾的一个voaltile的一个state变量来记录重入的状态的</p>
<ul>
<li><p>如果当前<code>没有</code>人持有这把锁，那么<code>state = 0</code></p>
</li>
<li><p>如果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有</span><br></pre></td></tr></table></figure>

<p>人持有这把锁，那么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = 1</span><br></pre></td></tr></table></figure>

<ul>
<li>如果持有者把锁的人再次持有这把锁，那么state会<code>+1</code></li>
</ul>
</li>
<li><p>如果对于<code>synchronize</code>而言，他在c语言代码中会有一个count</p>
</li>
<li><p>原理与<code>state</code>类似，也是重入一次就<code>+1</code>，释放一次就<code>-1</code>，直至减到0，表示这把锁没有被人持有</p>
</li>
</ul>
</li>
<li><p>在redisson中，我们也支持可重入锁</p>
<ul>
<li>在分布式锁中，它采用hash结构来存储锁，其中外层key表示这把锁是否存在，内层key则记录当前这把锁被哪个线程持有</li>
</ul>
</li>
<li><p>method1在方法内部调用method2，method1和method2出于同一个线程，那么method1已经拿到一把锁了，想进入method2中拿另外一把锁，必然是拿不到的，于是就出现了死锁</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Resource</span><br><span class="line">private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">private RLock lock;</span><br><span class="line"></span><br><span class="line">@BeforeEach</span><br><span class="line">void setUp() &#123;</span><br><span class="line">    lock = redissonClient.getLock(&quot;lock&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void method1() &#123;</span><br><span class="line">    boolean success = lock.tryLock();</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">        log.error(&quot;获取锁失败，1&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        log.info(&quot;获取锁成功&quot;);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        log.info(&quot;释放锁，1&quot;);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void method2() &#123;</span><br><span class="line">    RLock lock = redissonClient.getLock(&quot;lock&quot;);</span><br><span class="line">    boolean success = lock.tryLock();</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">        log.error(&quot;获取锁失败，2&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        log.info(&quot;获取锁成功，2&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        log.info(&quot;释放锁，2&quot;);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以我们需要额外判断，method1和method2是否处于同一线程，如果是同一个线程，则可以拿到锁，但是state会<code>+1</code>，之后执行method2中的方法，释放锁，释放锁的时候也只是将state进行<code>-1</code>，只有减至0，才会真正释放锁</li>
<li>由于我们需要额外存储一个state，所以用字符串型<code>SET NX EX</code>是不行的，需要用到<code>Hash</code>结构，但是<code>Hash</code>结构又没有<code>NX</code>这种方法，所以我们需要将原有的逻辑拆开，进行手动判断</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635cea4f16f2c2beb1df2620.jpg"><img src="https://pic1.imgdb.cn/item/635cea4f16f2c2beb1df2620.jpg" alt="img"></a></p>
<ul>
<li><p>为了保证原子性，所以流程图中的业务逻辑也是需要我们用Lua来实现的</p>
<ul>
<li>获取锁的逻辑</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LUA</span><br><span class="line"></span><br><span class="line">local key = KEYS[1]; -- 锁的key</span><br><span class="line">local threadId = ARGV[1]; -- 线程唯一标识</span><br><span class="line">local releaseTime = ARGV[2]; -- 锁的自动释放时间</span><br><span class="line">-- 锁不存在</span><br><span class="line">if (redis.call(&#x27;exists&#x27;, key) == 0) then</span><br><span class="line">    -- 获取锁并添加线程标识，state设为1</span><br><span class="line">    redis.call(&#x27;hset&#x27;, key, threadId, &#x27;1&#x27;);</span><br><span class="line">    -- 设置锁有效期</span><br><span class="line">    redis.call(&#x27;expire&#x27;, key, releaseTime);</span><br><span class="line">    return 1; -- 返回结果</span><br><span class="line">end;</span><br><span class="line">-- 锁存在，判断threadId是否为自己</span><br><span class="line">if (redis.call(&#x27;hexists&#x27;, key, threadId) == 1) then</span><br><span class="line">    -- 锁存在，重入次数 +1，这里用的是hash结构的incrby增长</span><br><span class="line">    redis.call(&#x27;hincrby&#x27;, key, thread, 1);</span><br><span class="line">    -- 设置锁的有效期</span><br><span class="line">    redis.call(&#x27;expire&#x27;, key, releaseTime);</span><br><span class="line">    return 1; -- 返回结果</span><br><span class="line">end;</span><br><span class="line">return 0; -- 代码走到这里，说明获取锁的不是自己，获取锁失败</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁的逻辑</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LUA</span><br><span class="line"></span><br><span class="line">local key = KEYS[1];</span><br><span class="line">local threadId = ARGV[1];</span><br><span class="line">local releaseTime = ARGV[2];</span><br><span class="line">-- 如果锁不是自己的</span><br><span class="line">if (redis.call(&#x27;HEXISTS&#x27;, key, threadId) == 0) then</span><br><span class="line">    return nil; -- 直接返回</span><br><span class="line">end;</span><br><span class="line">-- 锁是自己的，锁计数-1，还是用hincrby，不过自增长的值为-1</span><br><span class="line">local count = redis.call(&#x27;hincrby&#x27;, key, threadId, -1);</span><br><span class="line">-- 判断重入次数为多少</span><br><span class="line">if (count &gt; 0) then</span><br><span class="line">    -- 大于0，重置有效期</span><br><span class="line">    redis.call(&#x27;expire&#x27;, key, releaseTime);</span><br><span class="line">    return nil;</span><br><span class="line">else</span><br><span class="line">    -- 否则直接释放锁</span><br><span class="line">    redis.call(&#x27;del&#x27;, key);</span><br><span class="line">    return nil;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取锁源码<br>查看源码，跟我们的实现方式几乎一致</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;</span><br><span class="line">    this.internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">    return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, command, &quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;, Collections.singletonList(this.getName()), this.internalLockLeaseTime, this.getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁源码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">protected RFuture&lt;Boolean&gt; unlockInnerAsync(long threadId) &#123;</span><br><span class="line">    return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); if (counter &gt; 0) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); return 0; else redis.call(&#x27;del&#x27;, KEYS[1]); redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end; return nil;&quot;, Arrays.asList(this.getName(), this.getChannelName()), LockPubSub.UNLOCK_MESSAGE, this.internalLockLeaseTime, this.getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redisson锁重试和WatchDog机制"><a href="#Redisson锁重试和WatchDog机制" class="headerlink" title="Redisson锁重试和WatchDog机制"></a>Redisson锁重试和WatchDog机制</h3><ul>
<li>前面我们分析的是空参的tryLock方法，现在我们来分析一下这个带参数的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;</span><br><span class="line">    this.internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">    return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, command, &quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;, Collections.singletonList(this.getName()), this.internalLockLeaseTime, this.getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>源码分析</li>
<li>tryAcquireAsync</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) &#123;</span><br><span class="line">    </span><br><span class="line">    if (leaseTime != -1L) &#123;</span><br><span class="line">        return this.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果没有指定释放时间时间，则指定默认释放时间为getLockWatchdogTimeout，底层源码显示是30*1000ms，也就是30秒</span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = this.tryLockInnerAsync(waitTime, this.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            if (e == null) &#123;</span><br><span class="line">                if (ttlRemaining == null) &#123;</span><br><span class="line">                    this.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>tryLock</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        long time = unit.toMillis(waitTime);</span><br><span class="line">        long current = System.currentTimeMillis();</span><br><span class="line">        long threadId = Thread.currentThread().getId();</span><br><span class="line">        Long ttl = this.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">        //判断ttl是否为null</span><br><span class="line">        if (ttl == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //计算当前时间与获取锁时间的差值，让等待时间减去这个值</span><br><span class="line">            time -= System.currentTimeMillis() - current;</span><br><span class="line">            //如果消耗时间太长了，直接返回false，获取锁失败</span><br><span class="line">            if (time &lt;= 0L) &#123;</span><br><span class="line">                this.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //等待时间还有剩余，再次获取当前时间</span><br><span class="line">                current = System.currentTimeMillis();</span><br><span class="line">                //订阅别人释放锁的信号</span><br><span class="line">                RFuture&lt;RedissonLockEntry&gt; subscribeFuture = this.subscribe(threadId);</span><br><span class="line">                //在剩余时间内，等待这个信号</span><br><span class="line">                if (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    if (!subscribeFuture.cancel(false)) &#123;</span><br><span class="line">                        subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                            if (e == null) &#123;</span><br><span class="line">                                //取消订阅</span><br><span class="line">                                this.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //剩余时间内没等到，返回false</span><br><span class="line">                    this.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //如果剩余时间内等到了别人释放锁的信号，再次计算当前剩余最大等待时间</span><br><span class="line">                        time -= System.currentTimeMillis() - current;</span><br><span class="line">                        if (time &lt;= 0L) &#123;</span><br><span class="line">                            //如果剩余时间为负数，则直接返回false</span><br><span class="line">                            this.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                            boolean var20 = false;</span><br><span class="line">                            return var20;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            boolean var16;</span><br><span class="line">                            do &#123;</span><br><span class="line">                                //如果剩余时间等到了，dowhile循环重试获取锁</span><br><span class="line">                                long currentTime = System.currentTimeMillis();</span><br><span class="line">                                ttl = this.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">                                if (ttl == null) &#123;</span><br><span class="line">                                    var16 = true;</span><br><span class="line">                                    return var16;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                                if (time &lt;= 0L) &#123;</span><br><span class="line">                                    this.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                                    var16 = false;</span><br><span class="line">                                    return var16;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                currentTime = System.currentTimeMillis();</span><br><span class="line">                                if (ttl &gt;= 0L &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                                    ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                            &#125; while(time &gt; 0L);</span><br><span class="line"></span><br><span class="line">                            this.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                            var16 = false;</span><br><span class="line">                            return var16;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        this.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>scheduleExpirationRenewal</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">private void scheduleExpirationRenewal(long threadId) &#123;</span><br><span class="line">    ExpirationEntry entry = new ExpirationEntry();  </span><br><span class="line">    //不存在，才put，表明是第一次进入，不是重入</span><br><span class="line">    ExpirationEntry oldEntry = (ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(this.getEntryName(), entry);</span><br><span class="line">    if (oldEntry != null) &#123;</span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果是第一次进入，则跟新有效期</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        this.renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>renewExpiration</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">private void renewExpiration() &#123;</span><br><span class="line">    ExpirationEntry ee = (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(this.getEntryName());</span><br><span class="line">    if (ee != null) &#123;</span><br><span class="line">        //Timeout是一个定时任务</span><br><span class="line">        Timeout task = this.commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;</span><br><span class="line">            public void run(Timeout timeout) throws Exception &#123;</span><br><span class="line">                ExpirationEntry ent = (ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.this.getEntryName());</span><br><span class="line">                if (ent != null) &#123;</span><br><span class="line">                    Long threadId = ent.getFirstThreadId();</span><br><span class="line">                    if (threadId != null) &#123;</span><br><span class="line">                        //重置有效期</span><br><span class="line">                        RFuture&lt;Boolean&gt; future = RedissonLock.this.renewExpirationAsync(threadId);</span><br><span class="line">                        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                            if (e != null) &#123;</span><br><span class="line">                                RedissonLock.log.error(&quot;Can&#x27;t update lock &quot; + RedissonLock.this.getName() + &quot; expiration&quot;, e);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                if (res) &#123;</span><br><span class="line">                                    //然后调用自己，递归重置有效期</span><br><span class="line">                                    RedissonLock.this.renewExpiration();</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //internalLockLeaseTime是之前WatchDog默认有效期30秒，那这里就是 30 / 3 = 10秒之后，才会执行</span><br><span class="line">        &#125;, this.internalLockLeaseTime / 3L, TimeUnit.MILLISECONDS);</span><br><span class="line">        ee.setTimeout(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>renewExpirationAsync<br>重点看lua脚本，先判断锁是不是自己的，然后更新有效时间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">protected RFuture&lt;Boolean&gt; renewExpirationAsync(long threadId) &#123;</span><br><span class="line">    return this.evalWriteAsync(this.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return 1; end; return 0;&quot;, Collections.singletonList(this.getName()), this.internalLockLeaseTime, this.getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>那么之前的重置有效期的行为该怎么终止呢？当然是释放锁的时候会终止</li>
<li>cancelExpirationRenewal</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">void cancelExpirationRenewal(Long threadId) &#123;</span><br><span class="line">    //将之前的线程终止掉</span><br><span class="line">    ExpirationEntry task = (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(this.getEntryName());</span><br><span class="line">    if (task != null) &#123;</span><br><span class="line">        if (threadId != null) &#123;</span><br><span class="line">            task.removeThreadId(threadId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (threadId == null || task.hasNoThreads()) &#123;</span><br><span class="line">            //获取之前的定时任务</span><br><span class="line">            Timeout timeout = task.getTimeout();</span><br><span class="line">            if (timeout != null) &#123;</span><br><span class="line">                //取消</span><br><span class="line">                timeout.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EXPIRATION_RENEWAL_MAP.remove(this.getEntryName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635d046816f2c2beb1293315.jpg"><img src="https://pic1.imgdb.cn/item/635d046816f2c2beb1293315.jpg" alt="img"></a></p>
<h3 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a>Redisson锁的MutiLock原理</h3><ul>
<li>为了提高Redis的可用性，我们会搭建集群或者主从，现在以主从为例</li>
<li>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设主机还没来得及把数据写入到从机去的时候，主机宕机了</li>
<li>哨兵会发现主机宕机了，于是选举一个slave(从机)变成master(主机)，而此时新的master(主机)上并没有锁的信息，那么其他线程就可以获取锁，又会引发安全问题</li>
<li>为了解决这个问题。Redisson提出来了MutiLock锁，使用这把锁的话，那我们就不用主从了，每个节点的地位都是一样的，都可以当做是主机，那我们就需要将加锁的逻辑写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性</li>
<li>我们先使用虚拟机额外搭建两个Redis节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient() &#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://192.168.137.130:6379&quot;)</span><br><span class="line">                .setPassword(&quot;root&quot;);</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient2() &#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://92.168.137.131:6379&quot;)</span><br><span class="line">                .setPassword(&quot;root&quot;);</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient3() &#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://92.168.137.132:6379&quot;)</span><br><span class="line">                .setPassword(&quot;root&quot;);</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用联锁，我们首先要注入三个RedissonClient对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Resource</span><br><span class="line">private RedissonClient redissonClient;</span><br><span class="line">@Resource</span><br><span class="line">private RedissonClient redissonClient2;</span><br><span class="line">@Resource</span><br><span class="line">private RedissonClient redissonClient3;</span><br><span class="line"></span><br><span class="line">private RLock lock;</span><br><span class="line"></span><br><span class="line">@BeforeEach</span><br><span class="line">void setUp() &#123;</span><br><span class="line">    RLock lock1 = redissonClient.getLock(&quot;lock&quot;);</span><br><span class="line">    RLock lock2 = redissonClient2.getLock(&quot;lock&quot;);</span><br><span class="line">    RLock lock3 = redissonClient3.getLock(&quot;lock&quot;);</span><br><span class="line">    lock = redissonClient.getMultiLock(lock1, lock2, lock3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void method1() &#123;</span><br><span class="line">    boolean success = lock.tryLock();</span><br><span class="line">    redissonClient.getMultiLock();</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">        log.error(&quot;获取锁失败，1&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        log.info(&quot;获取锁成功&quot;);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        log.info(&quot;释放锁，1&quot;);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void method2() &#123;</span><br><span class="line">    RLock lock = redissonClient.getLock(&quot;lock&quot;);</span><br><span class="line">    boolean success = lock.tryLock();</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">        log.error(&quot;获取锁失败，2&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        log.info(&quot;获取锁成功，2&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        log.info(&quot;释放锁，2&quot;);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>源码分析</li>
<li>当我们没有传入锁对象来创建联锁的时候，则会抛出一个异常，反之则将我们传入的可变参数锁对象封装成一个集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public RedissonMultiLock(RLock... locks) &#123;</span><br><span class="line">    if (locks.length == 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Lock objects are not defined&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.locks.addAll(Arrays.asList(locks));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>联锁的tryLock</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    long newLeaseTime = -1L;</span><br><span class="line">    //如果传入了释放时间</span><br><span class="line">    if (leaseTime != -1L) &#123;</span><br><span class="line">        //再判断一下是否有等待时间</span><br><span class="line">        if (waitTime == -1L) &#123;</span><br><span class="line">            //如果没传等待时间，不重试，则只获得一次</span><br><span class="line">            newLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //想要重试，耗时较久，万一释放时间小于等待时间，则会有问题，所以这里将等待时间乘以二</span><br><span class="line">            newLeaseTime = unit.toMillis(waitTime) * 2L;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取当前时间</span><br><span class="line">    long time = System.currentTimeMillis();</span><br><span class="line">    //剩余等待时间</span><br><span class="line">    long remainTime = -1L;</span><br><span class="line">    if (waitTime != -1L) &#123;</span><br><span class="line">        remainTime = unit.toMillis(waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">    //锁等待时间，与剩余等待时间一样    </span><br><span class="line">    long lockWaitTime = this.calcLockWaitTime(remainTime);</span><br><span class="line">    //锁失败的限制，源码返回是的0</span><br><span class="line">    int failedLocksLimit = this.failedLocksLimit();</span><br><span class="line">    //已经获取成功的锁</span><br><span class="line">    List&lt;RLock&gt; acquiredLocks = new ArrayList(this.locks.size());</span><br><span class="line">    //迭代器，用于遍历</span><br><span class="line">    ListIterator&lt;RLock&gt; iterator = this.locks.listIterator();</span><br><span class="line"></span><br><span class="line">    while(iterator.hasNext()) &#123;</span><br><span class="line">        RLock lock = (RLock)iterator.next();</span><br><span class="line"></span><br><span class="line">        boolean lockAcquired;</span><br><span class="line">        try &#123;</span><br><span class="line">            //没有等待时间和释放时间，调用空参的tryLock</span><br><span class="line">            if (waitTime == -1L &amp;&amp; leaseTime == -1L) &#123;</span><br><span class="line">                lockAcquired = lock.tryLock();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //否则调用带参的tryLock</span><br><span class="line">                long awaitTime = Math.min(lockWaitTime, remainTime);</span><br><span class="line">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RedisResponseTimeoutException var21) &#123;</span><br><span class="line">            this.unlockInner(Arrays.asList(lock));</span><br><span class="line">            lockAcquired = false;</span><br><span class="line">        &#125; catch (Exception var22) &#123;</span><br><span class="line">            lockAcquired = false;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断获取锁是否成功</span><br><span class="line">        if (lockAcquired) &#123;</span><br><span class="line">            //成功则将锁放入成功锁的集合</span><br><span class="line">            acquiredLocks.add(lock);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果获取锁失败</span><br><span class="line">            //判断当前锁的数量，减去成功获取锁的数量，如果为0，则所有锁都成功获取，跳出循环</span><br><span class="line">            if (this.locks.size() - acquiredLocks.size() == this.failedLocksLimit()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //否则将拿到的锁都释放掉</span><br><span class="line">            if (failedLocksLimit == 0) &#123;</span><br><span class="line">                this.unlockInner(acquiredLocks);</span><br><span class="line">                //如果等待时间为-1，则不想重试，直接返回false</span><br><span class="line">                if (waitTime == -1L) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                failedLocksLimit = this.failedLocksLimit();</span><br><span class="line">                //将已经拿到的锁都清空</span><br><span class="line">                acquiredLocks.clear();</span><br><span class="line">                //将迭代器往前迭代，相当于重置指针，放到第一个然后重试获取锁</span><br><span class="line">                while(iterator.hasPrevious()) &#123;</span><br><span class="line">                    iterator.previous();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                --failedLocksLimit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果剩余时间不为-1，很充足</span><br><span class="line">        if (remainTime != -1L) &#123;</span><br><span class="line">            //计算现在剩余时间</span><br><span class="line">            remainTime -= System.currentTimeMillis() - time;</span><br><span class="line">            time = System.currentTimeMillis();</span><br><span class="line">            //如果剩余时间为负数，则获取锁超时了</span><br><span class="line">            if (remainTime &lt;= 0L) &#123;</span><br><span class="line">                //将之前已经获取到的锁释放掉，并返回false</span><br><span class="line">                this.unlockInner(acquiredLocks);</span><br><span class="line">                //联锁成功的条件是：每一把锁都必须成功获取，一把锁失败，则都失败</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果设置了锁的有效期</span><br><span class="line">    if (leaseTime != -1L) &#123;</span><br><span class="line">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = new ArrayList(acquiredLocks.size());</span><br><span class="line">        //迭代器用于遍历已经获取成功的锁</span><br><span class="line">        Iterator var24 = acquiredLocks.iterator();</span><br><span class="line"></span><br><span class="line">        while(var24.hasNext()) &#123;</span><br><span class="line">            RLock rLock = (RLock)var24.next();</span><br><span class="line">            //设置每一把锁的有效期</span><br><span class="line">            RFuture&lt;Boolean&gt; future = ((RedissonLock)rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var24 = futures.iterator();</span><br><span class="line"></span><br><span class="line">        while(var24.hasNext()) &#123;</span><br><span class="line">            RFuture&lt;Boolean&gt; rFuture = (RFuture)var24.next();</span><br><span class="line">            rFuture.syncUninterruptibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //但如果没设置有效期，则会触发WatchDog机制，自动帮我们设置有效期，所以大多数情况下，我们不需要自己设置有效期</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>不可重入Redis分布式锁<ul>
<li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li>
<li>缺陷：不可重入、无法重试、锁超时失效</li>
</ul>
</li>
<li>可重入Redis分布式锁<ul>
<li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li>
<li>缺陷：Redis宕机引起锁失效问题</li>
</ul>
</li>
<li>Redisson的multiLock<ul>
<li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li>
</ul>
</li>
</ol>
<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><h3 id="异步秒杀思路"><a href="#异步秒杀思路" class="headerlink" title="异步秒杀思路"></a>异步秒杀思路</h3><ul>
<li>我们先来回顾一下下单流程</li>
<li>当用户发起请求，此时会先请求Nginx，Nginx反向代理到Tomcat，而Tomcat中的程序，会进行串行操作，分为如下几个步骤<ol>
<li>查询优惠券</li>
<li>判断秒杀库存是否足够</li>
<li>查询订单</li>
<li>校验是否一人一单</li>
<li>扣减库存</li>
<li>创建订单</li>
</ol>
</li>
<li>在这六个步骤中，有很多操作都是要去操作数据库的，而且还是一个线程串行执行，这样就会导致我们的程序执行很慢，所以我们需要异步程序执行，那么如何加速呢？</li>
<li><code>优化方案：</code>我们将耗时较短的逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635dedfc16f2c2beb1c42f52.jpg"><img src="https://pic1.imgdb.cn/item/635dedfc16f2c2beb1c42f52.jpg" alt="img"></a></li>
<li>但是这里还存在两个难点<ol>
<li>我们怎么在Redis中快速校验是否一人一单，还有库存判断</li>
<li>我们校验一人一单和将下单数据写入数据库，这是两个线程，我们怎么知道下单是否完成。<ul>
<li>我们需要将一些信息返回给前端，同时也将这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询下单逻辑是否完成</li>
</ul>
</li>
</ol>
</li>
<li>我们现在来看整体思路：当用户下单之后，判断库存是否充足，只需要取Redis中根据key找对应的value是否大于0即可，如果不充足，则直接结束。如果充足，则在Redis中判断用户是否可以下单，如果set集合中没有该用户的下单数据，则可以下单，并将userId和优惠券存入到Redis中，并且返回0，整个过程需要保证是原子性的，所以我们要用Lua来操作，同时由于我们需要在Redis中查询优惠券信息，所以在我们新增秒杀优惠券的同时，需要将优惠券信息保存到Redis中</li>
<li>完成以上逻辑判断时，我们只需要判断当前Redis中的返回值是否为0，如果是0，则表示可以下单，将信息保存到queue中去，然后返回，开一个线程来异步下单，其阿奴单可以通过返回订单的id来判断是否下单成功</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/635df17d16f2c2beb1cf02be.jpg"><img src="https://pic1.imgdb.cn/item/635df17d16f2c2beb1cf02be.jpg" alt="img"></a></p>
<h3 id="Redis完成秒杀资格判断"><a href="#Redis完成秒杀资格判断" class="headerlink" title="Redis完成秒杀资格判断"></a>Redis完成秒杀资格判断</h3><ul>
<li>需求：<ol>
<li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</li>
<li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否秒杀成功</li>
</ol>
</li>
<li><code>步骤一：</code>修改保存优惠券相关代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional</span><br><span class="line">public void addSeckillVoucher(Voucher voucher) &#123;</span><br><span class="line">    // 保存优惠券</span><br><span class="line">    save(voucher);</span><br><span class="line">    // 保存秒杀信息</span><br><span class="line">    SeckillVoucher seckillVoucher = new SeckillVoucher();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    // 保存秒杀优惠券信息到Reids，Key名中包含优惠券ID，Value为优惠券的剩余数量</span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用PostMan发送请求，添加优惠券<br>请求路径：<a target="_blank" rel="noopener" href="http://localhost:8080/api/voucher/seckill">http://localhost:8080/api/voucher/seckill</a><br>请求方式：POST</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JSON</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;shopId&quot;:1,</span><br><span class="line">    &quot;title&quot;:&quot;9999元代金券&quot;,</span><br><span class="line">    &quot;subTitle&quot;:&quot;365*24小时可用&quot;,</span><br><span class="line">    &quot;rules&quot;:&quot;全场通用\\nApex猎杀无需预约&quot;,</span><br><span class="line">    &quot;payValue&quot;:1000,</span><br><span class="line">    &quot;actualValue&quot;:999900,</span><br><span class="line">    &quot;type&quot;:1,</span><br><span class="line">    &quot;stock&quot;:100,</span><br><span class="line">    &quot;beginTime&quot;:&quot;2022-01-01T00:00:00&quot;,</span><br><span class="line">    &quot;endTime&quot;:&quot;2022-12-31T23:59:59&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加成功后，数据库中和Redis中都能看到优惠券信息</li>
<li><code>步骤二：</code>编写Lua脚本<br>lua的字符串拼接使用<code>..</code>，字符串转数字是<code>tonumber()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LUA</span><br><span class="line"></span><br><span class="line">-- 订单id</span><br><span class="line">local voucherId = ARGV[1]</span><br><span class="line">-- 用户id</span><br><span class="line">local userId = ARGV[2]</span><br><span class="line">-- 优惠券key</span><br><span class="line">local stockKey = &#x27;seckill:stock:&#x27; .. voucherId</span><br><span class="line">-- 订单key</span><br><span class="line">local orderKey = &#x27;seckill:order:&#x27; .. voucherId</span><br><span class="line">-- 判断库存是否充足</span><br><span class="line">if (tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then</span><br><span class="line">    return 1</span><br><span class="line">end</span><br><span class="line">-- 判断用户是否下单</span><br><span class="line">if (redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then</span><br><span class="line">    return 2</span><br><span class="line">end</span><br><span class="line">-- 扣减库存</span><br><span class="line">redis.call(&#x27;incrby&#x27;, stockKey, -1)</span><br><span class="line">-- 将userId存入当前优惠券的set集合</span><br><span class="line">redis.call(&#x27;sadd&#x27;, orderKey, userId)</span><br><span class="line">return 0</span><br></pre></td></tr></table></figure>

<ul>
<li>修改业务逻辑</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    //1. 执行lua脚本</span><br><span class="line">    Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(), voucherId.toString(),</span><br><span class="line">            UserHolder.getUser().getId().toString());</span><br><span class="line">    //2. 判断返回值，并返回错误信息</span><br><span class="line">    if (result.intValue() != 0) &#123;</span><br><span class="line">        return Result.fail(result.intValue() == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">    //TODO 保存阻塞队列</span><br><span class="line"></span><br><span class="line">    //3. 返回订单id</span><br><span class="line">    return Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在我们使用PostMan发送请求，redis中的数据会变动，而且不能重复下单，但是数据库中的数据并没有变化</li>
</ul>
<h3 id="基于阻塞队列实现秒杀优化"><a href="#基于阻塞队列实现秒杀优化" class="headerlink" title="基于阻塞队列实现秒杀优化"></a>基于阻塞队列实现秒杀优化</h3><ul>
<li>修改下单的操作，我们在下单时，是通过Lua表达式去原子执行判断逻辑，如果判断结果不为0，返回错误信息，如果判断结果为0，则将下单的逻辑保存到队列中去，然后异步执行</li>
<li>需求<ol>
<li>如果秒杀成功，则将优惠券id和用户id封装后存入阻塞队列</li>
<li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li>
</ol>
</li>
<li><code>步骤一：</code>创建阻塞队列<br>阻塞队列有一个特点：当一个线程尝试从阻塞队列里获取元素的时候，如果没有元素，那么该线程就会被阻塞，直到队列中有元素，才会被唤醒，并去获取元素<br>阻塞队列的创建需要指定一个大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private final BlockingQueue&lt;VoucherOrder&gt; orderTasks = new ArrayBlockingQueue&lt;&gt;(1024 * 1024);</span><br></pre></td></tr></table></figure>

<ul>
<li>那么把优惠券id和用户id封装后存入阻塞队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(), voucherId.toString(),</span><br><span class="line">            UserHolder.getUser().getId().toString());</span><br><span class="line">    if (result.intValue() != 0) &#123;</span><br><span class="line">        return Result.fail(result.intValue() == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">    //封装到voucherOrder中</span><br><span class="line">    VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    //加入到阻塞队列</span><br><span class="line">    orderTasks.add(voucherOrder);</span><br><span class="line">    return Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code>步骤二：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实现异步下单功能</span><br><span class="line"></span><br><span class="line">1. 先创建一个线程池</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JAVA
private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 创建线程任务，秒杀业务需要在类初始化之后，就立即执行，所以这里需要用到`@PostConstruct`注解</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JAVA

@PostConstruct
private void init() &#123;
    SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
&#125;

private class VoucherOrderHandler implements Runnable &#123;
    @Override
    public void run() &#123;
        while (true) &#123;
            try &#123;
                //1. 获取队列中的订单信息
                VoucherOrder voucherOrder = orderTasks.take();
                //2. 创建订单
                handleVoucherOrder(voucherOrder);
            &#125; catch (Exception e) &#123;
                log.error(&quot;订单处理异常&quot;, e);
            &#125;
        &#125;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 编写创建订单的业务逻辑</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JAVA

private IVoucherOrderService proxy;
private void handleVoucherOrder(VoucherOrder voucherOrder) &#123;
    //1. 获取用户
    Long userId = voucherOrder.getUserId();
    //2. 创建锁对象，作为兜底方案
    RLock redisLock = redissonClient.getLock(&quot;order:&quot; + userId);
    //3. 获取锁
    boolean isLock = redisLock.tryLock();
    //4. 判断是否获取锁成功         
    if (!isLock) &#123;
        log.error(&quot;不允许重复下单!&quot;);
        return;
    &#125;
    try &#123;
        //5. 使用代理对象，由于这里是另外一个线程，
        proxy.createVoucherOrder(voucherOrder);
    &#125; finally &#123;
        redisLock.unlock();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 查看AopContext源码，它的获取代理对象也是通过ThreadLocal进行获取的，由于我们这里是异步下单，和主线程不是一个线程，所以不能获取成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JAVA
private static final ThreadLocal&lt;Object&gt; currentProxy = new NamedThreadLocal(&quot;Current AOP proxy&quot;);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 但是我们可以将proxy放在成员变量的位置，然后在主线程中获取代理对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JAVA

@Override
public Result seckillVoucher(Long voucherId) &#123;
    Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,
            Collections.emptyList(), voucherId.toString(),
            UserHolder.getUser().getId().toString());
    if (result.intValue() != 0) &#123;
        return Result.fail(result.intValue() == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;);
    &#125;
    long orderId = redisIdWorker.nextId(&quot;order&quot;);
    //封装到voucherOrder中
    VoucherOrder voucherOrder = new VoucherOrder();
    voucherOrder.setVoucherId(voucherId);
    voucherOrder.setUserId(UserHolder.getUser().getId());
    voucherOrder.setId(orderId);
    //加入到阻塞队列
    orderTasks.add(voucherOrder);
    //主线程获取代理对象
    proxy = (IVoucherOrderService) AopContext.currentProxy();
    return Result.ok(orderId);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 完整代码如下</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>JAVA</p>
<p>package com.hmdp.service.impl;</p>
<p>import com.hmdp.dto.Result;<br>import com.hmdp.entity.VoucherOrder;<br>import com.hmdp.mapper.VoucherOrderMapper;<br>import com.hmdp.service.ISeckillVoucherService;<br>import com.hmdp.service.IVoucherOrderService;<br>import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;<br>import com.hmdp.utils.RedisIdWorker;<br>import com.hmdp.utils.UserHolder;<br>import lombok.extern.slf4j.Slf4j;<br>import org.redisson.api.RLock;<br>import org.redisson.api.RedissonClient;<br>import org.springframework.aop.framework.AopContext;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.core.io.ClassPathResource;<br>import org.springframework.data.redis.core.StringRedisTemplate;<br>import org.springframework.data.redis.core.script.DefaultRedisScript;<br>import org.springframework.stereotype.Service;<br>import org.springframework.transaction.annotation.Transactional;</p>
<p>import javax.annotation.PostConstruct;<br>import javax.annotation.Resource;<br>import java.util.Collections;<br>import java.util.concurrent.ArrayBlockingQueue;<br>import java.util.concurrent.BlockingQueue;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;</p>
<p>&#x2F;**</p>
<ul>
<li><p></p></li>
<li><p>服务实现类</p>
</li>
<li><p></p></li>
<li></li>
<li><p>@author Kyle</p>
</li>
<li><p>@since 2022-10-22<br> *&#x2F;<br>@Service<br>@Slf4j<br>public class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService {</p>
<p> @Autowired<br> private ISeckillVoucherService seckillVoucherService;</p>
<p> @Autowired<br> private RedisIdWorker redisIdWorker;</p>
<p> @Resource<br> private StringRedisTemplate stringRedisTemplate;</p>
<p> @Resource<br> private RedissonClient redissonClient;</p>
<p> private IVoucherOrderService proxy;</p>
<p> private static final DefaultRedisScript<Long> SECKILL_SCRIPT;</Long></p>
<p> static {<br> SECKILL_SCRIPT &#x3D; new DefaultRedisScript();<br> SECKILL_SCRIPT.setLocation(new ClassPathResource(“seckill.lua”));<br> SECKILL_SCRIPT.setResultType(Long.class);<br> }</p>
<p> private static final ExecutorService SECKILL_ORDER_EXECUTOR &#x3D; Executors.newSingleThreadExecutor();</p>
<p> @PostConstruct<br> private void init() {<br> SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());<br> }</p>
<p> private final BlockingQueue<VoucherOrder> orderTasks &#x3D; new ArrayBlockingQueue&lt;&gt;(1024 * 1024);</VoucherOrder></p>
<p> private void handleVoucherOrder(VoucherOrder voucherOrder) {<br> &#x2F;&#x2F;1. 获取用户<br> Long userId &#x3D; voucherOrder.getUserId();<br> &#x2F;&#x2F;2. 创建锁对象，作为兜底方案<br> RLock redisLock &#x3D; redissonClient.getLock(“order:” + userId);<br> &#x2F;&#x2F;3. 获取锁<br> boolean isLock &#x3D; redisLock.tryLock();<br> &#x2F;&#x2F;4. 判断是否获取锁成功<br> if (!isLock) {<br>     log.error(“不允许重复下单!”);<br>     return;<br> }<br> try {<br>     &#x2F;&#x2F;5. 使用代理对象，由于这里是另外一个线程，<br>     proxy.createVoucherOrder(voucherOrder);<br> } finally {<br>     redisLock.unlock();<br> }<br> }</p>
<p> private class VoucherOrderHandler implements Runnable {<br> @Override<br> public void run() {<br>     while (true) {<br>         try {<br>             &#x2F;&#x2F;1. 获取队列中的订单信息<br>             VoucherOrder voucherOrder &#x3D; orderTasks.take();<br>             &#x2F;&#x2F;2. 创建订单<br>             handleVoucherOrder(voucherOrder);<br>         } catch (Exception e) {<br>             log.error(“订单处理异常”, e);<br>         }<br>     }<br> }<br> }</p>
<p> @Override<br> public Result seckillVoucher(Long voucherId) {<br> Long result &#x3D; stringRedisTemplate.execute(SECKILL_SCRIPT,<br>         Collections.emptyList(), voucherId.toString(),<br>         UserHolder.getUser().getId().toString());<br> if (result.intValue() !&#x3D; 0) {<br>     return Result.fail(result.intValue() &#x3D;&#x3D; 1 ? “库存不足” : “不能重复下单”);<br> }<br> long orderId &#x3D; redisIdWorker.nextId(“order”);<br> &#x2F;&#x2F;封装到voucherOrder中<br> VoucherOrder voucherOrder &#x3D; new VoucherOrder();<br> voucherOrder.setVoucherId(voucherId);<br> voucherOrder.setUserId(UserHolder.getUser().getId());<br> voucherOrder.setId(orderId);<br> &#x2F;&#x2F;加入到阻塞队列<br> orderTasks.add(voucherOrder);<br> &#x2F;&#x2F;主线程获取代理对象<br> proxy &#x3D; (IVoucherOrderService) AopContext.currentProxy();<br> return Result.ok(orderId);<br> }</p>
<p> @Transactional<br> public void createVoucherOrder(VoucherOrder voucherOrder) {<br> &#x2F;&#x2F; 一人一单逻辑<br> Long userId &#x3D; voucherOrder.getUserId();<br> Long voucherId &#x3D; voucherOrder.getVoucherId();<br> synchronized (userId.toString().intern()) {<br>     int count &#x3D; query().eq(“voucher_id”, voucherId).eq(“user_id”, userId).count();<br>     if (count &gt; 0) {<br>         log.error(“你已经抢过优惠券了哦”);<br>         return;<br>     }<br>     &#x2F;&#x2F;5. 扣减库存<br>     boolean success &#x3D; seckillVoucherService.update()<br>             .setSql(“stock &#x3D; stock - 1”)<br>             .eq(“voucher_id”, voucherId)<br>             .gt(“stock”, 0)<br>             .update();<br>     if (!success) {<br>         log.error(“库存不足”);<br>     }<br>     &#x2F;&#x2F;7. 将订单数据保存到表中<br>     save(voucherOrder);<br> }<br> }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 小结</span><br><span class="line"></span><br><span class="line">- 秒杀业务的优化思路是什么？</span><br><span class="line">  1. 先利用Redis完成库存容量、一人一单的判断，完成抢单业务</span><br><span class="line">  2. 再将下单业务放入阻塞队列，利用独立线程异步下单</span><br><span class="line">- 基于阻塞队列的异步秒杀存在哪些问题？</span><br><span class="line">  1. 内存限制问题：</span><br><span class="line">     - 我们现在使用的是JDK里的阻塞队列，它使用的是JVM的内存，如果在高并发的条件下，无数的订单都会放在阻塞队列里，可能就会造成内存溢出，所以我们在创建阻塞队列时，设置了一个长度，但是如果真的存满了，再有新的订单来往里塞，那就塞不进去了，存在内存限制问题</span><br><span class="line">  2. 数据安全问题：</span><br><span class="line">     - 经典服务器宕机了，用户明明下单了，但是数据库里没看到</span><br><span class="line"></span><br><span class="line">## Redis消息队列</span><br><span class="line"></span><br><span class="line">### 认识消息队列</span><br><span class="line"></span><br><span class="line">- 什么是消息队列？字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色</span><br><span class="line">  1. 消息队列：存储和管理消息，也被称为消息代理（Message Broker）</span><br><span class="line">  2. 生产者：发送消息到消息队列</span><br><span class="line">  3. 消费者：从消息队列获取消息并处理消息</span><br><span class="line">- 使用队列的好处在于`解耦`：举个例子，快递员(生产者)把快递放到驿站/快递柜里去(Message Queue)去，我们(消费者)从快递柜/驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的</span><br><span class="line">- 那么在这种场景下我们的秒杀就变成了：在我们下单之后，利用Redis去进行校验下单的结果，然后在通过队列把消息发送出去，然后在启动一个线程去拿到这个消息，完成解耦，同时也加快我们的响应速度</span><br><span class="line">- 这里我们可以直接使用一些现成的(MQ)消息队列，如kafka，rabbitmq等，但是如果没有安装MQ，我们也可以使用Redis提供的MQ方案(学完Redis我就去学微服务)</span><br><span class="line"></span><br><span class="line">### 基于List实现消息队列</span><br><span class="line"></span><br><span class="line">- 基于List结构模拟消息队列</span><br><span class="line">- 消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果</span><br><span class="line">- 队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。</span><br><span class="line">- 不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用BRPOP或者BLPOP来实现阻塞效果</span><br><span class="line">- 基于List的消息队列有哪些优缺点？</span><br><span class="line">  - 优点</span><br><span class="line">    1. 利用Redis存储，不受限于JVM内存上限</span><br><span class="line">    2. 基于Redis的持久化机制，数据安全性有保障</span><br><span class="line">    3. 可以满足消息有序性</span><br><span class="line">  - 缺点</span><br><span class="line">    1. 无法避免消息丢失(经典服务器宕机)</span><br><span class="line">    2. 只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)</span><br><span class="line"></span><br><span class="line">### 基于PubSub的消息队列</span><br><span class="line"></span><br><span class="line">- PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</span><br><span class="line">- `SUBSCRIBE channel [channel]`：订阅一个或多个频道</span><br><span class="line">- `PUBLISH channel msg`：向一个频道发送消息</span><br><span class="line">- `PSUBSCRIBE pattern [pattern]`：订阅与pattern格式匹配的所有频道</span><br><span class="line"></span><br><span class="line">Subscribes the client to the given patterns.</span><br><span class="line">Supported glob-style patterns:</span><br><span class="line"></span><br><span class="line">- h?flo subscribes to hello, hallo and hxllo</span><br><span class="line">- h*llo subscribes to hllo and heeeello</span><br><span class="line">- h[ae]llo subscribes to hello and hallo, but not hillo</span><br><span class="line"></span><br><span class="line">Use \ to escape special characters if you want to match them verbatim.</span><br><span class="line"></span><br><span class="line">- 基于PubSub的消息队列有哪些优缺点</span><br><span class="line">  - 优点：</span><br><span class="line">    1. 采用发布订阅模型，支持多生产，多消费</span><br><span class="line">  - 缺点：</span><br><span class="line">    1. 不支持数据持久化</span><br><span class="line">    2. 无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）</span><br><span class="line">    3. 消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）</span><br><span class="line"></span><br><span class="line">### 基于Stream的消息队列</span><br><span class="line"></span><br><span class="line">- Stream是Redis 5.0引入的一种新数据类型，可以时间一个功能非常完善的消息队列</span><br><span class="line">- 发送消息的命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>XADD key [NOMKSTREAM] [MAXLEN|MINID [&#x3D;!~] threshold [LIMIT count]] *|ID field value [field value …]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- NOMKSTREAM</span><br><span class="line">  - 如果队列不存在，是否自动创建队列，默认是自动创建</span><br><span class="line">- [MAXLEN|MINID [=!~] threshold [LIMIT count]]</span><br><span class="line">  - 设置消息队列的最大消息数量，不设置则无上限</span><br><span class="line">- *|ID</span><br><span class="line">  - 消息的唯一id，*代表由Redis自动生成。格式是&quot;时间戳-递增数字&quot;，例如&quot;114514114514-0&quot;</span><br><span class="line">- field value [field value …]</span><br><span class="line">  - 发送到队列中的消息，称为Entry。格式就是多个key-value键值对</span><br><span class="line"></span><br><span class="line">- 举例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH</p>
<h2 id="创建名为users的队列，并向其中发送一个消息，内容是-name-x3D-jack-age-x3D-21-，并且使用Redis自动生成ID"><a href="#创建名为users的队列，并向其中发送一个消息，内容是-name-x3D-jack-age-x3D-21-，并且使用Redis自动生成ID" class="headerlink" title="创建名为users的队列，并向其中发送一个消息，内容是{name&#x3D;jack, age&#x3D;21}，并且使用Redis自动生成ID"></a>创建名为users的队列，并向其中发送一个消息，内容是{name&#x3D;jack, age&#x3D;21}，并且使用Redis自动生成ID</h2><p>XADD users * name jack age 21</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 读取消息的方式之一：XREAD</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] ID [ID …]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- [COUNT count]</span><br><span class="line">  - 每次读取消息的最大数量</span><br><span class="line">- [BLOCK milliseconds]</span><br><span class="line">  - 当没有消息时，是否阻塞，阻塞时长</span><br><span class="line">- STREAMS key [key …]</span><br><span class="line">  - 要从哪个队列读取消息，key就是队列名</span><br><span class="line">- ID [ID …]</span><br><span class="line">  - 起始ID，只返回大于该ID的消息</span><br><span class="line">    - 0：表示从第一个消息开始</span><br><span class="line">    - $：表示从最新的消息开始</span><br><span class="line"></span><br><span class="line">- 例如：使用XREAD读取第一个消息</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>云服务器:0&gt;XREAD COUNT 1 STREAMS users 0</p>
<ol>
<li><ol>
<li>“users”</li>
<li><ol>
<li><ol>
<li>“1667119621804-0”</li>
<li><ol>
<li>“name”</li>
<li>“jack”</li>
<li>“age”</li>
<li>“21”</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 例如：XREAD阻塞方式，读取最新消息</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>XREAD COUNT 2 BLOCK 10000 STREAMS users $</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在业务开发中，我们可以使用循环调用的XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA<br>while (true){<br>    &#x2F;&#x2F;尝试读取队列中的消息，最多阻塞2秒<br>    Object msg &#x3D; redis.execute(“XREAD COUNT 1 BLOCK 2000 STREAMS users $”);<br>    &#x2F;&#x2F;没读取到，跳过下面的逻辑<br>    if(msg &#x3D;&#x3D; null){<br>        continue;<br>    }<br>    &#x2F;&#x2F;处理消息<br>    handleMessage(msg);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意：当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现`漏读消息`的问题</span><br><span class="line"></span><br><span class="line">- STREAM类型消息队列的XREAD命令特点</span><br><span class="line">  1. 消息可回溯</span><br><span class="line">  2. 一个消息可以被多个消费者读取</span><br><span class="line">  3. 可以阻塞读取</span><br><span class="line">  4. 有漏读消息的风险</span><br><span class="line"></span><br><span class="line">### 基于Stream的消息队列–消费者组</span><br><span class="line"></span><br><span class="line">- 消费者组(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点</span><br><span class="line">  1. 消息分流</span><br><span class="line">     - 队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而加快消息处理的速度</span><br><span class="line">  2. 消息标识</span><br><span class="line">     - 消费者会维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标识之后读取消息，确保每一个消息都会被消费</span><br><span class="line">  3. 消息确认</span><br><span class="line">     - 消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除</span><br><span class="line">- 创建消费者组</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>XGROUP CREATE key groupName ID [MKSTREAM]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- key</span><br><span class="line">  - 队列名称</span><br><span class="line">- groupName</span><br><span class="line">  - 消费者组名称</span><br><span class="line">- ID</span><br><span class="line">  - 起始ID标识，$代表队列中的最后一个消息，0代表队列中的第一个消息</span><br><span class="line">- MKSTREAM</span><br><span class="line">  - 队列不存在时自动创建队列</span><br><span class="line"></span><br><span class="line">- 其他常见命令</span><br><span class="line"></span><br><span class="line">  - 删除指定的消费者组</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  BASH<br>  XGROUP DESTORY key groupName<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 给指定的消费者组添加消费者</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  BASH<br>  XGROUP CREATECONSUMER key groupName consumerName<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 删除消费者组中指定的消费者</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  BASH<br>  XGROUP DELCONSUMER key groupName consumerName<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 从消费者组中读取消息</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>BASH<br>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [keys …] ID [ID …]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- group</span><br><span class="line">  - 消费者组名称</span><br><span class="line">- consumer</span><br><span class="line">  - 消费者名，如果消费者不存在，会自动创建一个消费者</span><br><span class="line">- count</span><br><span class="line">  - 本次查询的最大数量</span><br><span class="line">- BLOCK milliseconds</span><br><span class="line">  - 当前没有消息时的最大等待时间</span><br><span class="line">- NOACK</span><br><span class="line">  - 无需手动ACK，获取到消息后自动确认（一般不用，我们都是手动确认）</span><br><span class="line">- STREAMS key</span><br><span class="line">  - 指定队列名称</span><br><span class="line">- ID</span><br><span class="line">  - 获取消息的起始ID</span><br><span class="line">    - `&gt;`：从下一个未消费的消息开始(pending-list中)</span><br><span class="line">    - 其他：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</span><br><span class="line"></span><br><span class="line">- 消费者监听消息的基本思路</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>while(true){<br>    &#x2F;&#x2F; 尝试监听队列，使用阻塞模式，最大等待时长为2000ms<br>    Object msg &#x3D; redis.call(“XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;”)<br>    if(msg &#x3D;&#x3D; null){<br>        &#x2F;&#x2F; 没监听到消息，重试<br>        continue;<br>    }<br>    try{<br>        &#x2F;&#x2F;处理消息，完成后要手动确认ACK，ACK代码在handleMessage中编写<br>        handleMessage(msg);<br>    } catch(Exception e){<br>        while(true){<br>            &#x2F;&#x2F;0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息<br>            Object msg &#x3D; redis.call(“XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0”);<br>            if(msg &#x3D;&#x3D; null){<br>                &#x2F;&#x2F;null表示没有异常消息，所有消息均已确认，结束循环<br>                break;<br>            }<br>            try{<br>                &#x2F;&#x2F;说明有异常消息，再次处理<br>                handleMessage(msg);<br>            } catch(Exception e){<br>                &#x2F;&#x2F;再次出现异常，记录日志，继续循环<br>                log.error(“..”);<br>                continue;<br>            }<br>        }<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- STREAM类型消息队列的XREADGROUP命令的特点</span><br><span class="line">  1. 消息可回溯</span><br><span class="line">  2. 可以多消费者争抢消息，加快消费速度</span><br><span class="line">  3. 可以阻塞读取</span><br><span class="line">  4. 没有消息漏读风险</span><br><span class="line">  5. 有消息确认机制，保证消息至少被消费一次</span><br><span class="line"></span><br><span class="line">|              |                   List                    |       PubSub       |                         Stream                          |</span><br><span class="line">| :----------: | :---------------------------------------: | :----------------: | :-----------------------------------------------------: |</span><br><span class="line">|  消息持久化  |                   支持                    |       不支持       |                          支持                           |</span><br><span class="line">|   阻塞读取   |                   支持                    |        支持        |                          支持                           |</span><br><span class="line">| 消息堆积处理 | 受限于内存空间， 可以利用多消费者加快处理 | 受限于消费者缓冲区 | 受限于队列长度， 可以利用消费者组提高消费速度，减少堆积 |</span><br><span class="line">| 消息确认机制 |                  不支持                   |       不支持       |                          支持                           |</span><br><span class="line">|   消息回溯   |                  不支持                   |       不支持       |                          支持                           |</span><br><span class="line"></span><br><span class="line">### Stream消息队列实现异步秒杀下单</span><br><span class="line"></span><br><span class="line">- 需求：</span><br><span class="line">  1. 创建一个Stream类型的消息队列，名为stream.orders</span><br><span class="line">  2. 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</span><br><span class="line">  3. 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</span><br><span class="line">- `步骤一：`创建一个Stream类型的消息队列，名为stream.orders</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BASH<br>XGROUP CREATE stream.orders g1 0 MKSTREAM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `步骤二：`修改Lua脚本，新增orderId参数，并将订单信息加入到消息队列中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LUA</p>
<p>– 订单id<br>local voucherId &#x3D; ARGV[1]<br>– 用户id<br>local userId &#x3D; ARGV[2]<br>– 新增orderId，但是变量名用id就好，因为VoucherOrder实体类中的orderId就是用id表示的<br>local id &#x3D; ARGV[3]<br>– 优惠券key<br>local stockKey &#x3D; ‘seckill:stock:’ .. voucherId<br>– 订单key<br>local orderKey &#x3D; ‘seckill:order:’ .. voucherId<br>– 判断库存是否充足<br>if (tonumber(redis.call(‘get’, stockKey)) &lt;&#x3D; 0) then<br>    return 1<br>end<br>– 判断用户是否下单<br>if (redis.call(‘sismember’, orderKey, userId) &#x3D;&#x3D; 1) then<br>    return 2<br>end<br>– 扣减库存<br>redis.call(‘incrby’, stockKey, -1)<br>– 将userId存入当前优惠券的set集合<br>redis.call(‘sadd’, orderKey, userId)<br>– 将下单数据保存到消息队列中<br>redis.call(“sadd”, ‘stream.orders’, ‘*’, ‘userId’, userId, ‘voucherId’, voucherId, ‘id’, id)<br>return 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `步骤三：`修改秒杀逻辑</span><br><span class="line"></span><br><span class="line">- DIFF</span><br><span class="line">- 修改后代码</span><br><span class="line"></span><br><span class="line">由于将下单数据加入到消息队列的功能，我们在Lua脚本中实现了，所以这里就不需要将下单数据加入到JVM的阻塞队列中去了，同时Lua脚本中我们新增了一个参数，</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DIFF</p>
<pre><code>@Override
public Result seckillVoucher(Long voucherId) &#123;
</code></pre>
<ul>
<li><pre><code>  long orderId = redisIdWorker.nextId(&quot;order&quot;);
  Long result = stringRedisTemplate.execute(SECKILL_SCRIPT,
          Collections.emptyList(), voucherId.toString(),
</code></pre>
</li>
<li><pre><code>          UserHolder.getUser().getId().toString(), String.valueOf(orderId));
  if (result.intValue() != 0) &#123;
      return Result.fail(result.intValue() == 1 ? &quot;库存不足&quot; : &quot;不能重复下 单&quot;);
  &#125;
</code></pre>
</li>
</ul>
<ul>
<li><pre><code>  long orderId = redisIdWorker.nextId(&quot;order&quot;);
</code></pre>
</li>
<li><pre><code>  //封装到voucherOrder中
</code></pre>
</li>
<li><pre><code>  VoucherOrder voucherOrder = new VoucherOrder();
</code></pre>
</li>
<li><pre><code>  voucherOrder.setVoucherId(voucherId);
</code></pre>
</li>
<li><pre><code>  voucherOrder.setUserId(UserHolder.getUser().getId());
</code></pre>
</li>
<li><pre><code>  voucherOrder.setId(orderId);
</code></pre>
</li>
<li><pre><code>  //加入到阻塞队列
</code></pre>
</li>
<li><pre><code>  orderTasks.add(voucherOrder);
  //主线程获取代理对象
  proxy = (IVoucherOrderService) AopContext.currentProxy();
  return Result.ok(orderId);
</code></pre>
  }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 根据伪代码来修改我们的`VoucherOrderHandler`</span><br><span class="line"></span><br><span class="line">- 伪代码</span><br><span class="line">- 修改后的业务逻辑</span><br><span class="line"></span><br></pre></td></tr></table></figure>
JAVA</li>
</ul>
<p>while(true){<br>    &#x2F;&#x2F; 尝试监听队列，使用阻塞模式，最大等待时长为2000ms<br>    Object msg &#x3D; redis.call(“XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;”)<br>    if(msg &#x3D;&#x3D; null){<br>        &#x2F;&#x2F; 没监听到消息，重试<br>        continue;<br>    }<br>    try{<br>        &#x2F;&#x2F;处理消息，完成后要手动确认ACK<br>        handleMessage(msg);<br>    } catch(Exception e){<br>        while(true){<br>            &#x2F;&#x2F;0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息<br>            Object msg &#x3D; redis.call(“XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0”);<br>            if(msg &#x3D;&#x3D; null){<br>                &#x2F;&#x2F;null表示没有异常消息，所有消息均已确认，结束循环<br>                break;<br>            }<br>            try{<br>                &#x2F;&#x2F;说明有异常消息，再次处理<br>                handleMessage(msg);<br>            } catch(Exception e){<br>                &#x2F;&#x2F;再次出现异常，记录日志，继续循环<br>                log.error(“..”);<br>                continue;<br>            }<br>        }<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 达人探店</span><br><span class="line"></span><br><span class="line">### 发布探店笔记</span><br><span class="line"></span><br><span class="line">这部分代码已经提供好了，我们来看看对应的数据表</span><br><span class="line"></span><br><span class="line">- tb_blog</span><br><span class="line">- tb_blog_comments</span><br><span class="line"></span><br><span class="line">探店店笔记表，包含笔记中的标题、文字、图片等</span><br><span class="line"></span><br><span class="line">|    Field    |      Type       |     Collation      | Null | Key  |      Default      |                     Extra                     |              Comment               |</span><br><span class="line">| :---------: | :-------------: | :----------------: | :--: | :--: | :---------------: | :-------------------------------------------: | :--------------------------------: |</span><br><span class="line">|     id      | bigint unsigned |       (NULL)       |  NO  | PRI  |      (NULL)       |                auto_increment                 |                主键                |</span><br><span class="line">|   shop_id   |     bigint      |       (NULL)       |  NO  |      |      (NULL)       |                                               |               商户id               |</span><br><span class="line">|   user_id   | bigint unsigned |       (NULL)       |  NO  |      |      (NULL)       |                                               |               用户id               |</span><br><span class="line">|    title    |  varchar(255)   | utf8mb4_unicode_ci |  NO  |      |      (NULL)       |                                               |                标题                |</span><br><span class="line">|   images    |  varchar(2048)  | utf8mb4_general_ci |  NO  |      |      (NULL)       |                                               | 探店的照片，最多9张，多张以&quot;,&quot;隔开 |</span><br><span class="line">|   content   |  varchar(2048)  | utf8mb4_unicode_ci |  NO  |      |      (NULL)       |                                               |           探店的文字描述           |</span><br><span class="line">|    liked    |  int unsigned   |       (NULL)       | YES  |      |         0         |                                               |              点赞数量              |</span><br><span class="line">|  comments   |  int unsigned   |       (NULL)       | YES  |      |      (NULL)       |                                               |              评论数量              |</span><br><span class="line">| create_time |    timestamp    |       (NULL)       |  NO  |      | CURRENT_TIMESTAMP |               DEFAULT_GENERATED               |              创建时间              |</span><br><span class="line">| update_time |    timestamp    |       (NULL)       |  NO  |      | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |              更新时间              |</span><br><span class="line"></span><br><span class="line">- 对应的实体类，数据表中并没有用户头像和用户昵称，但是对应的实体类里却有，这是因为使用了`@TableField(exist = false)` 用来解决实体类中有的属性但是数据表中没有的字段</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@Data<br>@EqualsAndHashCode(callSuper &#x3D; false)<br>@Accessors(chain &#x3D; true)<br>@TableName(“tb_blog”)<br>public class Blog implements Serializable {</p>
<pre><code>private static final long serialVersionUID = 1L;

/**
 * 主键
 */
@TableId(value = &quot;id&quot;, type = IdType.AUTO)
private Long id;
/**
 * 商户id
 */
private Long shopId;
/**
 * 用户id
 */
private Long userId;
/**
 * 用户图标
 */
@TableField(exist = false)
private String icon;
/**
 * 用户姓名
 */
@TableField(exist = false)
private String name;
/**
 * 是否点赞过了
 */
@TableField(exist = false)
private Boolean isLike;

/**
 * 标题
 */
private String title;

/**
 * 探店的照片，最多9张，多张以&quot;,&quot;隔开
 */
private String images;

/**
 * 探店的文字描述
 */
private String content;

/**
 * 点赞数量
 */
private Integer liked;

/**
 * 评论数量
 */
private Integer comments;

/**
 * 创建时间
 */
private LocalDateTime createTime;

/**
 * 更新时间
 */
private LocalDateTime updateTime;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 效果图如下</span><br><span class="line">  [![img](https://pic1.imgdb.cn/item/635f8f8216f2c2beb1692e5f.jpg)](https://pic1.imgdb.cn/item/635f8f8216f2c2beb1692e5f.jpg)</span><br><span class="line">- 对应的代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA<br>@PostMapping<br>public Result saveBlog(@RequestBody Blog blog) {<br>    &#x2F;&#x2F; 获取登录用户<br>    UserDTO user &#x3D; UserHolder.getUser();<br>    blog.setUserId(user.getId());<br>    &#x2F;&#x2F; 保存探店博文<br>    blogService.save(blog);<br>    &#x2F;&#x2F; 返回id<br>    return Result.ok(blog.getId());<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 上传图片的代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@PostMapping(“blog”)<br>public Result uploadImage(@RequestParam(“file”) MultipartFile image) {<br>    try {<br>        &#x2F;&#x2F; 获取原始文件名称<br>        String originalFilename &#x3D; image.getOriginalFilename();<br>        &#x2F;&#x2F; 生成新文件名<br>        String fileName &#x3D; createNewFileName(originalFilename);<br>        &#x2F;&#x2F; 保存文件<br>        image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName));<br>        &#x2F;&#x2F; 返回结果<br>        log.debug(“文件上传成功，{}”, fileName);<br>        return Result.ok(fileName);<br>    } catch (IOException e) {<br>        throw new RuntimeException(“文件上传失败”, e);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意：这里我们需要修改`SystemConstants.IMAGE_UPLOAD_DIR` 为自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</span><br><span class="line"></span><br><span class="line">### 查看探店笔记</span><br><span class="line"></span><br><span class="line">- 需求：点击首页的探店笔记，会进入详情页面，我们现在需要实现页面的查询接口</span><br><span class="line">  [![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://pic1.imgdb.cn/item/635f908616f2c2beb16ba05d.jpg)</span><br><span class="line">- 随便点击一张图片，查看发送的请求</span><br><span class="line"></span><br><span class="line">&gt; 请求网址: http://localhost:8080/api/blog/6</span><br><span class="line">&gt; 请求方法: GET</span><br><span class="line"></span><br><span class="line">- 看样子是`BlogController`下的方法，请求方式为GET，那我们直接来编写对应的方法</span><br><span class="line"></span><br><span class="line">- Controller层</span><br><span class="line">- ServiceImpl</span><br><span class="line"></span><br><span class="line">业务逻辑我们要写在Service层，Controller层只调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA<br>@GetMapping(“&#x2F;{id}”)<br>public Result queryById(@PathVariable Integer id){<br>    return blogService.queryById(id);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 我们顺手将`queryHotBlog`也修改一下，原始代码将业务逻辑写到了Controller中，修改后的完整代码如下</span><br><span class="line"></span><br><span class="line">- BlogController</span><br><span class="line">- BlogServiceImpl</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@RestController<br>@RequestMapping(“&#x2F;blog”)<br>public class BlogController {</p>
<pre><code>@Resource
private IBlogService blogService;

@PostMapping
public Result saveBlog(@RequestBody Blog blog) &#123;
    // 获取登录用户
    UserDTO user = UserHolder.getUser();
    blog.setUserId(user.getId());
    // 保存探店博文
    blogService.save(blog);
    // 返回id
    return Result.ok(blog.getId());
&#125;

@PutMapping(&quot;/like/&#123;id&#125;&quot;)
public Result likeBlog(@PathVariable(&quot;id&quot;) Long id) &#123;
    // 修改点赞数量
    blogService.update()
            .setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update();
    return Result.ok();
&#125;

@GetMapping(&quot;/of/me&quot;)
public Result queryMyBlog(@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current) &#123;
    // 获取登录用户
    UserDTO user = UserHolder.getUser();
    // 根据用户查询
    Page&lt;Blog&gt; page = blogService.query()
            .eq(&quot;user_id&quot;, user.getId()).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));
    // 获取当前页数据
    List&lt;Blog&gt; records = page.getRecords();
    return Result.ok(records);
&#125;

@GetMapping(&quot;/hot&quot;)
public Result queryHotBlog(@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current) &#123;
    return blogService.queryHotBlog(current);
&#125;

@GetMapping(&quot;/&#123;id&#125;&quot;)
public Result queryById(@PathVariable Integer id)&#123;
    return blogService.queryById(id);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 点赞功能</span><br><span class="line"></span><br><span class="line">- 点击点赞按钮，查看发送的请求</span><br><span class="line"></span><br><span class="line">&gt; 请求网址: http://localhost:8080/api/blog/like/4</span><br><span class="line">&gt; 请求方法: PUT</span><br><span class="line"></span><br><span class="line">- 看样子是BlogController中的like方法，源码如下</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA<br>@PutMapping(“&#x2F;like&#x2F;{id}”)<br>public Result likeBlog(@PathVariable(“id”) Long id) {<br>    &#x2F;&#x2F; 修改点赞数量<br>    blogService.update().setSql(“liked &#x3D; liked + 1”).eq(“id”, id).update();<br>    return Result.ok();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</span><br><span class="line">- 造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</span><br><span class="line">- 需求</span><br><span class="line">  1. 同一个用户只能对同一篇笔记点赞一次，再次点击则取消点赞</span><br><span class="line">  2. 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</span><br><span class="line">- 实现步骤</span><br><span class="line">  1. 修改点赞功能，利用Redis中的set集合来判断是否点赞过，未点赞则点赞数`+1`，已点赞则点赞数`-1`</span><br><span class="line">  2. 修改根据id查询的业务，判断当前登录用户是否点赞过，赋值给isLike字段</span><br><span class="line">  3. 修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</span><br><span class="line">- 具体实现</span><br><span class="line"></span><br><span class="line">- Controller层</span><br><span class="line">- BlogServiceImpl</span><br><span class="line"></span><br><span class="line">业务逻辑卸载Service层</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA<br>@PutMapping(“&#x2F;like&#x2F;{id}”)<br>public Result likeBlog(@PathVariable(“id”) Long id) {<br>    return blogService.likeBlog(id);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 修改完毕之后，页面上还不能立即显示点赞完毕的后果，我们还需要修改查询Blog业务，判断Blog是否被当前用户点赞过</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@Override<br>public Result queryHotBlog(Integer current) {<br>    &#x2F;&#x2F; 根据用户查询<br>    Page<Blog> page &#x3D; query()<br>            .orderByDesc(“liked”)<br>            .page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));<br>    &#x2F;&#x2F; 获取当前页数据<br>    List<Blog> records &#x3D; page.getRecords();<br>    &#x2F;&#x2F; 查询用户<br>    records.forEach(blog -&gt; {<br>        queryBlogUser(blog);<br>        &#x2F;&#x2F;追加判断blog是否被当前用户点赞，逻辑封装到isBlogLiked方法中<br>        isBlogLiked(blog);<br>    });<br>    return Result.ok(records);<br>}</Blog></Blog></p>
<p>@Override<br>public Result queryById(Integer id) {<br>    Blog blog &#x3D; getById(id);<br>    if (blog &#x3D;&#x3D; null) {<br>        return Result.fail(“评价不存在或已被删除”);<br>    }<br>    queryBlogUser(blog);<br>    &#x2F;&#x2F;追加判断blog是否被当前用户点赞，逻辑封装到isBlogLiked方法中<br>    isBlogLiked(blog);<br>    return Result.ok(blog);<br>}</p>
<p>private void isBlogLiked(Blog blog) {<br>    &#x2F;&#x2F;1. 获取当前用户信息<br>    Long userId &#x3D; UserHolder.getUser().getId();<br>    &#x2F;&#x2F;2. 判断当前用户是否点赞<br>    String key &#x3D; BLOG_LIKED_KEY + blog.getId();<br>    Boolean isMember &#x3D; stringRedisTemplate.opsForSet().isMember(key, userId.toString());<br>    &#x2F;&#x2F;3. 如果点赞了，则将isLike设置为true<br>    blog.setIsLike(BooleanUtil.isTrue(isMember));<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 点赞排行榜</span><br><span class="line"></span><br><span class="line">- 当我们点击探店笔记详情页面时，应该按点赞顺序展示点赞用户，比如显示最早点赞的TOP5，形成点赞排行榜，就跟QQ空间发的说说一样，可以看到有哪些人点了赞</span><br><span class="line">- 之前的点赞是放到Set集合中，但是Set集合又不能排序，所以这个时候，我们就可以改用SortedSet(Zset)</span><br><span class="line">- 那我们这里顺便就来对比一下这些集合的区别</span><br><span class="line"></span><br><span class="line">|          |         List         |     Set      |    SortedSet    |</span><br><span class="line">| :------: | :------------------: | :----------: | :-------------: |</span><br><span class="line">| 排序方式 |    按添加顺序排序    |   无法排序   | 根据score值排序 |</span><br><span class="line">|  唯一性  |        不唯一        |     唯一     |      唯一       |</span><br><span class="line">| 查找方式 | 按索引查找或首尾查找 | 根据元素查找 |  根据元素查找   |</span><br><span class="line"></span><br><span class="line">- 修改BlogServiceImpl</span><br><span class="line">  由于ZSet没有isMember方法，所以这里只能通过查询score来判断集合中是否有该元素，如果有该元素，则返回值是对应的score，如果没有该元素，则返回值为null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@Override<br>public Result likeBlog(Long id) {<br>    &#x2F;&#x2F;1. 获取当前用户信息<br>    Long userId &#x3D; UserHolder.getUser().getId();<br>    &#x2F;&#x2F;2. 如果当前用户未点赞，则点赞数 +1，同时将用户加入set集合<br>    String key &#x3D; BLOG_LIKED_KEY + id;<br>    &#x2F;&#x2F;尝试获取score<br>    Double score &#x3D; stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>    &#x2F;&#x2F;为null，则表示集合中没有该用户<br>    if (score &#x3D;&#x3D; null) {<br>        &#x2F;&#x2F;点赞数 +1<br>        boolean success &#x3D; update().setSql(“liked &#x3D; liked + 1”).eq(“id”, id).update();<br>        &#x2F;&#x2F;将用户加入set集合<br>        if (success) {<br>            stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());<br>        }<br>        &#x2F;&#x2F;3. 如果当前用户已点赞，则取消点赞，将用户从set集合中移除<br>    } else {<br>        &#x2F;&#x2F;点赞数 -1<br>        boolean success &#x3D; update().setSql(“liked &#x3D; liked - 1”).eq(“id”, id).update();<br>        if (success) {<br>            &#x2F;&#x2F;从set集合移除<br>            stringRedisTemplate.opsForZSet().remove(key, userId.toString());<br>        }<br>    }<br>    return Result.ok();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 同时修改isBlogLiked方法，在原有逻辑上，判断用户是否已登录，登录状态下才会继续判断用户是否点赞</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>private void isBlogLiked(Blog blog) {<br>    &#x2F;&#x2F;1. 获取当前用户信息<br>    UserDTO userDTO &#x3D; UserHolder.getUser();<br>    &#x2F;&#x2F;当用户未登录时，就不判断了，直接return结束逻辑<br>    if (userDTO &#x3D;&#x3D; null) {<br>        return;<br>    }<br>    &#x2F;&#x2F;2. 判断当前用户是否点赞<br>    String key &#x3D; BLOG_LIKED_KEY + blog.getId();<br>    Double score &#x3D; stringRedisTemplate.opsForZSet().score(key, userDTO.getId().toString());<br>    blog.setIsLike(score !&#x3D; null);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 那我们继续来完善显示点赞列表功能，查看浏览器请求，这个请求目前应该是404的，因为我们还没有写，他需要一个list返回值，显示top5点赞的用户</span><br><span class="line"></span><br><span class="line">&gt; 请求网址: http://localhost:8080/api/blog/likes/4</span><br><span class="line">&gt; 请求方法: GET</span><br><span class="line"></span><br><span class="line">- 在Controller层中编写对应的方法，点赞查询列表，具体逻辑写到BlogServiceImpl中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA<br>@GetMapping(“&#x2F;likes&#x2F;{id}”)<br>public Result queryBlogLikes(@PathVariable Integer id){<br>    return blogService.queryBlogLikes(id);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 具体逻辑如下</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@Override<br>public Result queryBlogLikes(Integer id) {<br>    String key &#x3D; BLOG_LIKED_KEY + id;<br>    &#x2F;&#x2F;zrange key 0 4  查询zset中前5个元素<br>    Set<String> top5 &#x3D; stringRedisTemplate.opsForZSet().range(key, 0, 4);<br>    &#x2F;&#x2F;如果是空的(可能没人点赞)，直接返回一个空集合<br>    if (top5 &#x3D;&#x3D; null || top5.isEmpty()) {<br>        return Result.ok(Collections.emptyList());<br>    }<br>    List<Long> ids &#x3D; top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    &#x2F;&#x2F;将ids使用<code>,</code>拼接，SQL语句查询出来的结果并不是按照我们期望的方式进行排<br>    &#x2F;&#x2F;所以我们需要用order by field来指定排序方式，期望的排序方式就是按照查询出来的id进行排序<br>    String idsStr &#x3D; StrUtil.join(“,”, ids);<br>    &#x2F;&#x2F;select * from tb_user where id in (ids[0], ids[1] …) order by field(id, ids[0], ids[1] …)<br>    List<UserDTO> userDTOS &#x3D; userService.query().in(“id”, ids)<br>            .last(“order by field(id,” + idsStr + “)”)<br>            .list().stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    return Result.ok(userDTOS);<br>}</UserDTO></Long></String></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 重启服务器，查看效果</span><br><span class="line">  [![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://pic1.imgdb.cn/item/636328b216f2c2beb10e3c08.jpg)</span><br><span class="line"></span><br><span class="line">## 好友关注</span><br><span class="line"></span><br><span class="line">### 关注和取消关注</span><br><span class="line"></span><br><span class="line">- 当我们进入到笔记详情页面时，会发送一个请求，判断当前登录用户是否关注了笔记博主</span><br><span class="line"></span><br><span class="line">&gt; 请求网址: http://localhost:8080/api/follow/or/not/2</span><br><span class="line">&gt; 请求方法: GET</span><br><span class="line"></span><br><span class="line">- 当我们点击关注按钮时，会发送一个请求，实现关注/取关</span><br><span class="line"></span><br><span class="line">&gt; 请求网址: http://localhost:8080/api/follow/2/true</span><br><span class="line">&gt; 请求方法: PUT</span><br><span class="line"></span><br><span class="line">- 关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示</span><br><span class="line"></span><br><span class="line">|     Field      |      Type       | Collation | Null | Key  |      Default      |       Extra       |   Comment    |</span><br><span class="line">| :------------: | :-------------: | :-------: | :--: | :--: | :---------------: | :---------------: | :----------: |</span><br><span class="line">|       id       |     bigint      |  (NULL)   |  NO  | PRI  |      (NULL)       |  auto_increment   |     主键     |</span><br><span class="line">|    user_id     | bigint unsigned |  (NULL)   |  NO  |      |      (NULL)       |                   |    用户id    |</span><br><span class="line">| follow_user_id | bigint unsigned |  (NULL)   |  NO  |      |      (NULL)       |                   | 关联的用户id |</span><br><span class="line">|  create_time   |    timestamp    |  (NULL)   |  NO  |      | CURRENT_TIMESTAMP | DEFAULT_GENERATED |   创建时间   |</span><br><span class="line"></span><br><span class="line">- 对应的实体类如下</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@Data<br>@EqualsAndHashCode(callSuper &#x3D; false)<br>@Accessors(chain &#x3D; true)<br>@TableName(“tb_follow”)<br>public class Follow implements Serializable {</p>
<pre><code>private static final long serialVersionUID = 1L;

/**
 * 主键
 */
@TableId(value = &quot;id&quot;, type = IdType.AUTO)
private Long id;

/**
 * 用户id
 */
private Long userId;

/**
 * 关联的用户id
 */
private Long followUserId;

/**
 * 创建时间
 */
private LocalDateTime createTime;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 那我们现在来Controller层中编写对应的两个方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@RestController<br>@RequestMapping(“&#x2F;follow”)<br>public class FollowController {<br>    @Resource<br>    private IFollowService followService;<br>    &#x2F;&#x2F;判断当前用户是否关注了该博主<br>    @GetMapping(“&#x2F;or&#x2F;not&#x2F;{id}”)<br>    public Result isFollow(@PathVariable(“id”) Long followUserId) {<br>        return followService.isFollow(followUserId);<br>    }<br>    &#x2F;&#x2F;实现取关&#x2F;关注<br>    @PutMapping(“&#x2F;{id}&#x2F;{isFollow}”)<br>    public Result follow(@PathVariable(“id”) Long followUserId, @PathVariable(“isFollow”) Boolean isFellow) {<br>        return followService.follow(followUserId,isFellow);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 具体的业务逻辑我们还是放在FellowServiceImpl中来编写</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@Service<br>public class FollowServiceImpl extends ServiceImpl&lt;FollowMapper, Follow&gt; implements IFollowService {</p>
<pre><code>@Override
public Result isFollow(Long followUserId) &#123;
    //获取当前登录的userId
    Long userId = UserHolder.getUser().getId();
    LambdaQueryWrapper&lt;Follow&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
    //查询当前用户是否关注了该笔记的博主
    queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);
    //只查询一个count就行了
    int count = this.count(queryWrapper);
    return Result.ok(count &gt; 0);
&#125;

@Override
public Result follow(Long followUserId, Boolean isFellow) &#123;
    //获取当前用户id
    Long userId = UserHolder.getUser().getId();
    //判断是否关注
    if (isFellow) &#123;
        //关注，则将信息保存到数据库
        Follow follow = new Follow();
        follow.setUserId(userId);
        follow.setFollowUserId(followUserId);
        save(follow);
    &#125; else &#123;
        //取关，则将数据从数据库中移除
        LambdaQueryWrapper&lt;Follow&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);
        remove(queryWrapper);
    &#125;
    return Result.ok();
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 测试效果如下</span><br><span class="line">  [![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://pic1.imgdb.cn/item/63633ca816f2c2beb12b772e.jpg)</span><br><span class="line"></span><br><span class="line">### 共同关注</span><br><span class="line"></span><br><span class="line">- 点击用户头像，进入到用户详情页，可以查看用户发布的笔记，和共同关注列表</span><br><span class="line">  [![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://pic1.imgdb.cn/item/63635de616f2c2beb15b17cb.jpg)</span><br><span class="line"></span><br><span class="line">- 但现在我们还没写具体的业务逻辑，所以现在暂时看不到数据</span><br><span class="line"></span><br><span class="line">- 检测NetWork选项卡，查看发送的请求</span><br><span class="line"></span><br><span class="line">  - 查询用户信息</span><br><span class="line"></span><br><span class="line">  &gt; 请求网址: http://localhost:8080/api/user/2</span><br><span class="line">  &gt; 请求方法: GET</span><br><span class="line"></span><br><span class="line">  - 查看共同关注</span><br><span class="line"></span><br><span class="line">  &gt; 请求网址: http://localhost:8080/api/follow/common/undefined</span><br><span class="line">  &gt; 请求方法: GET</span><br><span class="line"></span><br><span class="line">- 编写`查询用户信息`方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@GetMapping(“&#x2F;{id}”)<br>public Result queryById(@PathVariable(“id”) Long userId) {<br>    &#x2F;&#x2F; 查询详情<br>    User user &#x3D; userService.getById(userId);<br>    if (user &#x3D;&#x3D; null) {<br>        &#x2F;&#x2F; 没有详情，应该是第一次查看详情<br>        return Result.ok();<br>    }<br>    UserDTO userDTO &#x3D; BeanUtil.copyProperties(user, UserDTO.class);<br>    &#x2F;&#x2F; 返回<br>    return Result.ok(userDTO);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 重启服务器，现在可以看到用户信息，但是不能看到用户发布的笔记信息，查看NetWork检测的请求，我们还需要完成这个需求</span><br><span class="line"></span><br><span class="line">&gt; 请求网址: http://localhost:8080/api/blog/of/user?&amp;id=2&amp;current=1</span><br><span class="line">&gt; 请求方法: GET</span><br><span class="line"></span><br><span class="line">- 编写`查询用户笔记`方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<pre><code>@GetMapping(&quot;/of/user&quot;)
public Result queryBlogByUserId(@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current, @RequestParam(&quot;id&quot;) Long id) &#123;
    LambdaQueryWrapper&lt;Blog&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
    queryWrapper.eq(Blog::getUserId, id);
    Page&lt;Blog&gt; pageInfo = new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE);
    blogService.page(pageInfo, queryWrapper);
    List&lt;Blog&gt; records = pageInfo.getRecords();
    return Result.ok(records);
&#125;
</code></pre>
<p>&#x2F;&#x2F;下面这是老师的代码，个人感觉我的可读性更高[doge]<br>&#x2F;&#x2F; BlogController  根据id查询博主的探店笔记<br>@GetMapping(“&#x2F;of&#x2F;user”)<br>public Result queryBlogByUserId(<br>        @RequestParam(value &#x3D; “current”, defaultValue &#x3D; “1”) Integer current,<br>        @RequestParam(“id”) Long id) {<br>    &#x2F;&#x2F; 根据用户查询<br>    Page<Blog> page &#x3D; blogService.query()<br>            .eq(“user_id”, id).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));<br>    &#x2F;&#x2F; 获取当前页数据<br>    List<Blog> records &#x3D; page.getRecords();<br>    return Result.ok(records);<br>}</Blog></Blog></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 效果如下</span><br><span class="line">  [![img](https://pic1.imgdb.cn/item/6363632816f2c2beb162b6de.jpg)](https://pic1.imgdb.cn/item/6363632816f2c2beb162b6de.jpg)</span><br><span class="line">- 接下来我们来看看怎么实现共同关注</span><br><span class="line"></span><br><span class="line">需求：利用Redis中恰当的数据结构，实现共同关注功能，在博主个人页面展示出当前用户与博主的共同关注</span><br><span class="line"></span><br><span class="line">- 实现方式当然是我们之前学过的set集合，在set集合中，有交集并集补集的api，可以把二者关注的人放入到set集合中，然后通过api查询两个set集合的交集</span><br><span class="line">- 那我们就得先修改我们之前的关注逻辑，在关注博主的同时，需要将数据放到set集合中，方便后期我们实现共同关注，当取消关注时，也需要将数据从set集合中删除</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA</p>
<p>@Resource<br>private StringRedisTemplate stringRedisTemplate;</p>
<p>@Override<br>public Result follow(Long followUserId, Boolean isFellow) {<br>    &#x2F;&#x2F;获取当前用户id<br>    Long userId &#x3D; UserHolder.getUser().getId();<br>    String key &#x3D; “follows:” + userId;<br>    &#x2F;&#x2F;判断是否关注<br>    if (isFellow) {<br>        &#x2F;&#x2F;关注，则将信息保存到数据库<br>        Follow follow &#x3D; new Follow();<br>        follow.setUserId(userId);<br>        follow.setFollowUserId(followUserId);<br>        &#x2F;&#x2F;如果保存成功<br>        boolean success &#x3D; save(follow);<br>        &#x2F;&#x2F;则将数据也写入Redis<br>        if (success) {<br>            stringRedisTemplate.opsForSet().add(key, followUserId.toString());<br>        }<br>    } else {<br>        &#x2F;&#x2F;取关，则将数据从数据库中移除<br>        LambdaQueryWrapper<Follow> queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();<br>        queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);<br>        &#x2F;&#x2F;如果取关成功<br>        boolean success &#x3D; remove(queryWrapper);<br>        &#x2F;&#x2F;则将数据也从Redis中移除<br>        if (success){<br>            stringRedisTemplate.opsForSet().remove(key,followUserId.toString());<br>        }<br>    }<br>    return Result.ok();<br>}</Follow></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 那么接下来，我们实现共同关注代码</span><br><span class="line"></span><br><span class="line">- Controller层</span><br><span class="line">- Impl</span><br><span class="line"></span><br><span class="line">业务逻辑写在Impl中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JAVA<br>@GetMapping(“&#x2F;common&#x2F;{id}”)<br>public Result followCommons(@PathVariable Long id){<br>    return followService.followCommons(id);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 最终效果如下</span><br><span class="line">  [![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://pic1.imgdb.cn/item/6363737716f2c2beb17fae7b.jpg)</span><br><span class="line"></span><br><span class="line">### Feed流实现方案</span><br><span class="line"></span><br><span class="line">- 当我们关注了用户之后，这个用户发布了动态，那我们应该把这些数据推送给用户，这个需求，我们又称其为Feed流，关注推送也叫作Feed流，直译为投喂，为用户提供沉浸式体验，通过无限下拉刷新获取新的信息，</span><br><span class="line"></span><br><span class="line">- 对于传统的模式内容检索：用户需要主动通过搜索引擎或者是其他方式去查找想看的内容</span><br><span class="line"></span><br><span class="line">- 对于新型Feed流的效果：系统分析用户到底想看什么，然后直接把内容推送给用户，从而使用户能更加节约时间，不用去主动搜素</span><br><span class="line"></span><br><span class="line">- Feed流的实现有两种模式</span><br><span class="line"></span><br><span class="line">  1. Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注(B站关注的up，朋友圈等)</span><br><span class="line">     - 优点：信息全面，不会有缺失，并且实现也相对简单</span><br><span class="line">     - 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</span><br><span class="line">  2. 智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣的信息来吸引用户</span><br><span class="line">     - 优点：投喂用户感兴趣的信息，用户粘度很高，容易沉迷</span><br><span class="line">     - 缺点：如果算法不精准，可能会起到反作用（给你推的你都不爱看）</span><br><span class="line"></span><br><span class="line">- 那我们这里针对好友的操作，采用的是Timeline方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</span><br><span class="line"></span><br><span class="line">- 采用Timeline模式，有三种具体的实现方案</span><br><span class="line"></span><br><span class="line">  1. 拉模式</span><br><span class="line">  2. 推模式</span><br><span class="line">  3. 推拉结合</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  拉模式</span><br></pre></td></tr></table></figure>

<p>  ：也叫读扩散</p>
<ul>
<li><p>该模式的核心含义是：当张三和李四、王五发了消息之后，都会保存到自己的发件箱中，如果赵六要读取消息，那么他会读取他自己的收件箱，此时系统会从他关注的人群中，将他关注人的信息全都进行拉取，然后进行排序</p>
</li>
<li><p>优点：比较节约空间，因为赵六在读取信息时，并没有重复读取，并且读取完之后，可以将他的收件箱清除</p>
</li>
<li><p>缺点：有延迟，当用户读取数据时，才会去关注的人的时发件箱中拉取信息，假设该用户关注了海量用户，那么此时就会拉取很多信息，对服务器压力巨大<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6363826516f2c2beb1992291.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="img"></a></p>
</li>
<li><pre><code>推模式
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：也叫写扩散</span><br><span class="line"></span><br><span class="line">  - 推模式是没有写邮箱的，当张三写了一个内容，此时会主动把张三写的内容发送到它粉丝的收件箱中，假设此时李四再来读取，就不用再去临时拉取了</span><br><span class="line">  - 优点：时效快，不用临时拉取</span><br><span class="line">  - 缺点：内存压力大，假设一个大V发了一个动态，很多人关注他，那么就会写很多份数据到粉丝那边去</span><br><span class="line">    [![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://pic1.imgdb.cn/item/636383e816f2c2beb1a0ab75.jpg)</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  推拉结合</span><br></pre></td></tr></table></figure>

：页脚读写混合，兼具推和拉两种模式的优点

- 推拉模式是一个折中的方案，站在发件人这一边，如果是普通人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝收件箱中，因为普通人的粉丝数量较少，所以这样不会产生太大压力。但如果是大V，那么他是直接将数据写入一份到发件箱中去，在直接写一份到活跃粉丝的收件箱中，站在收件人这边来看，如果是活跃粉丝，那么大V和普通人发的都会写到自己的收件箱里，但如果是普通粉丝，由于上线不是很频繁，所以等他们上线的时候，再从发件箱中去拉取信息。
  [![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://pic1.imgdb.cn/item/6363841b16f2c2beb1a1e1e3.jpg)
</code></pre>
</li>
</ul>
<h3 id="推送到粉丝收件箱"><a href="#推送到粉丝收件箱" class="headerlink" title="推送到粉丝收件箱"></a>推送到粉丝收件箱</h3><ul>
<li>需求：<ol>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li>
<li>收件箱满足可以根据时间戳排序，必须使用Redis的数据结构实现</li>
<li>查询收件箱数据时，课实现分页查询</li>
</ol>
</li>
<li>Feed流中的数据会不断更新，所以数据的角标也会不断变化，所以我们不能使用传统的分页模式</li>
<li>假设在t1时刻，我们取读取第一页，此时page &#x3D; 1，size &#x3D; 5，那么我们拿到的就是<code>10~6</code>这几条记录，假设t2时刻有发布了一条新纪录，那么在t3时刻，我们来读取第二页，此时page &#x3D; 2，size &#x3D; 5，那么此时读取的数据是从6开始的，读到的是<code>6~2</code>，那么我们就读到了重复的数据，所以我们要使用Feed流的分页，不能使用传统的分页<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/63638cce16f2c2beb1b72c2f.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="img"></a></li>
<li>Feed流的滚动分页<ul>
<li>我们需要记录每次操作的最后一条，然后从这个位置去开始读数据</li>
<li>举个例子：我们从t1时刻开始，拿到第一页数据，拿到了<code>10~6</code>，然后记录下当前最后一次读取的记录，就是6，t2时刻发布了新纪录，此时这个11在最上面，但不会影响我们之前拿到的6，此时t3时刻来读取第二页，第二页读数据的时候，从<code>6-1=5</code>开始读，这样就拿到了<code>5~1</code>的记录。我们在这个地方可以使用SortedSet来做，使用时间戳来充当表中的<code>1~10</code><br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/63638cdb16f2c2beb1b743f5.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="img"></a></li>
</ul>
</li>
<li>核心思路：我们保存完探店笔记后，获取当前用户的粉丝列表，然后将数据推送给粉丝</li>
<li>那现在我们就需要修改保存笔记的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result saveBlog(Blog blog) &#123;</span><br><span class="line">    // 获取登录用户</span><br><span class="line">    UserDTO user = UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    // 保存探店博文</span><br><span class="line">    save(blog);</span><br><span class="line">    // 条件构造器</span><br><span class="line">    LambdaQueryWrapper&lt;Follow&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    // 从follow表最中，查找当前用户的粉丝  select * from follow where follow_user_id = user_id</span><br><span class="line">    queryWrapper.eq(Follow::getFollowUserId, user.getId());</span><br><span class="line">    //获取当前用户的粉丝</span><br><span class="line">    List&lt;Follow&gt; follows = followService.list(queryWrapper);</span><br><span class="line">    for (Follow follow : follows) &#123;</span><br><span class="line">        Long userId = follow.getUserId();</span><br><span class="line">        String key = FEED_KEY + userId;</span><br><span class="line">        //推送数据</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回id</span><br><span class="line">    return Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现分页查询收件箱"><a href="#实现分页查询收件箱" class="headerlink" title="实现分页查询收件箱"></a>实现分页查询收件箱</h3><ul>
<li>需求：在个人主页的<code>关注栏</code>中，查询并展示推送的Blog信息</li>
<li>具体步骤如下<ol>
<li>每次查询完成之后，我们要分析出查询出的最小时间戳，这个值会作为下一次的查询条件</li>
<li>我们需要找到与上一次查询相同的查询个数，并作为偏移量，下次查询的时候，跳过这些查询过的数据，拿到我们需要的数据（例如时间戳8 6 6 5 5 4，我们每次查询3个，第一次是8 6 6，此时最小时间戳是6，如果不设置偏移量，会从第一个6之后开始查询，那么查询到的就是6 5 5，而不是5 5 4，如果这里说的不清楚，那就看后续的代码）</li>
</ol>
</li>
<li>综上：我们的请求参数中需要携带lastId和offset，即上一次查询时的最小时间戳和偏移量，这两个参数</li>
<li>编写一个通用的实体类，不一定只对blog进行分页查询，这里用泛型做一个通用的分页查询，list是封装返回的结果，minTime是记录的最小时间戳，offset是记录偏移量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Data</span><br><span class="line">public class ScrollResult &#123;</span><br><span class="line">    private List&lt;?&gt; list;</span><br><span class="line">    private Long minTime;</span><br><span class="line">    private Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>点击个人主页中的<code>关注</code>栏，查看发送的请求</li>
</ul>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/blog/of/follow?&lastId=1667472294526">http://localhost:8080/api/blog/of/follow?&amp;lastId=1667472294526</a><br>请求方法: GET</p>
</blockquote>
<ul>
<li><p>在BlogController中创建对应的方法，具体实现去ServiceImpl中完成</p>
</li>
<li><p>tabName</p>
</li>
<li><p>Impl具体实现</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@GetMapping(&quot;/of/follow&quot;)</span><br><span class="line">public Result queryBlogOfFollow(@RequestParam(&quot;lastId&quot;) Long max, @RequestParam(value = &quot;offset&quot;,defaultValue = &quot;0&quot;) Integer offset) &#123;</span><br><span class="line">    return blogService.queryBlogOfFollow(max,offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>最终效果如下，在最上方显示的都是我们最新发布的动态<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6363a7da16f2c2beb1e17702.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="img"></a></li>
</ul>
<h2 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h2><h3 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h3><ul>
<li><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据，常见的命令有</p>
<ul>
<li><p>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</p>
</li>
<li><p>命令格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member …]</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：添加到sorted set元素的数目，但不包括已更新score的元素</li>
<li>复杂度：每⼀个元素添加是O(log(N)) ，N是sorted set的元素数量</li>
<li>举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">GEOADD china 13.361389 38.115556 &quot;shanghai&quot; 15.087269 37.502669 &quot;beijing&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GEODIST：计算指定的两个点之间的距离并返回</p>
</li>
<li><p>命令格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br></pre></td></tr></table></figure>

<ul>
<li>如果两个位置之间的其中⼀个不存在， 那么命令返回空值。</li>
<li>指定单位的参数 unit 必须是以下单位的其中⼀个：<ul>
<li>m 表示单位为米。</li>
<li>km 表示单位为千米。</li>
<li>mi 表示单位为英⾥。</li>
<li>ft 表示单位为英尺。</li>
</ul>
</li>
<li>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。</li>
<li>GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这⼀假设最⼤会造成 0.5% 的误差</li>
<li>返回值：计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值</li>
<li>举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">GEODIST china beijing shanghai km</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GEOHASH：将指定member的坐标转化为hash字符串形式并返回</p>
</li>
<li><p>命令格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">GEOHASH key member [member …]</span><br></pre></td></tr></table></figure>

<ul>
<li>通常使用表示位置的元素使用不同的技术，使用Geohash位置52点整数编码。由于编码和解码过程中所使用的初始最小和最大坐标不同，编码的编码也不同于标准。此命令返回一个标准的Geohash，在维基百科和geohash.org网站都有相关描述</li>
<li>返回值：一个数组， 数组的每个项都是一个 geohash 。 命令返回的 geohash 的位置与用户给定的位置元素的位置一一对应</li>
<li>复杂度：O(log(N)) for each member requested, where N is the number of elements in the sorted set</li>
<li>举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">云服务器:0&gt;GEOHASH china beijing shanghai</span><br><span class="line">1) &quot;sqdtr74hyu0&quot;</span><br><span class="line">2) &quot;sqc8b49rny0&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GEOPOS：返回指定member的坐标</p>
</li>
<li><p>格式：GEOPOS key member [member …]</p>
</li>
<li><p>给定一个sorted set表示的空间索引，密集使用 geoadd 命令，它以获得指定成员的坐标往往是有益的。当空间索引填充通过 geoadd 的坐标转换成一个52位Geohash，所以返回的坐标可能不完全以添加元素的，但小的错误可能会出台。</p>
</li>
<li><p>因为 GEOPOS 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复</p>
</li>
<li><p>返回值：GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。当给定的位置元素不存在时， 对应的数组项为空值</p>
</li>
<li><p>复杂度：O(log(N)) for each member requested, where N is the number of elements in the sorted set</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">云服务器:0&gt;geopos china beijing shanghai</span><br><span class="line">1)  1) &quot;15.08726745843887329&quot;</span><br><span class="line">    2) &quot;37.50266842333162032&quot;</span><br><span class="line"></span><br><span class="line">2)  1) &quot;13.36138933897018433&quot;</span><br><span class="line">    2) &quot;38.11555639549629859&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GEOGADIUS：指定圆心、半径，找到该园内包含的所有member，并按照与圆心之间的距离排序后返回，<code>6.2之后已废弃</code></p>
</li>
<li><p>命令格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] </span><br><span class="line">[COUNT count [ANY]] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure>

<ul>
<li>范围可以使用以下其中一个单位：<ul>
<li>m 表示单位为米。</li>
<li>km 表示单位为千米。</li>
<li>mi 表示单位为英里。</li>
<li>ft 表示单位为英尺。</li>
</ul>
</li>
<li>在给定以下可选项时， 命令会返回额外的信息：<ul>
<li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li>
<li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li>
<li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li>
</ul>
</li>
<li>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：<ul>
<li>ASC: 根据中心的位置， 按照从近到远的方式返回位置元素。</li>
<li>DESC: 根据中心的位置， 按照从远到近的方式返回位置元素。</li>
</ul>
</li>
<li>在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的</li>
<li>返回值：<ul>
<li>在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的线性（linear）列表。</li>
<li>在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素。</li>
<li>在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回：<ul>
<li>以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。</li>
<li>geohash 整数。</li>
<li>由两个元素组成的坐标，分别为经度和纬度</li>
</ul>
</li>
</ul>
</li>
<li>举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">云服务器:0&gt;GEORADIUS china 15 37 200 km WITHDIST WITHCOORD</span><br><span class="line">1)  1) &quot;shanghai&quot;</span><br><span class="line">    2) &quot;190.4424&quot;</span><br><span class="line">    3)  1) &quot;13.36138933897018433&quot;</span><br><span class="line">        2) &quot;38.11555639549629859&quot;</span><br><span class="line"></span><br><span class="line">2)  1) &quot;beijing&quot;</span><br><span class="line">    2) &quot;56.4413&quot;</span><br><span class="line">    3)  1) &quot;15.08726745843887329&quot;</span><br><span class="line">        2) &quot;37.50266842333162032&quot;</span><br><span class="line"></span><br><span class="line">云服务器:0&gt;GEORADIUS china 15 37 200 km WITHDIST</span><br><span class="line">1)  1) &quot;shanghai&quot;</span><br><span class="line">    2) &quot;190.4424&quot;</span><br><span class="line"></span><br><span class="line">2)  1) &quot;beijing&quot;</span><br><span class="line">    2) &quot;56.4413&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>GEOSEARCH：在指定范围内搜索member，并按照与制定点之间的距离排序后返回，范围可以使圆形或矩形，6.2的新功能</li>
</ul>
<p>命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">GEOSEARCH key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] </span><br><span class="line">[BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</span><br></pre></td></tr></table></figure>

<ul>
<li>举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line"></span><br><span class="line">云服务器:0&gt;geosearch china FROMLONLAT 15 37 BYRADIUS 200 km ASC WITHCOORD WITHDIST</span><br><span class="line">1)  1) &quot;beijing&quot;</span><br><span class="line">    2) &quot;56.4413&quot;</span><br><span class="line">    3)  1) &quot;15.08726745843887329&quot;</span><br><span class="line">        2) &quot;37.50266842333162032&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2)  1) &quot;shanghai&quot;</span><br><span class="line">    2) &quot;190.4424&quot;</span><br><span class="line">    3)  1) &quot;13.36138933897018433&quot;</span><br><span class="line">        2) &quot;38.11555639549629859&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">云服务器:0&gt;geosearch china FROMLONLAT 15 37 BYBOX 400 400 km DESC WITHCOORD WITHDIST</span><br><span class="line">1)  1) &quot;shanghai&quot;</span><br><span class="line">    2) &quot;190.4424&quot;</span><br><span class="line">    3)  1) &quot;13.36138933897018433&quot;</span><br><span class="line">        2) &quot;38.11555639549629859&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2)  1) &quot;beijing&quot;</span><br><span class="line">    2) &quot;56.4413&quot;</span><br><span class="line">    3)  S1) &quot;15.08726745843887329&quot;</span><br><span class="line">        2) &quot;37.50266842333162032&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key，也是6.2的新功能</p>
</li>
<li><p>命令格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">GEOSEARCHSTORE destination source [FROMMEMBER member] [FROMLONLAT longitude latitude] </span><br><span class="line">[BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] </span><br><span class="line">[ASC|DESC] [COUNT count [ANY]] [STOREDIST]</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点</li>
<li>指定成员的位置被用作查询的中心。</li>
<li>关于 GEORADIUSBYMEMBER 命令的更多信息， 请参考 GEORADIUS 命令的文档</li>
<li>复杂度：O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">云服务器:0&gt;GEORADIUSBYMEMBER china beijing 200 km</span><br><span class="line">1) &quot;shanghai&quot;</span><br><span class="line">2) &quot;beijing&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="导入店铺数据到GEO"><a href="#导入店铺数据到GEO" class="headerlink" title="导入店铺数据到GEO"></a>导入店铺数据到GEO</h3><ul>
<li>具体场景说明，例如美团&#x2F;饿了么这种外卖App，你是可以看到商家离你有多远的，那我们现在也要实现这个功能。</li>
<li>我们可以使用GEO来实现该功能，以当前坐标为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件插入后台，后台查询出对应的数据再返回</li>
<li>那现在我们要做的就是：将数据库中的数据导入到Redis中去，GEO在Redis中就是一个member和一个经纬度，经纬度对应的就是tb_shop中的x和y，而member，我们用shop_id来存，因为Redis只是一个内存级数据库，如果存海量的数据，还是力不从心，所以我们只存一个id，用的时候再拿id去SQL数据库中查询shop信息</li>
<li>但是此时还有一个问题，我们在redis中没有存储shop_type，无法根据店铺类型来对数据进行筛选，解决办法就是将type_id作为key，存入同一个GEO集合即可</li>
</ul>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
<th>Score</th>
</tr>
</thead>
<tbody><tr>
<td>shop:geo:美食</td>
<td>海底捞</td>
<td>40691512240174598</td>
</tr>
<tr>
<td>吉野家</td>
<td>40691519846517915</td>
<td></td>
</tr>
<tr>
<td>shop:geo:KTV</td>
<td>KTV 01</td>
<td>40691165486458787</td>
</tr>
<tr>
<td>KTV 02</td>
<td>40691514154651657</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void loadShopData()&#123;</span><br><span class="line">    //1. 查询所有店铺信息</span><br><span class="line">    List&lt;Shop&gt; shopList = shopService.list();</span><br><span class="line">    //2. 按照typeId，将店铺进行分组</span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    //3. 逐个写入Redis</span><br><span class="line">    for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        //3.1 获取类型id</span><br><span class="line">        Long typeId = entry.getKey();</span><br><span class="line">        //3.2 获取同类型店铺的集合</span><br><span class="line">        List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line">        String key = SHOP_GEO_KEY + typeId;</span><br><span class="line">        for (Shop shop : shops) &#123;</span><br><span class="line">            //3.3 写入redis GEOADD key 经度 纬度 member</span><br><span class="line">            stringRedisTemplate.opsForGeo().add(key,new Point(shop.getX(),shop.getY()),shop.getId().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是上面的代码不够优雅，是一条一条写入的，效率较低，那我们现在来改进一下，这样只需要写入等同于type_id数量的次数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void loadShopData() &#123;</span><br><span class="line">    List&lt;Shop&gt; shopList = shopService.list();</span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        Long typeId = entry.getKey();</span><br><span class="line">        List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line">        String key = SHOP_GEO_KEY + typeId;</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(shops.size());</span><br><span class="line">        for (Shop shop : shops) &#123;</span><br><span class="line">            //将当前type的商铺都添加到locations集合中</span><br><span class="line">            locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;(shop.getId().toString(), new Point(shop.getX(), shop.getY())));</span><br><span class="line">        &#125;</span><br><span class="line">        //批量写入</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码编写完毕，我们启动测试方法，然后去Redis图形化界面中查看是否有对应的数据</li>
</ul>
<h3 id="实现附近商户功能"><a href="#实现附近商户功能" class="headerlink" title="实现附近商户功能"></a>实现附近商户功能</h3><ul>
<li>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的pom.xml文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>点击距离分类，查看发送的请求</li>
</ul>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/shop/of/type?&typeId=1&current=1&x=120.149993&y=30.334229">http://localhost:8080/api/shop/of/type?&amp;typeId=1&amp;current=1&amp;x=120.149993&amp;y=30.334229</a><br>请求方法: GET</p>
</blockquote>
<ul>
<li>看样子是ShopController中的方法，那我们现在来修改其代码，除了typeId，分页码，我们还需要其坐标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@GetMapping(&quot;/of/type&quot;)</span><br><span class="line">public Result queryShopByType(</span><br><span class="line">        @RequestParam(&quot;typeId&quot;) Integer typeId,</span><br><span class="line">        @RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current,</span><br><span class="line">        @RequestParam(value = &quot;x&quot;, required = false) Double x,</span><br><span class="line">        @RequestParam(value = &quot;y&quot;, required = false) Double y</span><br><span class="line">) &#123;</span><br><span class="line">   return shopService.queryShopByType(typeId,current,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体业务逻辑依旧是写在ShopServiceImpl中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) &#123;</span><br><span class="line">    //1. 判断是否需要根据距离查询</span><br><span class="line">    if (x == null || y == null) &#123;</span><br><span class="line">        // 根据类型分页查询</span><br><span class="line">        Page&lt;Shop&gt; page = query()</span><br><span class="line">                .eq(&quot;type_id&quot;, typeId)</span><br><span class="line">                .page(new Page&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">        // 返回数据</span><br><span class="line">        return Result.ok(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line">    //2. 计算分页查询参数</span><br><span class="line">    int from = (current - 1) * SystemConstants.MAX_PAGE_SIZE;</span><br><span class="line">    int end = current * SystemConstants.MAX_PAGE_SIZE;</span><br><span class="line">    String key = SHOP_GEO_KEY + typeId;</span><br><span class="line">    //3. 查询redis、按照距离排序、分页; 结果：shopId、distance</span><br><span class="line">    //GEOSEARCH key FROMLONLAT x y BYRADIUS 5000 m WITHDIST</span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo().search(key,</span><br><span class="line">            GeoReference.fromCoordinate(x, y),</span><br><span class="line">            new Distance(5000),</span><br><span class="line">            RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));</span><br><span class="line">    if (results == null) &#123;</span><br><span class="line">        return Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    //4. 解析出id</span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">    if (list.size() &lt; from) &#123;</span><br><span class="line">        //起始查询位置大于数据总量，则说明没数据了，返回空集合</span><br><span class="line">        return Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Long&gt; ids = new ArrayList&lt;&gt;(list.size());</span><br><span class="line">    HashMap&lt;String, Distance&gt; distanceMap = new HashMap&lt;&gt;(list.size());</span><br><span class="line">    list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">        String shopIdStr = result.getContent().getName();</span><br><span class="line">        ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">        Distance distance = result.getDistance();</span><br><span class="line">        distanceMap.put(shopIdStr, distance);</span><br><span class="line">    &#125;);</span><br><span class="line">    //5. 根据id查询shop</span><br><span class="line">    String idsStr = StrUtil.join(&quot;,&quot;, ids);</span><br><span class="line">    List&lt;Shop&gt; shops = query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD( id,&quot; + idsStr + &quot;)&quot;).list();</span><br><span class="line">    for (Shop shop : shops) &#123;</span><br><span class="line">        //设置shop的举例属性，从distanceMap中根据shopId查询</span><br><span class="line">        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    //6. 返回</span><br><span class="line">    return Result.ok(shops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最终效果如下，可以显示出距离<br><a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6364c8c216f2c2beb16eb996.jpg"><img src="https://pic1.imgdb.cn/item/6364c8c216f2c2beb16eb996.jpg" alt="img"></a></li>
</ul>
<h2 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h2><h3 id="BitMap功能演示"><a href="#BitMap功能演示" class="headerlink" title="BitMap功能演示"></a>BitMap功能演示</h3><ul>
<li>我们针对签到功能完全可以通过MySQL来完成，例如下面这张表</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="center">Type</th>
<th align="center">Collation</th>
<th align="center">Null</th>
<th align="center">Key</th>
<th align="center">Default</th>
<th align="center">Extra</th>
<th align="center">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">bigint unsigned</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center">PRI</td>
<td align="center">(NULL)</td>
<td align="center">auto_increment</td>
<td align="center">主键</td>
</tr>
<tr>
<td align="center">user_id</td>
<td align="center">bigint unsigned</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">用户id</td>
</tr>
<tr>
<td align="center">year</td>
<td align="center">year</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">签到的年</td>
</tr>
<tr>
<td align="center">month</td>
<td align="center">tinyint</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">签到的月</td>
</tr>
<tr>
<td align="center">date</td>
<td align="center">date</td>
<td align="center">(NULL)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">签到的日期</td>
</tr>
<tr>
<td align="center">is_backup</td>
<td align="center">tinyint unsigned</td>
<td align="center">(NULL)</td>
<td align="center">YES</td>
<td align="center"></td>
<td align="center">(NULL)</td>
<td align="center"></td>
<td align="center">是否补签</td>
</tr>
</tbody></table>
<ul>
<li>用户签到一次，就是一条记录，假如有1000W用户，平均没人每年签到10次，那这张表一年的数据量就有1亿条</li>
<li>那有没有方法能简化一点呢？我们可以使用二进制位来记录每个月的签到情况，签到记录为1，未签到记录为0</li>
<li>把每一个bit位对应当月的每一天，形成映射关系，用0和1标识业务状态，这种思路就成为位图（BitMap）。这样我们就能用极小的空间，来实现大量数据的表示</li>
<li>Redis中是利用String类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是2^32个bit位</li>
<li>BitMap的操作命令有<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT：获取指定位置（offset）的bit值</li>
<li>BITCOUNT：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP：将多个BitMap的结果做位运算（与、或、异或）</li>
<li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
</li>
</ul>
<h3 id="实现签到功能"><a href="#实现签到功能" class="headerlink" title="实现签到功能"></a>实现签到功能</h3><ul>
<li>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">请求方式</td>
<td align="center">Post</td>
</tr>
<tr>
<td align="center">请求路径</td>
<td align="center">&#x2F;user&#x2F;sign</td>
</tr>
<tr>
<td align="center">请求参数</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">无</td>
</tr>
</tbody></table>
<ul>
<li>思路：我们可以把年和月作为BitMap的key，然后保存到一个BitMap中，每次签到就把对应位上的0变成1，只要是1就说明这一天已经签到了，反之则没有签到</li>
<li>由于BitMap底层是基于String数据结构，因此其操作也都封装在字符串相关操作中了</li>
<li>在UserController中编写对应的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@PostMapping(&quot;/sign&quot;)</span><br><span class="line">public Result sign()&#123;</span><br><span class="line">    return userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result sign() &#123;</span><br><span class="line">    //1. 获取当前用户</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    //2. 获取日期</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    //3. 拼接key</span><br><span class="line">    String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    //4. 获取今天是当月第几天(1~31)</span><br><span class="line">    int dayOfMonth = now.getDayOfMonth();</span><br><span class="line">    //5. 写入Redis  BITSET key offset 1</span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用PostMan发送请求测试，注意请求头中需携带登录用户的token，否则无效（又浪费我五分钟找这个问题）</li>
<li>发送成功之后，在Redis图形化界面中是可以看到的</li>
</ul>
<h3 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h3><ul>
<li><p>如何获取本月到今天为止的所有签到数据？</p>
<ul>
<li>BITFIELD key GET u[dayOfMonth] 0</li>
</ul>
</li>
<li><p>如何从后往前遍历每个bit位，获取连续签到天数</p>
<ul>
<li>连续签到天数，就是从末尾往前数，看有多少个1</li>
<li>简单的位运算算法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">int count = 0;</span><br><span class="line">while(true) &#123;</span><br><span class="line">    if((num &amp; 1) == 0)</span><br><span class="line">        break;</span><br><span class="line">    else</span><br><span class="line">        count++;</span><br><span class="line">    num &gt;&gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">请求方式</td>
<td align="center">GET</td>
</tr>
<tr>
<td align="center">请求路径</td>
<td align="center">&#x2F;user&#x2F;sign&#x2F;count</td>
</tr>
<tr>
<td align="center">请求参数</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">连续签到天数</td>
</tr>
</tbody></table>
<ul>
<li>在UserController中创建对应的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@GetMapping(&quot;/sign/count&quot;)</span><br><span class="line">public Result signCount()&#123;</span><br><span class="line">    return userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在UserServiceImpl中实现方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result signCount() &#123;</span><br><span class="line">    //1. 获取当前用户</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    //2. 获取日期</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    //3. 拼接key</span><br><span class="line">    String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    //4. 获取今天是当月第几天(1~31)</span><br><span class="line">    int dayOfMonth = now.getDayOfMonth();</span><br><span class="line">    //5. 获取截止至今日的签到记录  BITFIELD key GET uDay 0</span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(key, BitFieldSubCommands.create()</span><br><span class="line">            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0));</span><br><span class="line">    if (result == null || result.isEmpty()) &#123;</span><br><span class="line">        return Result.ok(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //6. 循环遍历</span><br><span class="line">    int count = 0;</span><br><span class="line">    Long num = result.get(0);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if ((num &amp; 1) == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else</span><br><span class="line">            count++;</span><br><span class="line">        //数字右移，抛弃最后一位</span><br><span class="line">        num &gt;&gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用PostMan发送请求，可以手动修改redis中的签到数据多次测试，发请求的时候还是要注意携带登录用户的token</li>
</ul>
<h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><ul>
<li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
<li>本博客的首页侧边栏就有本站访客量和本站总访问量，对应的就是UV和PV</li>
<li>通常来说PV会比UV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素。</li>
<li>UV统计在服务端做会很麻烦，因为要判断该用户是否已经统计过了，需要将统计过的信息保存，但是如果每个访问的用户都保存到Redis中，那么数据库会非常恐怖，那么该如何处理呢？</li>
<li>HyperLogLog(HLL)是从Loglog算法派生的概率算法，用户确定非常大的集合基数，而不需要存储其所有值，算法相关原理可以参考下面这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a></li>
<li>Redis中的HLL是基于string结构实现的，单个HLL的内存<code>永远小于16kb</code>，<code>内存占用低</code>的令人发指！作为代价，其测量结果是概率性的，<code>有小于0.81％的误差</code>。不过对于UV统计来说，这完全可以忽略。</li>
<li>常用的三个方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">PFADD key element [element...]</span><br><span class="line">summary: Adds the specified elements to the specified HyperLogLog</span><br><span class="line"></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line">Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</span><br><span class="line"></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br><span class="line">lnternal commands for debugging HyperLogLog values</span><br></pre></td></tr></table></figure>

<h3 id="测试百万数据的统计"><a href="#测试百万数据的统计" class="headerlink" title="测试百万数据的统计"></a>测试百万数据的统计</h3><ul>
<li>使用单元测试，向HyperLogLog中添加100万条数据，看看内存占用是否真的那么低，以及统计误差如何</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testHyperLogLog() &#123;</span><br><span class="line">    String[] users = new String[1000];</span><br><span class="line">    int j = 0;</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        j = i % 1000;</span><br><span class="line">        users[j] = &quot;user_&quot; + i;</span><br><span class="line">        if (j == 999) &#123;</span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(&quot;HLL&quot;, users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Long count = stringRedisTemplate.opsForHyperLogLog().size(&quot;HLL&quot;);</span><br><span class="line">    System.out.println(&quot;count = &quot; + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>插入100W条数据，得到的count为997593，误差率为0.002407%</li>
<li>去Redis图形化界面中查看占用情况为：12.3K字节</li>
</ul>
<p>Redis实战篇</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hjianming.github.io">HUANG jm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hjianming.github.io/2023/05/25/RedisTry/">https://hjianming.github.io/2023/05/25/RedisTry/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hjianming.github.io" target="_blank">HUANGjm 's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/master/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=3910186754,1957799350&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=991&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/master/2023/10/12/mysqlinterview/" title="Mysql面试八股文"><img class="cover" src="https://img1.baidu.com/it/u=1965663592,580944689&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=917&amp;h=500" onerror="onerror=null;src='/master/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mysql面试八股文</div></div></a></div><div class="next-post pull-right"><a href="/master/2023/05/19/datastructandalgorithm/" title="数据结构和算法"><img class="cover" src="https://img0.baidu.com/it/u=311636268,727562660&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/master/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构和算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/master/2023/05/13/RedisBasic/" title="Redis基础"><img class="cover" src="https://img1.baidu.com/it/u=3701577953,2518490734&fm=253&fmt=auto&app=138&f=JPEG?w=550&h=306" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-13</div><div class="title">Redis基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/master/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUANG jm</div><div class="author-info__description">越努力越幸运</div></div><div class="card-info-data site-data is-center"><a href="/master/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/master/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/master/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！这里是我的学习生活分享!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">内容概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">短信登录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.</span> <span class="toc-text">导入项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5SQL"><span class="toc-number">2.1.1.</span> <span class="toc-text">导入SQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E5%BD%93%E5%89%8D%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">有关当前模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.3.</span> <span class="toc-text">导入后端项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">导入前端工程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESession%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">基于Session实现登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.</span> <span class="toc-text">实现发送短信验证码功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%8A%9F%E8%83%BD"><span class="toc-number">2.4.</span> <span class="toc-text">实现登录拦截功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">2.5.</span> <span class="toc-text">隐藏用户敏感信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.</span> <span class="toc-text">session共享问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%9B%BF%E4%BB%A3session%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">Redis替代session的业务流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1key%E7%BB%93%E6%9E%84"><span class="toc-number">2.7.1.</span> <span class="toc-text">设计key结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1key%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82"><span class="toc-number">2.7.2.</span> <span class="toc-text">设计key的具体细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.3.</span> <span class="toc-text">整体访问流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">2.8.</span> <span class="toc-text">基于Redis实现短信登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.9.</span> <span class="toc-text">解决状态登录刷新问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%96%B9%E6%A1%88"><span class="toc-number">2.9.1.</span> <span class="toc-text">初始方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">2.9.2.</span> <span class="toc-text">优化方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">商户查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">什么是缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">为什么要使用缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">如何使用缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">添加商户缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%80%9D%E8%B7%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">缓存模型和思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%81%E7%83%AD%E6%89%93%E9%93%81"><span class="toc-number">3.2.3.</span> <span class="toc-text">趁热打铁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.</span> <span class="toc-text">缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.3.1.</span> <span class="toc-text">数据库和缓存不一致解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88"><span class="toc-number">3.3.2.</span> <span class="toc-text">数据库和缓存不一致采用什么方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="toc-number">3.4.</span> <span class="toc-text">实现商铺缓存与数据库双写一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">3.5.</span> <span class="toc-text">缓存穿透问题的解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.</span> <span class="toc-text">编码解决商品查询的缓存穿透问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">3.7.</span> <span class="toc-text">缓存雪崩问题及解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">3.8.</span> <span class="toc-text">缓存击穿问题及解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4"><span class="toc-number">3.9.</span> <span class="toc-text">对比互斥锁与逻辑删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">3.10.</span> <span class="toc-text">利用互斥锁解决缓存击穿问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">3.11.</span> <span class="toc-text">利用逻辑过期解决缓存击穿问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85Redis%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">3.12.</span> <span class="toc-text">封装Redis工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">4.</span> <span class="toc-text">优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">4.1.</span> <span class="toc-text">Redis实现全局唯一ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8"><span class="toc-number">4.2.</span> <span class="toc-text">添加优惠券</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">4.3.</span> <span class="toc-text">实现秒杀下单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">超卖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">4.5.</span> <span class="toc-text">一人一单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">集群环境下的并发问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">5.1.</span> <span class="toc-text">基本原理和实现方式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.</span> <span class="toc-text">Redis分布式锁的实现核心思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">实现分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0%E6%83%85%E5%86%B5%E8%AF%B4%E6%98%8E"><span class="toc-number">5.4.</span> <span class="toc-text">Redis分布式锁误删情况说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="toc-number">5.5.</span> <span class="toc-text">解决Redis分布式锁误删问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.6.</span> <span class="toc-text">分布式锁的原子性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E8%84%9A%E6%9C%AC%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.</span> <span class="toc-text">Lua脚本解决多条命令原子性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Java%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8Lua%E8%84%9A%E6%9C%AC%E6%94%B9%E9%80%A0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.8.</span> <span class="toc-text">利用Java代码调用Lua脚本改造分布式锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redisson"><span class="toc-number">6.</span> <span class="toc-text">分布式锁-Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E5%85%A5%E9%97%A8"><span class="toc-number">6.1.</span> <span class="toc-text">Redisson入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">Redisson可重入锁原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E9%94%81%E9%87%8D%E8%AF%95%E5%92%8CWatchDog%E6%9C%BA%E5%88%B6"><span class="toc-number">6.3.</span> <span class="toc-text">Redisson锁重试和WatchDog机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E9%94%81%E7%9A%84MutiLock%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">Redisson锁的MutiLock原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">秒杀优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E6%80%9D%E8%B7%AF"><span class="toc-number">7.1.</span> <span class="toc-text">异步秒杀思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%8C%E6%88%90%E7%A7%92%E6%9D%80%E8%B5%84%E6%A0%BC%E5%88%A4%E6%96%AD"><span class="toc-number">7.2.</span> <span class="toc-text">Redis完成秒杀资格判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">基于阻塞队列实现秒杀优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%90%8D%E4%B8%BAusers%E7%9A%84%E9%98%9F%E5%88%97%EF%BC%8C%E5%B9%B6%E5%90%91%E5%85%B6%E4%B8%AD%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%EF%BC%8C%E5%86%85%E5%AE%B9%E6%98%AF-name-x3D-jack-age-x3D-21-%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BD%BF%E7%94%A8Redis%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90ID"><span class="toc-number">8.</span> <span class="toc-text">创建名为users的队列，并向其中发送一个消息，内容是{name&#x3D;jack, age&#x3D;21}，并且使用Redis自动生成ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E5%88%B0%E7%B2%89%E4%B8%9D%E6%94%B6%E4%BB%B6%E7%AE%B1"><span class="toc-number">8.1.</span> <span class="toc-text">推送到粉丝收件箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%94%B6%E4%BB%B6%E7%AE%B1"><span class="toc-number">8.2.</span> <span class="toc-text">实现分页查询收件箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7"><span class="toc-number">9.</span> <span class="toc-text">附近商户</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">GEO数据结构的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%BA%97%E9%93%BA%E6%95%B0%E6%8D%AE%E5%88%B0GEO"><span class="toc-number">9.2.</span> <span class="toc-text">导入店铺数据到GEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7%E5%8A%9F%E8%83%BD"><span class="toc-number">9.3.</span> <span class="toc-text">实现附近商户功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0"><span class="toc-number">10.</span> <span class="toc-text">用户签到</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BitMap%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA"><span class="toc-number">10.1.</span> <span class="toc-text">BitMap功能演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">10.2.</span> <span class="toc-text">实现签到功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">10.3.</span> <span class="toc-text">签到统计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">11.</span> <span class="toc-text">UV统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">11.1.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">11.2.</span> <span class="toc-text">测试百万数据的统计</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/master/2024/03/18/JUC/" title="JAVA并发编程"><img src="https://img0.baidu.com/it/u=2673111999,852452608&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=450" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="JAVA并发编程"/></a><div class="content"><a class="title" href="/master/2024/03/18/JUC/" title="JAVA并发编程">JAVA并发编程</a><time datetime="2024-03-18T03:21:56.656Z" title="发表于 2024-03-18 11:21:56">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2024/03/06/SkyTakeOut/" title="麦老头炸鸡"><img src="https://img1.baidu.com/it/u=3286805665,73344517&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1200&amp;h=639" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="麦老头炸鸡"/></a><div class="content"><a class="title" href="/master/2024/03/06/SkyTakeOut/" title="麦老头炸鸡">麦老头炸鸡</a><time datetime="2024-03-06T13:34:03.024Z" title="发表于 2024-03-06 21:34:03">2024-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/12/07/SpringCloudUtility/" title="SpringCloud实用篇"><img src="https://img2.baidu.com/it/u=3840651282,2081575526&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="SpringCloud实用篇"/></a><div class="content"><a class="title" href="/master/2023/12/07/SpringCloudUtility/" title="SpringCloud实用篇">SpringCloud实用篇</a><time datetime="2023-12-07T07:29:54.944Z" title="发表于 2023-12-07 15:29:54">2023-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/12/04/JVM-mid/" title="JVM中篇：字节码与类的加载篇"><img src="https://img1.baidu.com/it/u=1124169842,3402755948&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="JVM中篇：字节码与类的加载篇"/></a><div class="content"><a class="title" href="/master/2023/12/04/JVM-mid/" title="JVM中篇：字节码与类的加载篇">JVM中篇：字节码与类的加载篇</a><time datetime="2023-12-04T14:49:36.899Z" title="发表于 2023-12-04 22:49:36">2023-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/12/04/JVM-up/" title="JVM上篇：内存与垃圾回收篇"><img src="https://img2.baidu.com/it/u=4088804987,3950260204&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="JVM上篇：内存与垃圾回收篇"/></a><div class="content"><a class="title" href="/master/2023/12/04/JVM-up/" title="JVM上篇：内存与垃圾回收篇">JVM上篇：内存与垃圾回收篇</a><time datetime="2023-12-04T14:38:15.904Z" title="发表于 2023-12-04 22:38:15">2023-12-04</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By HUANG jm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/master/js/utils.js"></script><script src="/master/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>