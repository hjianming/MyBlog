<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构和算法 | HUANGjm 's blog</title><meta name="author" content="HUANG jm"><meta name="copyright" content="HUANG jm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 绪论1.1数据结构的基本概念1.1.1 基本概念和术语1.数据：数据是信息的载体，是描述客观事物属性的数、字符以及所有能输入到计算机中并被程序识别和处理的符号的集合。 2.数据元素：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。 **3.数">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构和算法">
<meta property="og:url" content="https://huangjm0508.gitee.io/2023/05/19/datastructandalgorithm/index.html">
<meta property="og:site_name" content="HUANGjm &#39;s blog">
<meta property="og:description" content="第一章 绪论1.1数据结构的基本概念1.1.1 基本概念和术语1.数据：数据是信息的载体，是描述客观事物属性的数、字符以及所有能输入到计算机中并被程序识别和处理的符号的集合。 2.数据元素：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。 **3.数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img0.baidu.com/it/u=311636268,727562660&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500">
<meta property="article:published_time" content="2023-05-19T06:41:24.469Z">
<meta property="article:modified_time" content="2023-06-23T06:19:16.597Z">
<meta property="article:author" content="HUANG jm">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img0.baidu.com/it/u=311636268,727562660&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500"><link rel="shortcut icon" href="/master/img/favicon.png"><link rel="canonical" href="https://huangjm0508.gitee.io/2023/05/19/datastructandalgorithm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/master/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/master/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构和算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-23 14:19:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/master/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/master/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/master/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/master/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/master/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/master/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/master/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/master/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/master/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/master/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/master/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/master/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/master/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img0.baidu.com/it/u=311636268,727562660&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500')"><nav id="nav"><span id="blog-info"><a href="/master/" title="HUANGjm 's blog"><span class="site-name">HUANGjm 's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/master/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/master/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/master/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/master/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/master/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/master/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/master/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/master/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/master/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/master/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构和算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-19T06:41:24.469Z" title="发表于 2023-05-19 14:41:24">2023-05-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-23T06:19:16.597Z" title="更新于 2023-06-23 14:19:16">2023-06-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构和算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1数据结构的基本概念"><a href="#1-1数据结构的基本概念" class="headerlink" title="1.1数据结构的基本概念"></a>1.1数据结构的基本概念</h2><h3 id="1-1-1-基本概念和术语"><a href="#1-1-1-基本概念和术语" class="headerlink" title="1.1.1 基本概念和术语"></a>1.1.1 基本概念和术语</h3><p><strong>1.数据：</strong>数据是信息的载体，是描述客观事物属性的数、字符以及所有能输入到计算机中并被程序识别和处理的符号的集合。</p>
<p><strong>2.数据元素：</strong>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。</p>
<p>**3.数据对象:**数据对象是具有相同性值的数据元素的集合，是数据的一个子集。</p>
<p>**4.数据类型:**数据类型是一个值的集合和定义再此集合上的一组操作的总称。</p>
<p>​	1）原子类型。其值不可再分的数据类型。如bool 和int 类型。<br>​	2）结构类型。其值可以再分解为若干成分（分量）的数据类型。<br>​	3）抽象数据类型。抽象数据组织及与之相关的操作。</p>
<p>**5.数据结构:**数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<h3 id="1-1-2数据结构三要素"><a href="#1-1-2数据结构三要素" class="headerlink" title="1.1.2数据结构三要素"></a>1.1.2数据结构三要素</h3><p><strong>1.数据的逻辑结构：</strong><br>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。<br>逻辑结构包括：</p>
<ul>
<li>集合结构：结构中的数据元素之间除“同属一个集合”外，别无其它关系。</li>
<li>线性结构：结构中的数据元素之间只存在一对一的关系，除了第一个元素，所有元	素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。</li>
<li>树形结构：结构中数据元素之间存在一对多的关系。</li>
<li>图状结构：数据元素之间是多对多的关系。</li>
</ul>
<p><img src="/master/2023/05/19/datastructandalgorithm/01.jpeg" alt="01"></p>
<p><strong>2.数据的存储结构（物理结构）：</strong><br>存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。<br>存储结构包括：</p>
<ul>
<li>顺序存储：把逻辑上相邻的元素存储在物理位置也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</li>
<li>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</li>
<li>索引存储：在存储元素信息的同时，还建立附加的索引表，索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）</li>
<li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储。</li>
</ul>
<p><strong>3.数据的运算：</strong>施加在数据上的运算包括运算的定义何实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>
<h2 id="1-2算法分析"><a href="#1-2算法分析" class="headerlink" title="1.2算法分析"></a>1.2算法分析</h2><h3 id="1-2-1算法的基本概念"><a href="#1-2-1算法的基本概念" class="headerlink" title="1.2.1算法的基本概念"></a>1.2.1算法的基本概念</h3><p><strong>程序&#x3D;数据结构+算法</strong></p>
<p>**算法（algorithm)**是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p>
<p><strong>算法的特性：</strong></p>
<ol>
<li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li>
<li>确定性：算法中每条指令必须有确定的含义，对于相同的输入只能得到相同的输出。</li>
<li>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li>
<li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li>
<li>输出：一个算法有一个多个输出，这些输出是与输入有着某种特定关系的量。</li>
</ol>
<p><strong>好的算法达到的目标：</strong></p>
<ol>
<li>正确性：算法应能够正确的求接问题。</li>
<li>可读性：算法应具有良好的可读性，以帮助人们理解。</li>
<li>健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名奇妙地输出结果。</li>
<li>效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。</li>
</ol>
<h3 id="1-2-2算法效率度量"><a href="#1-2-2算法效率度量" class="headerlink" title="1.2.2算法效率度量"></a>1.2.2算法效率度量</h3><p><strong>Θ渐近确界：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/02.jpg" alt="02"></p>
<p><strong>O渐近上界：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/03.jpg" alt="03"></p>
<p><strong>Ω渐近下界：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/04.jpg" alt="04"></p>
<p><strong>时间复杂度</strong><br>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记作T（n)&#x3D;O(n)，它表示随问题规模n的增大而增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。</p>
<p><strong>空间复杂度</strong><br>算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。记为S(n)&#x3D;O(g(n))。</p>
<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1顺序表──数组实现"><a href="#2-1顺序表──数组实现" class="headerlink" title="2.1顺序表──数组实现"></a>2.1顺序表──数组实现</h2><p><strong>顺序表的特点：</strong></p>
<ol>
<li>随机访问 ，可以在O(1)时间内找到第i个元素。</li>
<li>存储密度高，每个节点只存储数据元素</li>
<li>拓展容量不方便</li>
<li>插入、删除操作不方便，需要移动大量元素</li>
</ol>
<table>
<thead>
<tr>
<th>操作</th>
<th align="left">时间复杂度（平均情况）</th>
<th>时间复杂度（最坏情况）</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>访问操作</td>
<td align="left">O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>末尾插入</td>
<td align="left">O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>指定位置插入</td>
<td align="left">O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>末尾删除</td>
<td align="left">O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>指定位置删除</td>
<td align="left">O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>查找操作</td>
<td align="left">O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>更新操作</td>
<td align="left">O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] arr;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> length)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr.length &lt; length) &#123;</span><br><span class="line">		<span class="comment">/* 给数组扩容，不过我这里没有实现扩容的方法，所以直接抛出异常 */</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">this</span>.arr = arr;</span><br><span class="line">	<span class="built_in">this</span>.length = length;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">	<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">	sb.append(<span class="string">&quot;[&quot;</span>).append(arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">		sb.append(<span class="string">&quot;, &quot;</span>).append(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="2-1-1删除最小元素"><a href="#2-1-1删除最小元素" class="headerlink" title="2.1.1删除最小元素"></a>2.1.1删除最小元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteMin</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顺序表长度为0，无法删除。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">			minIndex = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[minIndex];</span><br><span class="line">	length--;</span><br><span class="line">	arr[minIndex] = arr[length - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2顺序表逆置"><a href="#2-1-2顺序表逆置" class="headerlink" title="2.1.2顺序表逆置"></a>2.1.2顺序表逆置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">		i = arr[length - i - <span class="number">1</span>];</span><br><span class="line">		arr[length - i - <span class="number">1</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3删除某元素"><a href="#2-1-3删除某元素" class="headerlink" title="2.1.3删除某元素"></a>2.1.3删除某元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteElem</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] != x) &#123;</span><br><span class="line">			arr[j] = arr[i];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	length = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4删除顺序表内闭区间元素"><a href="#2-1-4删除顺序表内闭区间元素" class="headerlink" title="2.1.4删除顺序表内闭区间元素"></a>2.1.4删除顺序表内闭区间元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteInCloseInterval</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顺序表长度为0，无法删除元素。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s &gt; t) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;给出的最小值不小于最大值。不构成区间。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s &lt;= arr[i] &amp;&amp; arr[i] &lt;= t) &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			arr[i - j] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	length -= j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5顺序表的去重"><a href="#2-1-5顺序表的去重" class="headerlink" title="2.1.5顺序表的去重"></a>2.1.5顺序表的去重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDuplicate</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顺序表长度为0，无法删除元素。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] != arr[j]) &#123;</span><br><span class="line">			arr[++j] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	length = j + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hash写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDuplicate</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;顺序表长度为0，无法删除元素。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!set.contains(arr[i])) &#123;</span><br><span class="line">			set.add(arr[i]);</span><br><span class="line">			arr[j] = arr[i];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	length = set.size();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-6合并两个有序顺序表"><a href="#2-1-6合并两个有序顺序表" class="headerlink" title="2.1.6合并两个有序顺序表"></a>2.1.6合并两个有序顺序表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title function_">merge</span><span class="params">(ArrayList l1, ArrayList l2)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[l1.length + l2.length];</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (j &lt; l1.length &amp;&amp; k &lt; l2.length) &#123;</span><br><span class="line">		<span class="keyword">if</span> (l1.arr[j] &lt;= l2.arr[k]) &#123;</span><br><span class="line">			arr[i++] = l1.arr[j++];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			arr[i++] = l2.arr[k++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (j &lt; l1.length) &#123;</span><br><span class="line">		arr[i++] = l1.arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (k &lt; l2.length) &#123;</span><br><span class="line">		arr[i++] = l2.arr[k++];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(arr, arr.length);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-7交换顺序表"><a href="#2-1-7交换顺序表" class="headerlink" title="2.1.7交换顺序表"></a>2.1.7交换顺序表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swapElem</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m &gt;= length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;长度不匹配&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reverse(arr, <span class="number">0</span>, length);</span><br><span class="line">	reverse(arr, <span class="number">0</span>, length - m);</span><br><span class="line">	reverse(arr, length - m, length);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (end - begin) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[begin + i];</span><br><span class="line">		arr[begin + i] = arr[end - i - <span class="number">1</span>];</span><br><span class="line">		arr[end - i - <span class="number">1</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-8在有序顺序表中查找元素"><a href="#2-1-8在有序顺序表中查找元素" class="headerlink" title="2.1.8在有序顺序表中查找元素"></a>2.1.8在有序顺序表中查找元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line"></span><br><span class="line">	index = (low + high) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr[index] == x) &#123;</span><br><span class="line">		find = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr[index] &lt; x) &#123;</span><br><span class="line">		low = index + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &gt; x) &#123;</span><br><span class="line">		high = index - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2链表──链表实现"><a href="#2-2链表──链表实现" class="headerlink" title="2.2链表──链表实现"></a>2.2链表──链表实现</h2><p><strong>链表的特点：</strong></p>
<ol>
<li>动态性：链表的长度可以动态地增长或缩小，不需要预先分配固定大小的内存空间。这使得链表对于处理不确定数量的元素非常有用。</li>
<li>插入和删除的高效性：由于链表中的节点通过指针相互连接，插入和删除操作相对容易和高效。只需要调整指针的指向，而不需要像数组那样移动元素。</li>
<li>内存空间的灵活利用：链表在内存中可以非连续地存储节点，每个节点可以在任何可用的内存位置。相比之下，数组需要一块连续的内存空间来存储所有元素。</li>
<li>随机访问的低效性：由于链表中的节点不是连续存储的，无法通过索引直接访问任意位置的元素，而是需要从头节点开始按顺序遍历链表。因此，链表的随机访问效率较低，时间复杂度为O(n)。</li>
<li>链表长度不受限制：链表的长度可以根据需要增长或缩小，没有固定的容量限制。这使得链表更加灵活，适用于处理未知或动态变化的数据量。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th>时间复杂度（平均情况）</th>
<th>时间复杂度（最坏情况）</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入开头</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td align="left">插入末尾</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td align="left">插入指定位置</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td align="left">删除开头</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td align="left">删除末尾</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td align="left">删除指定位置</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td align="left">查找操作</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td align="left">更新操作</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">public</span> LinkedList next;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> haveHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">boolean</span> haveHead)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(arr, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">this</span>.haveHead = haveHead;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">LinkedList</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin)</span> &#123;</span><br><span class="line">		val = arr[begin];</span><br><span class="line">		<span class="keyword">if</span> (begin != arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">			next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(arr, begin + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">		<span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> haveHead ? next : <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">			sb.append(cur.val);</span><br><span class="line">			cur  = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">			sb.append(<span class="string">&quot;, &quot;</span>).append(cur.val);</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">free</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		obj = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1删除无头节点链表的某元素"><a href="#2-2-1删除无头节点链表的某元素" class="headerlink" title="2.2.1删除无头节点链表的某元素"></a>2.2.1删除无头节点链表的某元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">deleteElem</span><span class="params">(<span class="type">int</span> x, LinkedList node)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	node.next = deleteElem(x, node.next);</span><br><span class="line">	<span class="keyword">if</span> (x == node.val) &#123;</span><br><span class="line">		<span class="type">LinkedList</span> <span class="variable">temp</span> <span class="operator">=</span> node.next;</span><br><span class="line">		free(node);</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2删除有头节点链表的某元素"><a href="#2-2-2删除有头节点链表的某元素" class="headerlink" title="2.2.2删除有头节点链表的某元素"></a>2.2.2删除有头节点链表的某元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteElem</span><span class="params">(<span class="type">int</span> x, LinkedList head)</span> &#123;</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">	<span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur.next.val == x) &#123;</span><br><span class="line">			<span class="type">LinkedList</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">			cur.next = cur.next.next;</span><br><span class="line">			free(temp); <span class="comment">// 启用虚拟机释放内存</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3逆序输出单链表java"><a href="#2-2-3逆序输出单链表java" class="headerlink" title="2.2.3逆序输出单链表java"></a>2.2.3逆序输出单链表java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printReserve</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (head != <span class="literal">null</span>) printRe(head.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printRe</span><span class="params">(LinkedList node)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	printRe(node.next);</span><br><span class="line">	System.out.println(node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4删除单链表中最小元素"><a href="#2-2-4删除单链表中最小元素" class="headerlink" title="2.2.4删除单链表中最小元素"></a>2.2.4删除单链表中最小元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteMin</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">prevOfMin</span> <span class="operator">=</span> cur;</span><br><span class="line">	<span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur.next.val &lt; prevOfMin.next.val) &#123;</span><br><span class="line">			prevOfMin = cur;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">temp</span> <span class="operator">=</span> prevOfMin.next;</span><br><span class="line">	prevOfMin.next = prevOfMin.next.next;</span><br><span class="line">	free(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-5链表逆置"><a href="#2-2-5链表逆置" class="headerlink" title="2.2.5链表逆置"></a>2.2.5链表逆置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">	ans.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">LinkedList</span> <span class="variable">temp</span> <span class="operator">=</span> cur;</span><br><span class="line">		cur = cur.next;</span><br><span class="line">		temp.next = ans.next;</span><br><span class="line">		ans.next = temp;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	head.next = ans.next;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6链表排序"><a href="#2-2-6链表排序" class="headerlink" title="2.2.6链表排序"></a>2.2.6链表排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">p</span> <span class="operator">=</span> head.next;</span><br><span class="line">	head.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; p.val &gt; cur.next.val) &#123;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cur.next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(p.val, cur.next);</span><br><span class="line"></span><br><span class="line">		p = p.next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-7删除链表中属于某个区间的元素"><a href="#2-2-7删除链表中属于某个区间的元素" class="headerlink" title="2.2.7删除链表中属于某个区间的元素"></a>2.2.7删除链表中属于某个区间的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteBetweenSection</span><span class="params">(LinkedList head, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">	<span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (low &lt; cur.next.val &amp;&amp; cur.next.val &lt; high) &#123;</span><br><span class="line">			<span class="type">LinkedList</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">			cur.next = temp.next;</span><br><span class="line">			free(temp);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-8寻找公共节点"><a href="#2-2-8寻找公共节点" class="headerlink" title="2.2.8寻找公共节点"></a>2.2.8寻找公共节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">findSameNode</span><span class="params">(LinkedList l1, LinkedList l2)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">shortList</span> <span class="operator">=</span> l1;</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">longList</span> <span class="operator">=</span> l2;</span><br><span class="line">	<span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (shortList != <span class="literal">null</span> &amp;&amp; longList != <span class="literal">null</span>) &#123;</span><br><span class="line">		shortList = shortList.next;</span><br><span class="line">		longList = longList.next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> shortList == <span class="literal">null</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span> (shortList != <span class="literal">null</span>) &#123;</span><br><span class="line">		dist++;</span><br><span class="line">		shortList = shortList.next;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span> (longList != <span class="literal">null</span>) &#123;</span><br><span class="line">		dist++;</span><br><span class="line">		longList = longList.next;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	shortList = flag ? l1 : l2;</span><br><span class="line">	longList = flag ? l2 : l1;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span> (dist-- != <span class="number">0</span>) &#123;</span><br><span class="line">		longList = longList.next;</span><br><span class="line">		<span class="keyword">while</span> (longList != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (longList == shortList) &#123;</span><br><span class="line">				<span class="keyword">return</span> longList;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				shortList = shortList.next;</span><br><span class="line">				longList = longList.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-9链表递增顺序输出"><a href="#2-2-9链表递增顺序输出" class="headerlink" title="2.2.9链表递增顺序输出"></a>2.2.9链表递增顺序输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortedOutPut</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">		<span class="type">LinkedList</span> <span class="variable">preOfMin</span> <span class="operator">=</span> cur;</span><br><span class="line">		<span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cur.next.val &lt; preOfMin.next.val) &#123;</span><br><span class="line">				preOfMin = cur;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">LinkedList</span> <span class="variable">min</span> <span class="operator">=</span> preOfMin.next;</span><br><span class="line">		System.out.println(min.val);</span><br><span class="line">		preOfMin.next = min.next;</span><br><span class="line">		free(min);</span><br><span class="line">	&#125;</span><br><span class="line">	free(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-10链表分割"><a href="#2-2-10链表分割" class="headerlink" title="2.2.10链表分割"></a>2.2.10链表分割</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">separate</span><span class="params">(LinkedList a)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> a.next;</span><br><span class="line">	a.next = <span class="literal">null</span>;</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(<span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">	b.haveHead = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">p</span> <span class="operator">=</span> a;</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">q</span> <span class="operator">=</span> b;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			p.next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(cur.val, p.next);</span><br><span class="line">			p = p.next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			q.next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(cur.val, q.next);</span><br><span class="line">			q = q.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cur = cur.next;</span><br><span class="line">		i++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-11链表去重"><a href="#2-2-11链表去重" class="headerlink" title="2.2.11链表去重"></a>2.2.11链表去重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteDuplicate</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">p</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// System.out.println(&quot;p = &quot; + p.val);</span></span><br><span class="line">		<span class="type">LinkedList</span> <span class="variable">q</span> <span class="operator">=</span> p;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (q.next != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// System.out.println(&quot;\tq.next = &quot; + q.next.val);</span></span><br><span class="line">			<span class="keyword">if</span> (q.next.val == p.val) &#123;</span><br><span class="line">				<span class="comment">// System.out.println(&quot;\t\tdelete q.next = &quot; + q.next.val);</span></span><br><span class="line">				<span class="type">LinkedList</span> <span class="variable">temp</span> <span class="operator">=</span> q.next;</span><br><span class="line">				q.next = temp.next;</span><br><span class="line">				free(temp);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				q = q.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p = p.next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-12链表合并"><a href="#2-2-12链表合并" class="headerlink" title="2.2.12链表合并"></a>2.2.12链表合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">merge</span><span class="params">(LinkedList a, LinkedList b)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">LinkedList</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(<span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">	head.haveHead = <span class="literal">true</span>;</span><br><span class="line">	a = a.next;</span><br><span class="line">	b = b.next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (a != <span class="literal">null</span> &amp;&amp; b != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a.val &lt; b.val) &#123;</span><br><span class="line">			head.next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(a.val, head.next);</span><br><span class="line">			a = a.next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			head.next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(b.val, head.next);</span><br><span class="line">			b = b.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">		head.next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(a.val, head.next);</span><br><span class="line">		a = a.next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">		head.next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(b.val, head.next);</span><br><span class="line">		b = b.next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="3-1栈"><a href="#3-1栈" class="headerlink" title="3.1栈"></a>3.1栈</h2><p><strong>栈（Stack）操作的时间复杂度和空间复杂度：</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>压栈</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>弹栈</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>获取栈顶元素</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>判断栈是否为空</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p><img src="/master/2023/05/19/datastructandalgorithm/05.jpg" alt="05"></p>
<h3 id="3-1-1栈的定义"><a href="#3-1-1栈的定义" class="headerlink" title="3.1.1栈的定义"></a>3.1.1栈的定义</h3><ul>
<li>栈是特殊的线性表：只允许在一端进行插入或删- 除操作， 其逻辑结构与普通线性表相同；</li>
<li>栈顶（Top）：允许进行插入和删除的一端 （最上面的为栈顶元素）；</li>
<li>栈底（Bottom）：固定的，不允许进行插入和删除的一端 （最下面的为栈底元素）；</li>
<li>空栈：不含任何元素的空表；</li>
<li>特点：后进先出（后进栈的元素先出栈）；</li>
<li>缺点：栈的大小不可变，解决方法——共享栈；</li>
</ul>
<h3 id="3-1-2栈的实现"><a href="#3-1-2栈的实现" class="headerlink" title="3.1.2栈的实现"></a>3.1.2栈的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mystack</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] elem;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mystack</span><span class="params">()</span> &#123;</span><br><span class="line">        elem = <span class="keyword">new</span> <span class="title class_">int</span>[DEFAULT_SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size() == elem.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elem = Arrays.copyOf(elem, elem.length * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.elem[top] = val;</span><br><span class="line">        <span class="built_in">this</span>.top++;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullStackExpection</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elem[--top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullStackExpection</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elem[top - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3共享栈"><a href="#3-1-3共享栈" class="headerlink" title="3.1.3共享栈"></a>3.1.3共享栈</h3><p><strong>共享栈操作的时间复杂度和空间复杂度：</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>共享栈的压栈操作</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>共享栈的弹栈操作</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>获取共享栈栈顶元素</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>判断共享栈是否为空</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>共享栈的压栈操作、弹栈操作、获取栈顶元素以及判断栈是否为空的时间复杂度都是常数级别的，不受栈中元素数量的影响。共享栈的空间复杂度也是常数级别的，只需要存储共享栈中的元素和相关指针。</p>
<p>需要注意的是，共享栈的容量是由底层数组的大小确定的。如果底层数组的空间被占满，继续进行压栈操作将导致栈溢出。因此，在使用共享栈时，需要合理设置底层数组的大小，以适应实际需求。</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/07.jpg" alt="07"></p>
<p><strong>定义：</strong>利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</p>
<h3 id="3-1-4栈的应用"><a href="#3-1-4栈的应用" class="headerlink" title="3.1.4栈的应用"></a>3.1.4栈的应用</h3><ol>
<li>函数调用：栈在函数调用过程中起到重要作用。每当调用一个函数时，函数的参数、返回地址和局部变量等信息会被压入栈中，函数执行完毕后，栈会弹出这些信息，使程序能够返回到正确的执行点。</li>
<li>表达式求值：栈常被用于处理表达式的求值。例如，中缀表达式转换为后缀表达式时使用栈，而后缀表达式的求值也可以借助栈来进行。</li>
<li>括号匹配：栈经常被用于检查括号是否匹配的问题。当遇到左括号时，将其压入栈中，当遇到右括号时，从栈顶弹出一个元素进行匹配。</li>
<li>浏览器的前进和后退功能：浏览器的前进和后退功能可以使用两个栈来实现。一个栈保存浏览历史记录，另一个栈保存后退历史记录，当用户执行前进或后退操作时，相应的网页 URL 会被从一个栈弹出并压入另一个栈。</li>
<li>深度优先搜索（DFS）：在图论和算法中，DFS 是一种用于搜索或遍历图形数据结构的算法。它使用栈来管理待处理的节点，从起始节点开始，将其加入栈，并依次将相邻节点加入栈，以深度优先的方式遍历图形。</li>
<li>撤销和恢复功能：在许多应用程序中，撤销和恢复功能可以使用栈来实现。每当用户执行一个操作时，相关的状态信息会被压入栈中，当用户执行撤销操作时，状态信息从栈顶弹出并恢复。</li>
</ol>
<h2 id="3-2队列"><a href="#3-2队列" class="headerlink" title="3.2队列"></a>3.2队列</h2><p><strong>队列（Queue）操作的时间复杂度和空间复杂度：</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>入队</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>出队</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>获取队首元素</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>判断队列是否为空</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p><img src="/master/2023/05/19/datastructandalgorithm/06.jpg" alt="06"></p>
<h3 id="3-2-1队列的定义"><a href="#3-2-1队列的定义" class="headerlink" title="3.2.1队列的定义"></a>3.2.1队列的定义</h3><p><strong>1.定义：</strong>队列（Queue）简称队，是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。<br><strong>2.特点：</strong></p>
<ul>
<li>队列是操作受限的线性表，只允许在一端进行插入 (入队)，另一端进行删除 (出队)</li>
<li>操作特性：先进先出 FIFO</li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>空队列：不含任何元素的空表</li>
</ul>
<h3 id="3-2-2队列的实现"><a href="#3-2-2队列的实现" class="headerlink" title="3.2.2队列的实现"></a>3.2.2队列的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">private</span> ListNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> usedSize;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line">    <span class="keyword">private</span> ListNode tail;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> date)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(date);</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            <span class="built_in">this</span>.usedSize++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = newNode;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">        <span class="built_in">this</span>.usedSize++;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullQueueExpection</span>(<span class="string">&quot;空队列&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个节点特殊处理</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> head.val;</span><br><span class="line">            head = <span class="literal">null</span>;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.usedSize--;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> head.val;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="built_in">this</span>.usedSize--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullQueueExpection</span>(<span class="string">&quot;空队列&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head.val;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="comment">//队长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.usedSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.usedSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3循环队列"><a href="#3-2-3循环队列" class="headerlink" title="3.2.3循环队列"></a>3.2.3循环队列</h3><p><strong>循环队列操作的时间复杂度和空间复杂度：</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>入队</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>出队</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>获取队首元素</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>判断队列是否为空</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>判断队列是否已满</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>循环队列的操作时间复杂度都是常数级别的，不受队列中元素数量的影响。循环队列的空间复杂度也是常数级别的，只需要存储队列中的元素和队首、队尾指针。需要注意的是，循环队列的数组大小是固定的，因此在初始化时需要预先指定队列的容量。</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/08.jpg" alt="08"></p>
<h3 id="3-2-4队列的应用"><a href="#3-2-4队列的应用" class="headerlink" title="3.2.4队列的应用"></a>3.2.4队列的应用</h3><ol>
<li>线程池：线程池通常使用队列来管理待执行的任务。新的任务被添加到队列的尾部，线程池中的线程从队列的头部获取任务进行处理，实现任务的异步执行。</li>
<li>消息队列：消息队列是一种用于异步通信的解耦工具。消息发送方将消息放入队列的尾部，接收方从队列的头部获取消息进行处理，实现不同组件之间的松耦合通信。</li>
<li>广度优先搜索（BFS）：在图论和算法中，BFS是一种用于搜索或遍历图形数据结构的算法。它使用队列来管理待处理的节点，从起始节点开始，将其加入队列，并依次将相邻节点加入队列，以层级的方式遍历图形。</li>
<li>缓冲区：队列经常被用作缓冲区，用于平衡生产者和消费者之间的速度差异。生产者将数据放入队列，而消费者从队列中获取数据进行处理，这样可以确保生产者和消费者之间的数据传输平滑。</li>
<li>操作系统调度：在操作系统中，任务调度器使用队列来管理进程的执行顺序。不同优先级的进程被添加到不同的队列中，调度器根据优先级和调度算法从队列中选择下一个要执行的进程。</li>
<li>网络数据包处理：在网络通信中，数据包通常通过队列进行排队和处理。数据包按到达顺序排队，然后依次进行处理和转发，以确保数据的有序传输。</li>
</ol>
<h1 id="第四章-树和二叉树"><a href="#第四章-树和二叉树" class="headerlink" title="第四章 树和二叉树"></a>第四章 树和二叉树</h1><h2 id="4-1树的基本概念"><a href="#4-1树的基本概念" class="headerlink" title="4.1树的基本概念"></a>4.1树的基本概念</h2><p><img src="/master/2023/05/19/datastructandalgorithm/09.jpg" alt="09"></p>
<h3 id="4-1-1树的定义"><a href="#4-1-1树的定义" class="headerlink" title="4.1.1树的定义"></a>4.1.1树的定义</h3><p>树是n个结点的有限集。</p>
<ul>
<li>空树：n&#x3D;0</li>
<li>根结点、分支结点、叶子结点</li>
<li>非空树的特性</li>
<li>子树</li>
</ul>
<h3 id="4-1-2树的术语"><a href="#4-1-2树的术语" class="headerlink" title="4.1.2树的术语"></a>4.1.2树的术语</h3><ol>
<li>节点（Node）：树中的每个元素称为一个节点，节点可以包含一个值或数据。</li>
<li>根节点（Root）：树中的顶部节点称为根节点，它是树的起始点，所有其他节点都从根节点开始可达。</li>
<li>子节点（Child）：一个节点可以有零个或多个子节点，子节点是其父节点的直接后继。</li>
<li>父节点（Parent）：一个节点的直接上级节点称为其父节点。</li>
<li>兄弟节点（Sibling）：具有同一个父节点的节点称为兄弟节点。</li>
<li>叶节点（Leaf）：没有子节点的节点称为叶节点或叶子节点。</li>
<li>子树（Subtree）：由节点及其后代节点组成的树称为子树。</li>
<li>深度（Depth）：从根节点到某个节点的唯一路径上的边数称为该节点的深度。</li>
<li>高度（Height）：树中节点的最大深度称为树的高度。</li>
<li>节点的度（Degree）：节点拥有的子节点数量称为节点的度。</li>
<li>树的度（Degree of Tree）：树中所有节点的度的最大值称为树的度。</li>
<li>父节点和子节点之间的连接称为边（Edge）。</li>
<li>子树之间没有交集，每个节点只能有一个父节点。</li>
</ol>
<h3 id="4-1-3树的性质"><a href="#4-1-3树的性质" class="headerlink" title="4.1.3树的性质"></a>4.1.3树的性质</h3><p><img src="/master/2023/05/19/datastructandalgorithm/10.png" alt="10"></p>
<h2 id="4-2二叉树"><a href="#4-2二叉树" class="headerlink" title="4.2二叉树"></a>4.2二叉树</h2><h3 id="4-2-1二叉树的基本概念"><a href="#4-2-1二叉树的基本概念" class="headerlink" title="4.2.1二叉树的基本概念"></a>4.2.1二叉树的基本概念</h3><p><strong>定义：</strong><br>二叉树是n(n&gt;&#x3D;0)个结点的有限集，它或者是空集（n&#x3D;0），或者由一个根结点及两颗互不相交的分别称作这个根的左子树和右子树的二叉树组成。</p>
<p><strong>特点：</strong></p>
<ol>
<li>每个结点最多有俩孩子（二叉树中不存在度大于2的结点）。</li>
<li>二叉树可以是空集合，根可以有空的左子树和空的右子树。</li>
<li>二叉树有左右之分，次序不能颠倒。</li>
</ol>
<p><strong>性质：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/11.jpg" alt="11"></p>
<h3 id="4-2-2二叉树的实现"><a href="#4-2-2二叉树的实现" class="headerlink" title="4.2.2二叉树的实现"></a>4.2.2二叉树的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">	object element;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3二叉树的遍历"><a href="#4-2-3二叉树的遍历" class="headerlink" title="4.2.3二叉树的遍历"></a>4.2.3二叉树的遍历</h3><p><strong>前中后遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 前序位置</span></span><br><span class="line"> traverse(root.left);</span><br><span class="line"> <span class="comment">// 中序位置</span></span><br><span class="line"> traverse(root.right);</span><br><span class="line"> <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前中后序是遍历⼆叉树过程中处理每⼀个节点的<strong>三个特殊时间点</strong>，绝不仅仅是三个顺序不同的List：</p>
<ul>
<li>前序位置的代码在刚刚进⼊⼀个⼆叉树节点的时候执⾏；</li>
<li>后序位置的代码在将要离开⼀个⼆叉树节点的时候执⾏；</li>
<li>中序位置的代码在⼀个⼆叉树节点左⼦树都遍历完，即将开始遍历右⼦树的时候执⾏。</li>
</ul>
<p>做二叉树题目时，<u>⼆叉树的所有问题，就是让你在前中后序位置注⼊巧妙的代码逻辑，去达到⾃⼰的⽬的，你只需要单独思考每⼀个节点应该做什么</u>，其他的不⽤你管，抛给⼆叉树遍历框架，递归会在所有节点上做相同的操作。例如，求二叉树的深度时，需要在前序遍历位置depth++，在后序遍历位置depth–。</p>
<img src="/master/2023/05/19/datastructandalgorithm/12.jpg" alt="12" style="zoom:50%;">

<p><strong>层次遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>遍历方式</th>
<th>特点</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>前序遍历</td>
<td>习惯把那些对前中后序位置不敏感的代码写在前序位置，代码执⾏是⾃顶向下的，前序位置的代码只能从函数参数中获取⽗节点传递来的数据</td>
<td>二叉树的层数，快速排序</td>
</tr>
<tr>
<td>中序遍历</td>
<td>从最左遍历到最右</td>
<td>二叉树的排序、查找、验证</td>
</tr>
<tr>
<td>后序遍历</td>
<td>后序位置的代码执⾏是⾃底向上的，⽽后序位置的代码不仅可以获取参数数据，还可以获取到⼦树通过函数返回值传递回来的数据，所以涉及子树的问题一般用后序遍历。</td>
<td>二叉树的直径</td>
</tr>
<tr>
<td>层次遍历</td>
<td>需要用到队列</td>
<td>BFS</td>
</tr>
</tbody></table>
<h3 id="4-2-4二叉树的应用"><a href="#4-2-4二叉树的应用" class="headerlink" title="4.2.4二叉树的应用"></a>4.2.4二叉树的应用</h3><ol>
<li><p>二叉排序树(BST)</p>
<p>左子树结点值&lt;跟结点值&lt;右子树结点值，这使得二叉排序树的平均查找时间复杂度为O(log n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinarySearchTree</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; currentNode.val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                    currentNode.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    currentNode = currentNode.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; currentNode.val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    currentNode.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    currentNode = currentNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 节点值已存在，不进行重复插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == currentNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; currentNode.val) &#123;</span><br><span class="line">                currentNode = currentNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentNode = currentNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == currentNode.val) &#123;</span><br><span class="line">                deleteNode(parent, currentNode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; currentNode.val) &#123;</span><br><span class="line">                parent = currentNode;</span><br><span class="line">                currentNode = currentNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent = currentNode;</span><br><span class="line">                currentNode = currentNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(TreeNode parent, TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.left == node) &#123;</span><br><span class="line">                parent.left = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">successorParent</span> <span class="operator">=</span> node;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">successor</span> <span class="operator">=</span> node.right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (successor.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                successorParent = successor;</span><br><span class="line">                successor = successor.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.val = successor.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (successorParent.left == successor) &#123;</span><br><span class="line">                successorParent.left = successor.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                successorParent.right = successor.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> (node.left != <span class="literal">null</span>) ? node.left : node.right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">                root = child;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.left == node) &#123;</span><br><span class="line">                parent.left = child;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>平衡二叉查找树(AVL)</p>
<p>在插入和删除二叉树的结点时，要保证任意结点的左右子树的高度差的绝对值不超过1</p>
<p>调整最小不平衡二叉树：</p>
<p>​	①LL: 在A结点的左孩子的左子树中插入导致不平衡<br>​			调整： A的左孩子结点右上旋<br>​	②RR: 在A结点的右孩子的右子树中插入导致不平衡<br>​			调整： A的右孩子结点左上旋<br>​	③LR: 在A结点的左孩子的右子树中插入导致不平衡<br>​			调整： A的左孩子的右孩子，先左上旋再右上旋<br>​	④RL: 在A结点的右孩子的左子树中插入导致不平衡<br>​			调整： A的右孩子的左孩子，先右上旋再左上旋</p>
</li>
<li><p>哈夫曼树(Huffman)</p>
<ol>
<li><p>带权路径长度：从根节点到该结点之间的路径长度与该节点的权的乘积。</p>
</li>
<li><p>哈夫曼树的定义：带权路径最短的树。</p>
</li>
<li><p>哈夫曼树的构造（重点）：构造森林全是根,选用两小造新树，删除两小添新人，重复2、3剩单根。</p>
</li>
<li><p>哈杜曼编码（重点）</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/13.png" alt="13"></p>
</li>
</ol>
</li>
</ol>
<h1 id="第五章-图"><a href="#第五章-图" class="headerlink" title="第五章 图"></a>第五章 图</h1><h2 id="5-1图的定义"><a href="#5-1图的定义" class="headerlink" title="5.1图的定义"></a>5.1图的定义</h2><p><img src="/master/2023/05/19/datastructandalgorithm/14.jpg" alt="14"></p>
<h2 id="5-2图的存储"><a href="#5-2图的存储" class="headerlink" title="5.2图的存储"></a>5.2图的存储</h2><h3 id="5-2-1邻接矩阵"><a href="#5-2-1邻接矩阵" class="headerlink" title="5.2.1邻接矩阵"></a>5.2.1邻接矩阵</h3><p>空间复杂度为O(n2)</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/image-20230519204634037.png" alt="image-20230519204634037"></p>
<h3 id="5-2-2邻接表"><a href="#5-2-2邻接表" class="headerlink" title="5.2.2邻接表"></a>5.2.2邻接表</h3><p>空间复杂度：无向图O(|V|+2|E|),有向图O(|V|+|E|)</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/image-20230519204648490.png" alt="image-20230519204648490"></p>
<h3 id="5-2-3十字链表"><a href="#5-2-3十字链表" class="headerlink" title="5.2.3十字链表"></a>5.2.3十字链表</h3><p><img src="/master/2023/05/19/datastructandalgorithm/image-20230519204656507.png" alt="image-20230519204656507"></p>
<h2 id="5-3图的遍历"><a href="#5-3图的遍历" class="headerlink" title="5.3图的遍历"></a>5.3图的遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的节点定义(邻接表)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    List&lt;GraphNode&gt; neighbors;</span><br><span class="line">    Set&lt;GraphNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.neighbors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的节点定义(邻接矩阵)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span> &#123;</span><br><span class="line">    <span class="comment">//图</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] graph=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line">    <span class="comment">//访问记录</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span>[] isVisited=<span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-1DFS"><a href="#5-3-1DFS" class="headerlink" title="5.3.1DFS"></a>5.3.1DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(GraphNode node, Set&lt;GraphNode&gt; visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span> || visited.contains(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited.add(node);</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (GraphNode neighbor : node.neighbors) &#123;</span><br><span class="line">            DFS(neighbor, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> currNode)</span> &#123;</span><br><span class="line">        visited[currNode] = <span class="literal">true</span>;</span><br><span class="line">        System.out.print(currNode + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">neighbor</span> <span class="operator">=</span> <span class="number">0</span>; neighbor &lt; graph.length; neighbor++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[currNode][neighbor] == <span class="number">1</span> &amp;&amp; !visited[neighbor]) &#123;</span><br><span class="line">                dfsRecursive(graph, neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2BFS"><a href="#5-3-2BFS" class="headerlink" title="5.3.2BFS"></a>5.3.2BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">(GraphNode node)</span> &#123;</span><br><span class="line">        Set&lt;GraphNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;GraphNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        visited.add(node);</span><br><span class="line">        queue.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">GraphNode</span> <span class="variable">currNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(currNode.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (GraphNode neighbor : currNode.neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                    visited.add(neighbor);</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> startNode)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNodes</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        visited[startNode] = <span class="literal">true</span>;</span><br><span class="line">        queue.offer(startNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(currNode + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">neighbor</span> <span class="operator">=</span> <span class="number">0</span>; neighbor &lt; graph.length; neighbor++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[currNode][neighbor] == <span class="number">1</span> &amp;&amp; !visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4图的应用"><a href="#5-4图的应用" class="headerlink" title="5.4图的应用"></a>5.4图的应用</h2><h3 id="5-4-1最小生成树"><a href="#5-4-1最小生成树" class="headerlink" title="5.4.1最小生成树"></a>5.4.1最小生成树</h3><p><strong>定义：</strong>一个连通图的<u>生成树</u>包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图;若给它增加一条边，则会形成图中的一条回路。对于一个带权连通无向图G&#x3D;(V，E)，生成不同，每棵树的权(即树中所有边上的权值之和)也可能不同。权值之和最小的生成树称为<u>最小生成树</u>。</p>
<p><strong>性质：</strong></p>
<ol>
<li>最小生成树不是唯一的，即最小生成树的树形不唯一，S中可能有多个最小生成树。当图G中的各边权值互不相等时，G 的最小生成树是唯一的;若无向连通图 G 的边数比顶点数少1，即G本身是一棵树时，则G的最小生成树就是它本身。</li>
<li>最小生成树的边的权值之和总是唯一的，虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。</li>
<li>最小生成树的边数为顶点数减 1。</li>
</ol>
<p><strong>基本思想：</strong>构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质:假设 G&#x3D;(V，E)是一个带权连通无向图，U是顶点集 V的一个非空子集。若(u,v)是一条具有最小权值的边，其中u∈U，v∈V，则<u>必存在一棵包含边(u，v)的最小生成树</u>。基于该性质的最小生成树算法主要有 Prim 算法和Kruskal算法它们都基于<u>贪心算法</u>的策略对这两种算法应主要掌握算法的本质含义和基本思想，并能够手工模拟算法的实现步骤下面介绍一个通用的最小生成树算法。</p>
<p><strong>典型应用：</strong>布线问题</p>
<h4 id="5-4-1-1prim算法"><a href="#5-4-1-1prim算法" class="headerlink" title="5.4.1.1prim算法"></a>5.4.1.1prim算法</h4><p><strong>算法步骤：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/15.png" alt="15"></p>
<p>Prim(普里姆)算法的执行非常类似于寻找图的最短路径的 Dijkstra 算法(见下一节)。Prim 算法构造最小生成树的过程如图所示。初始时从图中任取一顶点(如顶点1)加入树 T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入 T，每次操作后 T中的顶点数和边数都增 1。以此类推，直至图中所有的顶点都并入T，得到的T就是最小生成树。此时T中必然有n-1条边。	</p>
<p><strong>简单实现：</strong><img src="/master/2023/05/19/datastructandalgorithm/16.png" alt="16"></p>
<p><strong>算法模拟：</strong></p>
<p>首先随便选一个节点，如节点a，加入树T，此时树中只有一个节点，之后选择一个与当前T中顶点集合距离最短的顶点，将该顶点和对应的边加入到T，每次操作后T中的顶点和边数都加1，以此类推，直至所有的顶点都加入T。</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/17.png" alt="17"></p>
<p><strong>性能分析：</strong>Prim算法的时间复杂度为O(|N2|)，不依赖与|E|，因此它适合求解边稠密的图的最小生成树。</p>
<h4 id="5-4-1-2kruskal算法"><a href="#5-4-1-2kruskal算法" class="headerlink" title="5.4.1.2kruskal算法"></a>5.4.1.2kruskal算法</h4><p><strong>算法步骤：</strong></p>
<p>假设G&#x3D;(V,E)是连通图，其最小生成树T&#x3D;(U,ET)。</p>
<p>初始化：U&#x3D;V，ET&#x3D;∅。即每个顶点构成一颗独立的树，T此时是一个仅含|V|个顶点的森林。</p>
<p>循环(重复下列操作直至T是一棵树)：按G的边的权值递增顺序依次从E-ET中选择一条边，若这条边加入T后不构成回路，则将其加入ET，否则舍弃，直到ET中含有n-1条边。</p>
<p><strong>简单实现：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/18.png" alt="18"></p>
<p><strong>算法模拟：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/19.png" alt="19"></p>
<p><strong>性能分析：</strong>通常在 Kruskal 算法中，采用堆来存放边的集合，因此每次选择最小权值的边只需 O(log|E|)的时间。此外，由于生成树T中的所有边可视为一个等价类，因此每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述 T，从而构造T的时间复杂度为O(|E|log|E|)。因此，Kruskal算法适合于边稀疏而顶点较多的图。</p>
<h3 id="5-4-2最短路径"><a href="#5-4-2最短路径" class="headerlink" title="5.4.2最短路径"></a>5.4.2最短路径</h3><h3 id="5-4-3拓扑排序"><a href="#5-4-3拓扑排序" class="headerlink" title="5.4.3拓扑排序"></a>5.4.3拓扑排序</h3><h3 id="5-4-4关键路径"><a href="#5-4-4关键路径" class="headerlink" title="5.4.4关键路径"></a>5.4.4关键路径</h3><h1 id="第六章-查找"><a href="#第六章-查找" class="headerlink" title="第六章 查找"></a>第六章 查找</h1><h1 id="第七章-排序"><a href="#第七章-排序" class="headerlink" title="第七章 排序"></a>第七章 排序</h1><h2 id="7-0排序的基本概念"><a href="#7-0排序的基本概念" class="headerlink" title="7.0排序的基本概念"></a>7.0排序的基本概念</h2><p><strong>排序：</strong>重新排列表中的元素，使表中元素满足按关键字有序的过程（关键字可以相同）</p>
<p><strong>排序算法的评价指标：</strong>时间复杂度、空间复杂度；</p>
<p><strong>排序算法的稳定性：</strong>关键字相同的元素在排序之后相对位置不变，称为稳定的；（选择题考查）</p>
<p><strong>排序算法的分类：</strong></p>
<ul>
<li>​	内部排序： 数据都在内存——关注如何使时间、空间复杂度更低；</li>
<li>​	外部排序： 数据太多，无法全部放入内存——关注如何使时间、空间复杂度更低，如何使读&#x2F;写磁盘次数更少；</li>
</ul>
<h2 id="7-1插入排序"><a href="#7-1插入排序" class="headerlink" title="7.1插入排序"></a>7.1插入排序</h2><p><strong>基本思想：</strong>每次将一个待排序的记录按其关键字大小<u>插入前面已排好序的子序列</u>，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法:</p>
<ol>
<li><p>直接插入排序</p>
<p><strong>算法描述：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/20.gif" alt="20"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span>&#123;    <span class="comment">//A中从1开始存储，0放哨兵</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i-<span class="number">1</span>])&#123;    </span><br><span class="line">            A[<span class="number">0</span>] = A[i];     <span class="comment">//复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j=i-<span class="number">1</span>; A[<span class="number">0</span>] &lt; A[j]; --j)  <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];     <span class="comment">//向后挪动</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];          <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能分析：</strong></p>
<p>​	空间复杂度：O(1)<br>​	时间复杂度：主要来自于对比关键字、移动关键字，若有n个元素，则需要n-1躺处理<br>​	最好情况： 原本为有序，共n-1趟处理，每一趟都只需要对比1次关键字，不需要移动元素，共对比n-1次 —— 	O(n)<br>​	最差情况： 原本为逆序 —— O(n²)<br>​	平均情况： O(n²)<br>​	算法稳定性：稳定</p>
</li>
<li><p>折半插入排序</p>
<p>略</p>
</li>
<li><p>希尔排序</p>
<p><strong>算法描述：</strong></p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<p><img src="/master/2023/05/19/datastructandalgorithm/21.gif" alt="21"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">ShellSort</span><span class="params">(ElemType[] A, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//A[0]为暂存单元</span></span><br><span class="line">    <span class="keyword">for</span>(dk=n/<span class="number">2</span>; dk&gt;=<span class="number">1</span>; dk=dk/<span class="number">2</span>)   <span class="comment">//步长递减（看题目要求，一般是1/2</span></span><br><span class="line">        <span class="keyword">for</span>(i=dk+<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-dk])&#123;</span><br><span class="line">                A[<span class="number">0</span>]=A[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i-dk; j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=dk)</span><br><span class="line">                    A[j+dk]=A[j];         <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j+dk]=A[<span class="number">0</span>;]             <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能分析：</strong></p>
<ul>
<li>空间效率：空间复杂度O(1)</li>
<li>时间效率: n在某个特定范围时，时间复杂度为O(n1.3),最坏情况下时间复杂度O(n²)</li>
<li>稳定性：希尔排序是一种不稳定的排序方法</li>
</ul>
</li>
</ol>
<h2 id="7-2交换排序"><a href="#7-2交换排序" class="headerlink" title="7.2交换排序"></a>7.2交换排序</h2><p><strong>基于“交换”的排序：</strong>根据序列中两个元素关键字的比较结果来对换这两个记录再序列中的位置；</p>
<h3 id="7-2-1冒泡排序"><a href="#7-2-1冒泡排序" class="headerlink" title="7.2.1冒泡排序"></a>7.2.1冒泡排序</h3><p><strong>算法描述</strong></p>
<p>第一趟排序使关键字值最小的一个元素“冒”到最前面（其最终位置）—— 每趟冒泡的结果是把序列中最小元素放到序列的最终位置，这样最多做n-1趟冒泡就能把所有元素排好序，为保证稳定性，关键字相同的元素不交换；</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/22.gif" alt="22"></p>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span>&#123;   <span class="comment">//从0开始存放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">bool</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n-<span class="number">1</span>; j&gt;i; j--) <span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(A[j-<span class="number">1</span>]&gt;A[j])&#123;      <span class="comment">//若为逆序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> A[j-<span class="number">1</span>];</span><br><span class="line">  				  A[j-<span class="number">1</span>] = A[j];</span><br><span class="line">  				  A[j] = temp;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;       <span class="comment">//本趟遍历后没有发生交换，说明表已经有序，可以结束算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能分析</strong></p>
<p>空间复杂度：O(1)<br>时间复杂度<br>最好情况 (有序) ：只需要一趟排序，比较次数&#x3D;n-1，交换次数&#x3D;0，最好时间复杂度&#x3D;O(n)<br>最坏情况 (逆序) ：比较次数 &#x3D; (n-1)+(n-2)+…+1 &#x3D; n(n-1)&#x2F;2 &#x3D; 交换次数，最坏时间复杂度 &#x3D; O(n²)，平均时间复杂度 &#x3D; O(n²)<br>冒泡排序可以用于链表、顺序表</p>
<h3 id="7-2-2快速排序"><a href="#7-2-2快速排序" class="headerlink" title="7.2.2快速排序"></a>7.2.2快速排序</h3><p><strong>算法描述：</strong></p>
<p>快速排序的基本思想是基于分治法的:在待排序表 L[1..n]中任取一个元素 pivot 作为枢轴(或基准，通常取首元素)，通过一趟排序将待排序表划分为独立的两部分 [1..k-1]和L[k+l..n]，使得 L[l…k-1]中的所有元素小于 pivot，L[k+l..n]中的所有元素大于等于pivot，则 pivot 放在了其最终位置 L(k)上，这个过程称为一趟快速排序 (或一次划分)。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上，每一趟排序都可使一个中间元素确定其最终位置。</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/23.gif"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用第一个元素将待排序序列划分为左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> A[low];          <span class="comment">//用第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot) --high; <span class="comment">//high所指元素大于枢轴，high左移</span></span><br><span class="line">        A[low] = A[high];   <span class="comment">//high所指元素小于枢轴，移动到左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;=pivot)  ++low; <span class="comment">//low所指元素小于枢轴，low右移</span></span><br><span class="line">        A[high] = A[low];   <span class="comment">//low所指元素大于枢轴，移动到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot   <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low；     <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)   <span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotpos</span> <span class="operator">=</span> Partition(A, low, high);   <span class="comment">//划分</span></span><br><span class="line">        QuickSort（A, low, pivotpos - <span class="number">1</span>);    <span class="comment">//划分左子表</span></span><br><span class="line">        QuickSort（A, pivotpos + <span class="number">1</span>, high);   <span class="comment">//划分右子表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能分析：</strong></p>
<p>最好 &#x3D; O(nlog₂n) : 每次选的枢轴元素都能将序列划分成均匀的两部分；</p>
<p>最坏 &#x3D; O(n²) ：序列本就有序或逆序，此时时间、空间复杂度最高；</p>
<p>平均时间复杂度 &#x3D; O(nlog₂n) （接近最好而不是最坏）</p>
<p>空间复杂度 &#x3D; O(递归层数)（递归层数最小为log₂n）</p>
<p>时间复杂度 &#x3D; O(n×递归层数) （递归层数最大为n）</p>
<p>稳定性：不稳定</p>
<h2 id="7-3选择排序"><a href="#7-3选择排序" class="headerlink" title="7.3选择排序"></a>7.3选择排序</h2><p><strong>算法思想：</strong>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<h3 id="7-3-1简单选择排序"><a href="#7-3-1简单选择排序" class="headerlink" title="7.3.1简单选择排序"></a>7.3.1简单选择排序</h3><p><strong>算法描述：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/24.gif" alt="24"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span>&#123;       <span class="comment">//A从0开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++)&#123;          <span class="comment">//一共进行n-1趟，i指向待排序序列中第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;                   <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)       <span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min]) min = j;   <span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min!=i) &#123;</span><br><span class="line">            swap(A[i],A[min]);         <span class="comment">//交换</span></span><br><span class="line">        &#125;                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能分析：</strong></p>
<p>空间复杂度 &#x3D; O(1)<br>时间复杂度 &#x3D; O(n²),无论有序、逆序、乱序，都需要n-1的处理，总共需要对比关键字 (n-1)+(n-2)+…+1 &#x3D; n(n-2)&#x2F;2 次，元素交换次数 &lt; n-1;<br>稳定性： 不稳定<br>适用性： 既可以用于顺序表，也可以用于链表；</p>
<h3 id="7-3-2堆排序"><a href="#7-3-2堆排序" class="headerlink" title="7.3.2堆排序"></a>7.3.2堆排序</h3><p><strong>算法描述：</strong></p>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<p><img src="/master/2023/05/19/datastructandalgorithm/25.gif" alt="25"></p>
<p><strong>算法实现:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对初始序列建立大根堆</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)   <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="comment">从最底层的分支结点开始调整*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> k, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                      <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">                                      <span class="comment">// i为当前所选根结点的左孩子</span></span><br><span class="line">                                      <span class="comment">//i*=2是为了判断调整后再下一层是否满足大根堆</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])      <span class="comment">//判断：当前所选根结点的左、右结点哪个更大</span></span><br><span class="line">            i++;                      <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) </span><br><span class="line">            <span class="keyword">break</span>;                    <span class="comment">//筛选结束：i指向更大的子结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k] = A[i];              <span class="comment">//将A[i]调整至双亲结点上</span></span><br><span class="line">            k=i;                      <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>]                       <span class="comment">//被筛选的结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//基于大根堆进行排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);          <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;      <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i], A[<span class="number">1</span>]);          <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i-<span class="number">1</span>);       <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能分析：</strong><br>空间效率:仅使用了常数个辅助单元，所以空间复杂度为 O(1)。</p>
<p>时间效率:建堆时间为 O(m)，之后有 n-1次向下调整操作，每次调整的时间复杂度为 O(h),故在最好、最坏和平均情况下，堆排序的时间复杂度为 O(log2n)。</p>
<p>稳定性:进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序方法。例如，表L&#x3D;1,22，构造初始堆时可能将2交换到堆顶，此时L&#x3D;212,最终排序序列为 L&#x3D;{1.2.2，显然，2与2的相对次序已发生变化。</p>
<h2 id="7-4归并排序和基数排序"><a href="#7-4归并排序和基数排序" class="headerlink" title="7.4归并排序和基数排序"></a>7.4归并排序和基数排序</h2><h3 id="7-4-1归并排序"><a href="#7-4-1归并排序" class="headerlink" title="7.4.1归并排序"></a>7.4.1归并排序</h3><p><strong>算法描述：</strong></p>
<p>归并排序与上述基于交换、选择等排序的思想不一样，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假定待排序表含有 n 个记录，则可将其视为 n 个有序的子表，每个子表的长度为1，然后两两归并，得到 n&#x2F;2 个长度为2或1的有序表:继续两两归并….如此重复，直到合并成一个长度为”的有序表为止，这种排序方法称为 2 路归并排序。</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/26.gif" alt="26"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果数组长度小于2，则已经有序，无需排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将数组分为两个子数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] leftArray = <span class="keyword">new</span> <span class="title class_">int</span>[mid];</span><br><span class="line">        <span class="type">int</span>[] rightArray = <span class="keyword">new</span> <span class="title class_">int</span>[n - mid];</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, leftArray, <span class="number">0</span>, mid);</span><br><span class="line">        System.arraycopy(array, mid, rightArray, <span class="number">0</span>, n - mid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归地对子数组进行归并排序</span></span><br><span class="line">        mergeSort(leftArray);</span><br><span class="line">        mergeSort(rightArray);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两个已排序的子数组</span></span><br><span class="line">        merge(leftArray, rightArray, array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] leftArray, <span class="type">int</span>[] rightArray, <span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> leftArray.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> rightArray.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较左右子数组的元素，并按照升序放入原始数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; leftLength &amp;&amp; j &lt; rightLength) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftArray[i] &lt;= rightArray[j]) &#123;</span><br><span class="line">                array[k++] = leftArray[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[k++] = rightArray[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余的元素放入原始数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; leftLength) &#123;</span><br><span class="line">            array[k++] = leftArray[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; rightLength) &#123;</span><br><span class="line">            array[k++] = rightArray[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能分析：</strong></p>
<p>2路归并的“归并树”——倒立的二叉树，树高h，归并排序趟数m &#x3D; h-1，第h层最多2^(h-1)个结点，则满足n ≤ 2^(h-1)，即h-1 &#x3D; ⌈log₂n⌉; 结论: n个元素进行2路归并排序，归并趟数 m &#x3D; ⌈log₂n⌉</p>
<p>每趟归并时间复杂度为O(n), 算法总时间复杂度为O(nlog₂n);</p>
<p>空间复杂度为O(n); (归并排序算法可视为本章占用辅助空间最多的排序算法)</p>
<p>稳定性：归并排序是稳定的</p>
<p>对于N个元素进行k路归并排序，排序的趟数m满足 k^m &#x3D; N, m &#x3D; ⌈logkN⌉</p>
<h3 id="7-4-2基数排序"><a href="#7-4-2基数排序" class="headerlink" title="7.4.2基数排序"></a>7.4.2基数排序</h3><p><strong>算法描述：</strong></p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<p><img src="/master/2023/05/19/datastructandalgorithm/27.gif" alt="27"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSorting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a=&#123;<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">100</span>,<span class="number">1111</span>,-<span class="number">10</span>&#125;;</span><br><span class="line">        Sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Sort</span><span class="params">(<span class="type">int</span>[] s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> max=Integer.MAX_VALUE;<span class="comment">//int数据类型的最大取值数：2 147 483 647</span></span><br><span class="line">        <span class="type">int</span> min=Integer.MIN_VALUE;<span class="comment">//int数据类型的最小取值数：-2 147 483 648</span></span><br><span class="line">        <span class="comment">//求最大数和最小数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">            max=Math.max(min,s[i]);<span class="comment">//返回最大值</span></span><br><span class="line">            min=Math.min(max,s[i]);<span class="comment">//返回最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小数是负数</span></span><br><span class="line">        <span class="keyword">if</span>(min&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">                s[i]=s[i]-min;<span class="comment">//减去最小负数，使每个数大于等于0</span></span><br><span class="line">            &#125;</span><br><span class="line">            max=max-min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Maxlength=(max+<span class="string">&quot;&quot;</span>).length();<span class="comment">//将数字max转化为字符串，调用字符串长度函数length，求最大数最大位数</span></span><br><span class="line">        <span class="type">int</span>[][] song1=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][s.length];<span class="comment">//建立一个二维数组，一维表示0-9，二维表示数组长度，用来存储排序的数字</span></span><br><span class="line">        <span class="type">int</span>[] song2=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//建立一个一维数组，表示0-9数字的个数</span></span><br><span class="line">        <span class="comment">//开始排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>,k=<span class="number">1</span>;i&lt;Maxlength;i++,k=k*<span class="number">10</span>)&#123;<span class="comment">//按照个位，十位，千位.....遍历下去</span></span><br><span class="line">            <span class="comment">//存入数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.length;j++)&#123;<span class="comment">//每个数都要比较</span></span><br><span class="line">                <span class="type">int</span> temp=s[j]/k%<span class="number">10</span>;<span class="comment">//得到第k位上的数</span></span><br><span class="line">                song1[temp][song2[temp]]=s[j];</span><br><span class="line">                song2[temp]++;<span class="comment">//该位，数的个数加一，为下个要存入的数字确定二维下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出数(从左(0)到右(9)，从下(0)到上(9)取出)--升序</span></span><br><span class="line">            <span class="type">int</span> tem=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> t=<span class="number">0</span>;t&lt;song2.length;t++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(song2[t]!=<span class="number">0</span>)&#123;<span class="comment">//判断该位数是否有数字</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;song2[t];j++)&#123;</span><br><span class="line">                        s[tem]=song1[t][j];</span><br><span class="line">                        tem++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                song2[t]=<span class="number">0</span>;<span class="comment">//清空个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出数(从右(9)边到左(0)，从下到上取出)--降序</span></span><br><span class="line">            <span class="comment">/*int tem=0;</span></span><br><span class="line"><span class="comment">            for (int t=song2.length-1;t&gt;0;t--)&#123;</span></span><br><span class="line"><span class="comment">                if(song2[t]!=0)&#123;//判断该位,是否有数字</span></span><br><span class="line"><span class="comment">                    for (int j=0;j&lt;song2[t];j++)&#123;</span></span><br><span class="line"><span class="comment">                        s[tem]=song1[t][j];</span></span><br><span class="line"><span class="comment">                        tem++;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                song2[t]=0;//清空个数</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小数是负数</span></span><br><span class="line">        <span class="keyword">if</span> (min&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">                s[i]=s[i]+min;<span class="comment">//加上之前减去的min得到原来的数字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能分析：</strong></p>
<p>空间效率：O(r), 其中r为基数，需要的辅助空间(队列)为r；<br>时间效率：一共进行d趟分配收集，一趟分配需要O(n), 一趟收集需要O®, 时间复杂度为 O[d(n+r)]，且与序列的初始状态无关<br>稳定性：稳定！<br>基数排序擅长解决的问题<br>①数据元素的关键字可以方便地拆分为d组，且d较小；<br>②每组关键字的取值范围不大，即r较小；<br>③数据元素个数n较大；</p>
<h2 id="7-5排序算法比较"><a href="#7-5排序算法比较" class="headerlink" title="7.5排序算法比较"></a>7.5排序算法比较</h2><p><img src="/master/2023/05/19/datastructandalgorithm/28.png"></p>
<h1 id="第八章-字符串"><a href="#第八章-字符串" class="headerlink" title="第八章 字符串"></a>第八章 字符串</h1><p>Java的String是一种重要而实用的抽象数据类型。一个String值是一串可以由索引访问的char值。</p>
<h2 id="8-1java中字符串的性质："><a href="#8-1java中字符串的性质：" class="headerlink" title="8.1java中字符串的性质："></a><strong>8.1java中字符串的性质：</strong></h2><ul>
<li>不可变性：</li>
</ul>
<ol>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li>
</ol>
<p>总结:只要定义了字符串，之后对其做任何改变都是在常量池中重新创建一个常量赋值给字符串，而不修改当前的常量。</p>
<ul>
<li>不同实例方式：</li>
</ul>
<ol>
<li>通过字面量定义，数据保存在数据库常量池中</li>
<li>通过new+构造器方式，数据保存在堆空间中，此时变量保存的是地址</li>
</ol>
<h2 id="8-2String常用方法："><a href="#8-2String常用方法：" class="headerlink" title="8.2String常用方法："></a><strong>8.2String常用方法：</strong></h2><p><img src="/master/2023/05/19/datastructandalgorithm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230522145627.png" alt="微信截图_20230522145627"></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230522145647.png" alt="微信截图_20230522145647"></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230522145701.png" alt="微信截图_20230522145701"></p>
<h2 id="8-3字符串的转换"><a href="#8-3字符串的转换" class="headerlink" title="8.3字符串的转换"></a>8.3字符串的转换</h2><ol>
<li><p>字符串和基本数据类型</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230522150137.png" alt="微信截图_20230522150137"></p>
</li>
<li><p>字符串和字符数据类型</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230522150146.png" alt="微信截图_20230522150146"></p>
</li>
<li><p>字符串和byte数据类型</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230522150156.png" alt="微信截图_20230522150156"></p>
</li>
</ol>
<h2 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h2><h2 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h2><h2 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h2><h2 id="8-7"><a href="#8-7" class="headerlink" title="8.7"></a>8.7</h2><h2 id="8-8"><a href="#8-8" class="headerlink" title="8.8"></a>8.8</h2><h1 id="第九章-算法思想"><a href="#第九章-算法思想" class="headerlink" title="第九章 算法思想"></a>第九章 算法思想</h1><h2 id="9-1贪心算法"><a href="#9-1贪心算法" class="headerlink" title="9.1贪心算法"></a>9.1贪心算法</h2><p><strong>算法思想：</strong></p>
<p>每次选择当前看起来最优的解，希望通过每个局部的最优选择达到全局最优。贪心算法通常在每个决策点上做出当前最优选择，而不考虑该选择对后续决策的影响。</p>
<p><strong>贪心算法的两要素：</strong></p>
<ul>
<li>贪心选择性质</li>
<li>最优子结构</li>
</ul>
<p><strong>特点：</strong>贪心算法的优点是简单、高效，并且在某些问题上可以快速找到近似最优解。然而，贪心算法并不适用于所有问题，因为贪心策略可能无法得到全局最优解。有时候，贪心算法可能会陷入局部最优解，无法达到全局最优。因此，在应用贪心算法时，需要仔细分析问题的特性，确保贪心选择策略的正确性。</p>
<p><strong>常见贪心算法的应用：</strong></p>
<ul>
<li>零钱兑换问题</li>
<li>背包问题的部分背包和分数背包</li>
<li>最小生成树问题的Prim算法和Kruskal算法</li>
<li>最短路径问题的Dijkstra算法和Bellman-Ford算法</li>
</ul>
<p><strong>证明贪心算法：</strong></p>
<ol>
<li>​	证明贪心选择性质：必须证明每一步所作的贪心选择最终导致问题的一个整体最优解。首先证明问题的一个整体最优解，是从贪心选择开始的，然后证明，作了贪心选择后，原问题简化为一个规模更小的类似的子问题。数学归纳法证明，通过每一步作贪心选择，最终可得到问题的一个整体最优解。其中，证明贪心选择后的问题被简化为规模更小的类似问题的关键在于利用该问题的最优子结构性质。</li>
<li>​	证明最优子结构：一般采用反证法，即都是假设全局最优解如果不包含着子问题的最优解，那么通过假设的子问题的最优解就会推出我们原来假设的全局最优不正确（找出了比我们假设的最优解更优的解），从而矛盾！</li>
</ol>
<p>具体例子：船的装载问题</p>
<ol>
<li><p>证明贪心选择性质：</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/QQ%E6%88%AA%E5%9B%BE20230521153232.jpg" alt="QQ截图20230521153232"></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/QQ%E6%88%AA%E5%9B%BE20230521153242.jpg" alt="QQ截图20230521153242"></p>
</li>
<li><p>证明最优子结构：</p>
<p><img src="/master/2023/05/19/datastructandalgorithm/QQ%E6%88%AA%E5%9B%BE20230521153058.jpg" alt="QQ截图20230521153058"></p>
</li>
</ol>
<h2 id="9-2分治算法"><a href="#9-2分治算法" class="headerlink" title="9.2分治算法"></a>9.2分治算法</h2><p><strong>算法思想：</strong></p>
<ul>
<li>分( divide):将原问题分解为互不相交的若干个子问题，这些子问题是原问题规模较小的实例。</li>
<li>治( conquer):递归地求解子问题，然后合并成原问题的解。</li>
</ul>
<p><strong>典型算法：</strong>归并排序</p>
<h2 id="9-3动态规划"><a href="#9-3动态规划" class="headerlink" title="9.3动态规划"></a>9.3动态规划</h2><p><strong>算法思想：</strong>动态规划(dynamic programming)与分治方法相似，都是通过组合子问题的解来求解原问题。分治方法将问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来，求出原问题的解。与之相反，<u>动态规划应用于子问题重叠的情况</u>，即不同的子问题具有公共的子问题(子问题的求解是递归进行的，将其划分为更小的子问题)。在这种情况下，分治算法会做许多不必要的 工作，它会反复地求解那些公共子问题。而动态规划算法对每个子问题只求解一次，将其解保存在一个表格中(备忘录)，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。 动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值(最小值或最大值)的解。我们称这样的解为问题的一个最优解，而不是最优解，因为可能有多个解 都达到最优值。动态规划常见的求解方法有自顶向下和自底向上，自顶向上动态规划从原问题开始，逐步计算子问题的解，直到求解整个问题。它通常使用递归或者递归+记忆化的方式进行求解，自底向上动态规划从最小规模的子问题开始，逐步计算出更大规模子问题的解，直到求解整个问题。它通常使用迭代的方式进行求解。</p>
<p><strong>动态规划的三要素：</strong></p>
<ul>
<li>最优子结构</li>
<li>重叠子问题</li>
<li>状态转移方程</li>
</ul>
<p><strong>动态规划问题的求解：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/QQ%E6%88%AA%E5%9B%BE20230521172619.jpg" alt="QQ截图20230521172619"></p>
<p>求解动态规划问题，本质上是穷解所有的解，然后找出最优解，而为了高效地求解，就需要状态转移方程，所以写出了状态转移方程，就成功了一大半。</p>
<p>状态转移方程的求解思路：</p>
<ol>
<li>明确DP数组的定义</li>
<li>(状态)原问题和⼦问题中会变化的变量</li>
<li>(转移)导致状态产⽣变化的⾏为</li>
<li>(base case)</li>
</ol>
<p>举例应用：</p>
<p> 一、凑零钱问题：给你 k 种⾯值的硬币，⾯值分别为 c1, c2 … ck，每种硬币的数量⽆限，再给⼀个总⾦额 amount，问</p>
<p>你最少需要⼏枚硬币凑出这个⾦额，如果不可能凑出，算法返回 -1。</p>
<p>①<strong>dp</strong> 数组的定义：当⽬标⾦额为 <strong>i</strong> 时，⾄少需要 <strong>dp[i]</strong> 枚硬币凑出。</p>
<p>②状态：由于硬币数量⽆限，硬币的⾯额也是题⽬给定的，只有⽬标⾦额会不断地向 base case 靠近，所以唯⼀的「状态」就是⽬标⾦额 amount。</p>
<p>③转移：⽬标⾦额为什么变化呢，因为你在选择硬币，你每选择⼀枚硬币，就相当于减少了⽬标⾦额。所以说所有硬币的⾯值，就是你的「选择」。</p>
<p>④base case：显然⽬标⾦额 amount 为 0 时算法返回 0，</p>
<p>二、最长递增子序列：输⼊⼀个⽆序的整数数组，请你找到其中最⻓的严格递增⼦序列的⻓度</p>
<p>①dp数组的定义：<strong>dp[i]</strong> 表示以 <strong>nums[i]</strong> 这个数结尾的最⻓递增⼦序列的⻓度。</p>
<p>②状态：遍历的序列的长度</p>
<p>③转移：当nums[i]&gt;nums[j]时，nums[i]可以接在nums[j]后之后，此时dp[j]+1,否则不变。</p>
<p>④base case : dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。</p>
<h2 id="9-4回溯算法"><a href="#9-4回溯算法" class="headerlink" title="9.4回溯算法"></a>9.4回溯算法</h2><p><strong>算法思想：</strong>回溯算法是一种不断试探和回溯来寻求问题解的方法，有的时候需要计算所有的解，可以通过剪枝操作来减小解空间，</p>
<p><strong>算法框架：</strong></p>
<p><img src="/master/2023/05/19/datastructandalgorithm/QQ%E6%88%AA%E5%9B%BE20230521203627.jpg" alt="QQ截图20230521203627"></p>
<h2 id="9-5摊还分析"><a href="#9-5摊还分析" class="headerlink" title="9.5摊还分析"></a>9.5摊还分析</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://huangjm0508.gitee.io">HUANG jm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://huangjm0508.gitee.io/2023/05/19/datastructandalgorithm/">https://huangjm0508.gitee.io/2023/05/19/datastructandalgorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://huangjm0508.gitee.io" target="_blank">HUANGjm 's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/master/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://img0.baidu.com/it/u=311636268,727562660&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/master/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="https://img2.baidu.com/it/u=1182103572,357915882&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="onerror=null;src='/master/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/master/2023/05/13/computernet/" title="计算机网络"><img class="cover" src="https://img2.baidu.com/it/u=1182103572,357915882&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="onerror=null;src='/master/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/master/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUANG jm</div><div class="author-info__description">越努力越幸运</div></div><div class="card-info-data site-data is-center"><a href="/master/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/master/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/master/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！这里是我的学习生活分享!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.1数据结构的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 基本概念和术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2数据结构三要素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">1.2算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1算法的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%BA%A6%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2算法效率度量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">第二章 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E9%A1%BA%E5%BA%8F%E8%A1%A8%E2%94%80%E2%94%80%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1顺序表──数组实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1删除最小元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2%E9%A1%BA%E5%BA%8F%E8%A1%A8%E9%80%86%E7%BD%AE"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2顺序表逆置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3%E5%88%A0%E9%99%A4%E6%9F%90%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3删除某元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4%E5%88%A0%E9%99%A4%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%86%85%E9%97%AD%E5%8C%BA%E9%97%B4%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4删除顺序表内闭区间元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%8E%BB%E9%87%8D"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.1.5顺序表的去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">2.1.6.</span> <span class="toc-text">2.1.6合并两个有序顺序表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-7%E4%BA%A4%E6%8D%A2%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">2.1.7.</span> <span class="toc-text">2.1.7交换顺序表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-8%E5%9C%A8%E6%9C%89%E5%BA%8F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.8.</span> <span class="toc-text">2.1.8在有序顺序表中查找元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E9%93%BE%E8%A1%A8%E2%94%80%E2%94%80%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2.2链表──链表实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1%E5%88%A0%E9%99%A4%E6%97%A0%E5%A4%B4%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%90%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1删除无头节点链表的某元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2%E5%88%A0%E9%99%A4%E6%9C%89%E5%A4%B4%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%90%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2删除有头节点链表的某元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA%E5%8D%95%E9%93%BE%E8%A1%A8java"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3逆序输出单链表java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4删除单链表中最小元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.2.5链表逆置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.2.6链表排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-7%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%8C%BA%E9%97%B4%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.7.</span> <span class="toc-text">2.2.7删除链表中属于某个区间的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-8%E5%AF%BB%E6%89%BE%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.8.</span> <span class="toc-text">2.2.8寻找公共节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-9%E9%93%BE%E8%A1%A8%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%87%BA"><span class="toc-number">2.2.9.</span> <span class="toc-text">2.2.9链表递增顺序输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-10%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2"><span class="toc-number">2.2.10.</span> <span class="toc-text">2.2.10链表分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-11%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D"><span class="toc-number">2.2.11.</span> <span class="toc-text">2.2.11链表去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-12%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6"><span class="toc-number">2.2.12.</span> <span class="toc-text">2.2.12链表合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">第三章 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">3.1栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1栈的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2栈的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3共享栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4栈的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E9%98%9F%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">3.2队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1队列的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2队列的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3循环队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4队列的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">第四章 树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">4.1树的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2%E6%A0%91%E7%9A%84%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2树的术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3树的性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.2.</span> <span class="toc-text">4.2二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1二叉树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2二叉树的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4二叉树的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9B%BE"><span class="toc-number">5.</span> <span class="toc-text">第五章 图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">5.1图的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3十字链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.</span> <span class="toc-text">5.3图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1DFS"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2BFS"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2BFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.4.</span> <span class="toc-text">5.4图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-1prim%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">5.4.1.1prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-2kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">5.4.1.2kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">5.4.4.</span> <span class="toc-text">5.4.4关键路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%9F%A5%E6%89%BE"><span class="toc-number">6.</span> <span class="toc-text">第六章 查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">第七章 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-0%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">7.0排序的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">7.1插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.</span> <span class="toc-text">7.2交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.2.1冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.2.2快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.4.</span> <span class="toc-text">7.3选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.4.1.</span> <span class="toc-text">7.3.1简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">7.4.2.</span> <span class="toc-text">7.3.2堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">7.5.</span> <span class="toc-text">7.4归并排序和基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">7.5.1.</span> <span class="toc-text">7.4.1归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">7.5.2.</span> <span class="toc-text">7.4.2基数排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">7.6.</span> <span class="toc-text">7.5排序算法比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.</span> <span class="toc-text">第八章 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1java%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">8.1java中字符串的性质：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">8.2String常用方法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.3.</span> <span class="toc-text">8.3字符串的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4"><span class="toc-number">8.4.</span> <span class="toc-text">8.4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5"><span class="toc-number">8.5.</span> <span class="toc-text">8.5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6"><span class="toc-number">8.6.</span> <span class="toc-text">8.6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7"><span class="toc-number">8.7.</span> <span class="toc-text">8.7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8"><span class="toc-number">8.8.</span> <span class="toc-text">8.8</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">9.</span> <span class="toc-text">第九章 算法思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">9.1贪心算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">9.2分治算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">9.3.</span> <span class="toc-text">9.3动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">9.4回溯算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5%E6%91%8A%E8%BF%98%E5%88%86%E6%9E%90"><span class="toc-number">9.5.</span> <span class="toc-text">9.5摊还分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/master/2023/11/29/SpringCode/" title="Spring源码解析"><img src="https://i2.hdslb.com/bfs/archive/a7466a6415dc3527a962bf4fe2f0a2a34a5bdabc.jpg?w=1000&amp;h=500" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="Spring源码解析"/></a><div class="content"><a class="title" href="/master/2023/11/29/SpringCode/" title="Spring源码解析">Spring源码解析</a><time datetime="2023-11-29T15:41:46.838Z" title="发表于 2023-11-29 23:41:46">2023-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/11/06/SpringBoot2/" title="SpringBoot2"><img src="https://img1.baidu.com/it/u=376870289,2951595201&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=854&amp;h=521" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="SpringBoot2"/></a><div class="content"><a class="title" href="/master/2023/11/06/SpringBoot2/" title="SpringBoot2">SpringBoot2</a><time datetime="2023-11-06T11:56:32.652Z" title="发表于 2023-11-06 19:56:32">2023-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/10/25/leetcodenote/" title="leetcode日记"><img src="https://img0.baidu.com/it/u=2515196433,1042495811&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=400&amp;h=230" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="leetcode日记"/></a><div class="content"><a class="title" href="/master/2023/10/25/leetcodenote/" title="leetcode日记">leetcode日记</a><time datetime="2023-10-25T07:11:57.000Z" title="发表于 2023-10-25 15:11:57">2023-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://img2.baidu.com/it/u=1182103572,357915882&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/master/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-10-23T07:12:46.933Z" title="发表于 2023-10-23 15:12:46">2023-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/05/19/datastructandalgorithm/" title="数据结构和算法"><img src="https://img0.baidu.com/it/u=311636268,727562660&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="数据结构和算法"/></a><div class="content"><a class="title" href="/master/2023/05/19/datastructandalgorithm/" title="数据结构和算法">数据结构和算法</a><time datetime="2023-05-19T06:41:24.469Z" title="发表于 2023-05-19 14:41:24">2023-05-19</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 By HUANG jm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/master/js/utils.js"></script><script src="/master/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>