<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM中篇：字节码与类的加载篇 | HUANGjm 's blog</title><meta name="author" content="HUANG jm"><meta name="copyright" content="HUANG jm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Class 文件结构概述字节码文件的跨平台性 Java 语言，跨平台的（write once，run anywhere）  当 Java 源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译。 这个优势不再那么吸引人了。Python、PHP、Perl、Ruby、Lisp 等有强大的解释器。 跨平台似乎已经快称为一门语言必选的特性。   Java 虚拟机：跨语言的平台 Java 虚拟">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM中篇：字节码与类的加载篇">
<meta property="og:url" content="https://huangjm0508.gitee.io/2023/12/04/JVM-mid/index.html">
<meta property="og:site_name" content="HUANGjm &#39;s blog">
<meta property="og:description" content="Class 文件结构概述字节码文件的跨平台性 Java 语言，跨平台的（write once，run anywhere）  当 Java 源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译。 这个优势不再那么吸引人了。Python、PHP、Perl、Ruby、Lisp 等有强大的解释器。 跨平台似乎已经快称为一门语言必选的特性。   Java 虚拟机：跨语言的平台 Java 虚拟">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.baidu.com/it/u=1124169842,3402755948&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500">
<meta property="article:published_time" content="2023-12-04T14:49:36.899Z">
<meta property="article:modified_time" content="2023-12-04T15:34:04.279Z">
<meta property="article:author" content="HUANG jm">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.baidu.com/it/u=1124169842,3402755948&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500"><link rel="shortcut icon" href="/master/img/favicon.png"><link rel="canonical" href="https://huangjm0508.gitee.io/2023/12/04/JVM-mid/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/master/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/master/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM中篇：字节码与类的加载篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-04 23:34:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/master/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/master/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/master/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/master/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/master/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/master/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/master/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/master/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/master/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/master/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/master/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/master/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/master/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img1.baidu.com/it/u=1124169842,3402755948&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500')"><nav id="nav"><span id="blog-info"><a href="/master/" title="HUANGjm 's blog"><span class="site-name">HUANGjm 's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/master/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/master/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/master/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/master/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/master/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/master/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/master/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/master/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/master/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/master/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM中篇：字节码与类的加载篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-04T14:49:36.899Z" title="发表于 2023-12-04 22:49:36">2023-12-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-04T15:34:04.279Z" title="更新于 2023-12-04 23:34:04">2023-12-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM中篇：字节码与类的加载篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="字节码文件的跨平台性"><a href="#字节码文件的跨平台性" class="headerlink" title="字节码文件的跨平台性"></a>字节码文件的跨平台性</h3><ol>
<li><p><strong>Java 语言，跨平台的（write once，run anywhere）</strong></p>
<ul>
<li>当 Java 源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译。</li>
<li>这个优势不再那么吸引人了。Python、PHP、Perl、Ruby、Lisp 等有强大的解释器。</li>
<li>跨平台似乎已经快称为一门语言必选的特性。</li>
</ul>
</li>
<li><p><strong>Java 虚拟机：跨语言的平台</strong></p>
<p><strong>Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与”Class 文件”这种特定的二进制文件格式所关联。</strong>无论使用何种语言进行软件开发， 只要能将源文件编译为正确的 Class 文件，那么这种语言就可以在 Java 虚拟机上执行，可以说，统一而强大的 Class 文件结构，就是 Java 虚拟机的基石、桥梁。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201016175037.jpg" alt="中篇_第1章：JVM的平台无关性"></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a>，所有的 JVM 全部遵守 Java 虚拟机规范，也就是说所有的 JVM 环境都是一样的， 这样一来字节码文件可以在各种 JVM 上进行。</p>
</li>
<li><p><strong>想要让一个 Java 程序正确地运行在 JVM 中，Java 源码就是必须要被编译为符合 JVM 规范的字节码</strong></p>
<ul>
<li>前端编译器的主要任务就是负责将符合 Java 语法规范的 Java 代码转换为符合 JVM 规范的字节码文件。</li>
<li>javac 是一种能够将 Java 源码编译为字节码的前端编译器。</li>
<li>javac 编译器在将 Java 源码编译为一个有效的字节码文件过程中经历了 4 个步骤，分别是<strong>词法分析、语法分析、语义分析以及生成字节码。</strong></li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201016175905.jpg" alt="中篇_第1章：JVM结构"></p>
</li>
</ol>
<p>Oracle 的 JDK 软件包括两部分内容：</p>
<ul>
<li>一部分是将 Java 源代码编译成 Java 虚拟机的指令集的编译器。</li>
<li>另一部分是用于实现 Java 虚拟机的运行时环境。</li>
</ul>
<h3 id="Java-的前端编译器"><a href="#Java-的前端编译器" class="headerlink" title="Java 的前端编译器"></a>Java 的前端编译器</h3><p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201016180142.jpg" alt="中篇_第1章：理解执行引擎"></p>
<p>前端编译器 VS 后端编译器</p>
<p>Java 源代码的编译结果是字节码，那么肯定需要有一种编译器能够将 Java 源码编译为字节码，承担这个重要责任的就是配置在 path 环境变量中的 <strong>javac 编译器</strong>。javac 是一种能够将 Java 源码编译为字节码的<strong>前端编译器</strong>。</p>
<p>HotSpot VM 并没有强制要求前端编译器只能使用 javac 来编译字节码，其实只要编译结果符合 JVM 规范都可以被 JVM 所识别即可。在 Java 的前端编译器领域，除了 javac 之外，还有一种被大家经常用到的前端编译器，那就是内置在 Eclipse 中的 <strong>ECJ（Eclipse Compiler for Java）编译器</strong>。和 javac 的全量式编译不同，ECJ 是一种增量式编译器。</p>
<ul>
<li>在 Eclipse 中，当开发人员编写完代码后，使用”Ctrl + S”快捷键时，ECJ 编译器所采取的<strong>编译方案</strong>是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此 ECJ 的编译效率会比 javac 更加迅速和高效，当然编译质量和 javac 相比大致还是一样的。</li>
<li>ECJ 不仅是 Eclipse 的默认内置前端编译器，在 Tomcat 中同样也是使用 ECJ 编译器来编译 JSP 文件。由于 ECJ 编译器是采用 GPLv2 的开源协议进行源代码公开，所以，大家可以登录 Eclipse 官网下载 ECJ 编译器的源码进行二次开发。</li>
<li>默认情况下，IntelliJ IDEA 使用 javac 编译器（还可以自己设置为 AspectJ 编译器 ajc）。</li>
</ul>
<p>前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给 HotSpot 的 JIT 编译器负责。</p>
<h3 id="透过字节码指令看代码细节"><a href="#透过字节码指令看代码细节" class="headerlink" title="透过字节码指令看代码细节"></a>透过字节码指令看代码细节</h3><ol>
<li>BAT 面试题<ol>
<li>类文件结构有几个部分？</li>
<li>知道字节码吗？字节码都有哪些？Integer x &#x3D; 5; int y &#x3D; 5; 比较 x &#x3D;&#x3D; y 都经过哪些步骤？</li>
</ol>
</li>
<li>代码举例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(i3 == i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        System.out.println(str == str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(f.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.print();</span><br><span class="line">        x = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.x = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.print();</span><br><span class="line">        x = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.x = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201019171539.png" alt="image-20201019171538026"></p>
<h2 id="虚拟机的基石：Class-文件"><a href="#虚拟机的基石：Class-文件" class="headerlink" title="虚拟机的基石：Class 文件"></a>虚拟机的基石：Class 文件</h2><h3 id="字节码文件里是什么？"><a href="#字节码文件里是什么？" class="headerlink" title="字节码文件里是什么？"></a>字节码文件里是什么？</h3><p>源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是 JVM 的指令，而不像 C、C++ 经由编译器直接生成机器码。</p>
<h3 id="什么事字节码指令（byte-code）？"><a href="#什么事字节码指令（byte-code）？" class="headerlink" title="什么事字节码指令（byte code）？"></a>什么事字节码指令（byte code）？</h3><p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的<strong>操作码（opcode）</strong>以及跟随其后的零至多个代表此操作所需参数的<strong>操作数（operand）</strong>所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p>
<p>比如：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201019172026.png" alt="image-20201019172025732"></p>
<h3 id="如何解读供虚拟机解释执行的二进制字节码？"><a href="#如何解读供虚拟机解释执行的二进制字节码？" class="headerlink" title="如何解读供虚拟机解释执行的二进制字节码？"></a>如何解读供虚拟机解释执行的二进制字节码？</h3><p>方式一：一个一个二进制的看，这里用到的是 Notepad++，需要安装一个 HEX-Editor 插件，或者使用 Binary Viewer；</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201019172152.png" alt="image-20201019172151293"></p>
<p>方式二：使用 javap 指令，JDK 自带的反解析工具；</p>
<p>方式三：使用 IDEA 插件，jclasslib 或 jclasslib bytecode viewer 客户端工具。</p>
<h2 id="Class-文件结构-1"><a href="#Class-文件结构-1" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h2><ul>
<li><strong>官方文档位置</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<ul>
<li><strong>Class 类的本质</strong></li>
</ul>
<p>任何一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，Class 文件实际上它并不一定以磁盘文件形式存在。Class 文件是一组以 8 位字节为基础单位的<strong>二进制流。</strong></p>
<ul>
<li><strong>Class 文件格式</strong></li>
</ul>
<p>Class 的结构不像 XML 等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</p>
<p>Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表。</strong></p>
<ol>
<li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节、8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明。</li>
</ol>
<ul>
<li><strong>代码举例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        num = num + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码文件：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201019173446.png" alt="image-20201019173445368"></p>
<p><strong>换句话说，充分理解了每一个字节码文件的细节，自己也可以反编译出 Java 源文件来。</strong></p>
<ul>
<li><strong>Class 文件结构概述</strong></li>
</ul>
<p>Class 文件的结构并不是一成不变的，随着 Java 虚拟机的不断发展，总是不可避免地会对 Class 文件结构做出一些调整，但是其基本结构和框架是非常稳定的。</p>
<p>Class 文件的总体结构如下：</p>
<ol>
<li>魔数</li>
<li>Class 文件版本</li>
<li>常量池</li>
<li>访问标志</li>
<li>类索引、父类索引、接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ol>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">说明</th>
<th align="center">长度</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u4</td>
<td align="center">magic</td>
<td align="center">魔数,识别Class文件格式</td>
<td align="center">4个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">minor_version</td>
<td align="center">副版本号(小版本)</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">major_version</td>
<td align="center">主版本号(大版本)</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">constant_pool_count</td>
<td align="center">常量池计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">cp_info</td>
<td align="center">constant_pool</td>
<td align="center">常量池表</td>
<td align="center">n个字节</td>
<td align="center">constant_pool_count-1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">访问标识</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">this_class</td>
<td align="center">类索引</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">super_class</td>
<td align="center">父类索引</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces_count</td>
<td align="center">接口计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces</td>
<td align="center">接口索引集合</td>
<td align="center">2个字节</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">fields_count</td>
<td align="center">字段计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">field_info</td>
<td align="center">fields</td>
<td align="center">字段表</td>
<td align="center">n个字节</td>
<td align="center">fields_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">methods_count</td>
<td align="center">方法计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">method_info</td>
<td align="center">methods</td>
<td align="center">方法表</td>
<td align="center">n个字节</td>
<td align="center">methods_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">属性计数器</td>
<td align="center">2个字节</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">属性表</td>
<td align="center">n个字节</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<h3 id="魔数：Class-文件的标志"><a href="#魔数：Class-文件的标志" class="headerlink" title="魔数：Class 文件的标志"></a>魔数：Class 文件的标志</h3><p>Magic Number（魔数）</p>
<ul>
<li>每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number）。</li>
<li>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：魔数是 Class 文件的标识符。</li>
<li>魔数值固定为 0xCAFEBABE。不会改变。</li>
<li>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</li>
</ul>
<blockquote>
<p>Error: A JNI error has occurred, please check your installation and try again </p>
<p>Exception in thread “main” java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest</p>
</blockquote>
<ul>
<li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li>
</ul>
<h3 id="Class-文件版本号"><a href="#Class-文件版本号" class="headerlink" title="Class 文件版本号"></a>Class 文件版本号</h3><ul>
<li>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是 4 个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 minor_version，而第 7 个和第 8 个字节就是编译的主版本号 major_version。</li>
<li>它们共同构成了 Class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</li>
<li>版本号和 Java 编译器的对应关系如下表：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">主版本（十进制）</th>
<th align="center">副版本（十进制）</th>
<th align="center">编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">45</td>
<td align="center">3</td>
<td align="center">1.1</td>
</tr>
<tr>
<td align="center">46</td>
<td align="center">0</td>
<td align="center">1.2</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center">0</td>
<td align="center">1.3</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">0</td>
<td align="center">1.4</td>
</tr>
<tr>
<td align="center">49</td>
<td align="center">0</td>
<td align="center">1.5</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">0</td>
<td align="center">1.6</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">0</td>
<td align="center">1.7</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">0</td>
<td align="center">1.8</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center">0</td>
<td align="center">1.9</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">0</td>
<td align="center">1.10</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">0</td>
<td align="center">1.11</td>
</tr>
</tbody></table>
<ul>
<li>Java 的版本号是从 45 开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1。</li>
<li><strong>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的。目前，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行由高版本编译器生成的 Class 文件。否则 JVM 会抛出 <code>java.lang.UnsupportedClassVersionError</code> 异常（向下兼容）。</strong></li>
<li>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的 JDK 版本和生产环境的 JDK 版本是否一致。<ul>
<li>虚拟机 JDK 版本为 1.k（k &gt;&#x3D; 2）时，对应的 Class 文件格式版本号的范围为 45.0 - 44 + k.0（含两端）。</li>
</ul>
</li>
</ul>
<h3 id="常量池：存放所有常量"><a href="#常量池：存放所有常量" class="headerlink" title="常量池：存放所有常量"></a>常量池：存放所有常量</h3><ul>
<li>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</li>
<li>随着 Java 虚拟机的不断发展，常量池的内容也日渐丰富，可以说，常量池是整个 Class 文件的基石。</li>
<li>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</li>
<li>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count），与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2（无符号数）</td>
<td align="center">constant_pool_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">cp_info（表）</td>
<td align="center">constant_pool</td>
<td align="center">constant_pool_count - 1</td>
</tr>
</tbody></table>
<p>由上表可见，Class 文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容，我们把这一系列连续常量池数据称为常量池集合。</p>
<ul>
<li><strong>常量池表项</strong>中，用于存放编译时期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载后进入方法区的<strong>运行时常量池</strong>中存放。</li>
</ul>
<h4 id="常量池计数器：存放所有常量"><a href="#常量池计数器：存放所有常量" class="headerlink" title="常量池计数器：存放所有常量"></a>常量池计数器：存放所有常量</h4><ul>
<li>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li>
<li>常量池容量计数值（u2 类型）：从 1 开始，表示常量池中有多少项常量。即 constant_pool_count &#x3D; 1 表示常量池中有 0 个常量项。</li>
<li>Demo 的值为：</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="https://gitee.com/xlshi/blog_img/raw/master/img/20201019180124.png" alt="image-20201019180123341"></p>
<p>其值为 0x0016，对应的十进制值为 22。</p>
<p>需要注意的是，这实际上只有 21 项常量。索引为范围是 1-21。为什么呢？</p>
<blockquote>
<p>通常我们写代码时都是从 0 开始的，但是这里的常量池却是从 1 开始，因为它把第 0 项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的含义，这种情况可用索引值 0 来表示。</p>
</blockquote>
<h4 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h4><ul>
<li>constant_pool 是一种表结构，以 1 ~ constant_pool_count - 1 为索引。表明了后面有多少个常量项。</li>
<li>常量池主要存放两大类常量：<strong>字面量（Literal）</strong>和<strong>符号引用（Symbolic References）。</strong></li>
<li>它包含了 Class 文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第 1 个字节作为类型标记，用于确定该项的格式，这个字节称为 tag byte（标记字节、标签字节）。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志(或标识)</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">5</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">6</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Fieldref_info</td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_Methodref_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodref_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">表示方法句柄</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">标志方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">18</td>
<td align="center">表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h5 id="字面量和符号引用"><a href="#字面量和符号引用" class="headerlink" title="字面量和符号引用"></a>字面量和符号引用</h5><p>在对这些常量解读前，需要搞清楚几个概念：</p>
<p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">具体的常量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字面量</td>
<td align="center">文本字符串</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">声明为 final 的常量值</td>
</tr>
<tr>
<td align="center">符号引用</td>
<td align="center">类和接口的全限定名</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">字段的名称和描述符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">方法的名称和描述符</td>
</tr>
</tbody></table>
<h6 id="全限定名"><a href="#全限定名" class="headerlink" title="全限定名"></a>全限定名</h6><p>com&#x2F;atguigu&#x2F;test&#x2F;Demo 这个就是类的全限定名，仅仅是把包的”.”替换成”&#x2F;“，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个”;”表示全限定名结束。</p>
<h6 id="简单名称"><a href="#简单名称" class="headerlink" title="简单名称"></a>简单名称</h6><p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的 add() 方法和 num 字段的简单名称分别是 add 和 num。</p>
<h6 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h6><p><strong>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</strong>根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名表示，详见下表：</p>
<table>
<thead>
<tr>
<th align="center">标志符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">基本数据类型 byte</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">基本数据类型 char</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">基本数据类型 double</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">基本数据类型 float</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">基本数据类型 int</td>
</tr>
<tr>
<td align="center">J</td>
<td align="center">基本数据类型 long</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">基本数据类型 short</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">基本数据类型 boolean</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">代表 void 类型</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td align="center">[</td>
<td align="center">数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
<p>用描述符来藐视方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号”()”之内，如方法 <code>java.lang.String toString()</code>的描述符为 <code>() Ljava/lang/String;</code>，方法 <code>int abc(int[] x ,int y)</code>描述符为<code>([II) I</code></p>
<blockquote>
<p>虚拟机在加载 Class 文件时才会进行动态链接，也就是说，Class 文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。<strong>当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。</strong></p>
<p>这里说明下符号引用和直接引用的区别与关联：</p>
<ul>
<li>符号引用：符号引用以<strong>一组符号</strong>来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<strong>符号引用与虚拟机实现的内存布局无关</strong>，引用的目标并不一定已经加载到内存中</li>
<li>直接引用：直接引用可以是直接指<strong>向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，</strong>同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li>
</ul>
</blockquote>
<h5 id="常量类型和结构"><a href="#常量类型和结构" class="headerlink" title="常量类型和结构"></a>常量类型和结构</h5><p>常量池中每一项常量都是一个表，JDK 1.7 之后共 14 种不同的表结构数据。如下表格所示：</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">常量</th>
<th align="center">描述</th>
<th align="center">细节</th>
<th align="center">长度</th>
<th align="center">细节描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">UTF-8 编码的字符串</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为1</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">u2</td>
<td align="center">UTF-8 编码的字符串占用的字符数</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u1</td>
<td align="center">长度为 length 的 UTF-8 编码的字符串</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">整型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为3</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u4</td>
<td align="center">按照高位在前存储的 int 值</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">CONSTANT_Float_info</td>
<td align="center">浮点型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为4</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u4</td>
<td align="center">按照高位在前存储的 float 值</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">CONSTANT_Long_info</td>
<td align="center">长整型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为5</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u8</td>
<td align="center">按照高位在前存储的 long 值</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">CONSTANT_Double_info</td>
<td align="center">双精度浮点型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为6</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">u8</td>
<td align="center">按照高位在前存储的 double 值</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">CONSTANT_Class_info</td>
<td align="center">类或接口的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为7</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向全限定名常量项的索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">CONSTANT_String_info</td>
<td align="center">字符串类型字面量</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为8</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向字符串字面量的索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">CONSTANT_Fieldref_info</td>
<td align="center">字段的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为9</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向声明字段的类或接口描述符 CONSTANT_Class_info 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向字段描述符 CONSTANT_NameAndType 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">CONSTANT_Methodref_info</td>
<td align="center">类中方法的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为10</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向声明方法的类描述符 CONSTANT_Class_Info 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向名称及类型描述符 CONSTANT_NameAndType 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">CONSTANT_InterfaceMethodref_info</td>
<td align="center">接口中方法的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为11</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向声明方法的接口描述符 CONSTANT_Class_Info 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向名称及类型描述符 CONSTANT_NameAndType 的索引项</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">字段或方法的符号引用</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为12</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向该字段或方法名称常量项的索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向该字段或方法描述符常量项的索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">表示方法句柄</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为15</td>
</tr>
<tr>
<td align="center">reference_kind</td>
<td align="center">u1</td>
<td align="center">值必须在 1-9 之间，它决定了方法句柄的类型方法句柄类型的值表示方法句柄的字节码行为</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">reference_index</td>
<td align="center">u2</td>
<td align="center">值必须是对常量池的有效索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">标志方法类型</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为16</td>
</tr>
<tr>
<td align="center">descriptor_index</td>
<td align="center">u2</td>
<td align="center">值必须是对常量池的有效索引，常量池在该索引处的项必须是 CONSTANT_Utf8_info 结构，表示方法的描述符</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">表示一个动态方法调用点</td>
<td align="center">tag</td>
<td align="center">u1</td>
<td align="center">值为18</td>
</tr>
<tr>
<td align="center">bootstrap_method_attr</td>
<td align="center">u2</td>
<td align="center">值必须是对当前 Class 文件中引导方法表的 bootstrap_methods[] 数组的有效索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">name_and_type_index</td>
<td align="center">u2</td>
<td align="center">值必须是对当前常量池的有效索引，常量池在该索引处的项必须是 CONSTANT_NameAndType_Info 结构，表示方法名和方法描述符</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中那些内容（主要是字面量、符号引用）的。比如： CONSTANT_Integer_info 是用来描述常量池中字面量信息的，而且只是整型字面量信息。</li>
<li>标志为 15、16、18 的常量项类型是用来支持动态语言调用的（JDK 1.7 时才加入）。</li>
<li>细节说明<ul>
<li>CONSTANT_Class_info 结构用于表示类或接口。</li>
<li>CONSTANT_Fieldref_info、CONSTANT_Methodref_info 和 CONSTANT_InterfaceMethodref_info 结构表示字段、方法和接口方法。</li>
<li>CONSTANT_String_info 结构用于表示 String 类型的常量对象。</li>
<li>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示 4 字节（int 和 float）的数值常量。</li>
<li>CONSTANT_Long_info 和 CONSTANT_Double_info 结构表示 8 字节（long 和 double）的数值常量。<ul>
<li>在 Class 文件的常量池中，所有的 8 字节常量均占两个表成员（项）的空间，如果一个 CONSTANT_Long_info 或 CONSTANT_Double_info 结构的项在常量池表中的索引位 n，则常量池表中下一个可用项的索引位 n + 2，此时常量池表中索引为 n + 1，的项仍然有效但必须视为不可用的。</li>
</ul>
</li>
<li>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的 3 个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</li>
<li>CONSTANT_Utf8_info 用于表示字符常量的值。</li>
<li>CONSTANT_MethodHandle_info 结构用于表示方法句柄。</li>
<li>CONSTANT_MethodType_info 结构表示方法类型。</li>
<li>CONSTANT_InvokeDynamic_info 结构用于表示 invokedynamic 指令所用到的引导方法（bootstrap method）、引导方法所用到的动态调用名称（dynamic invocation name）、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</li>
</ul>
</li>
<li>解析方式<ul>
<li>一个字节一个字节的解析。</li>
<li>使用 javap 命令解析：javap -verbose Demo.class 或 jclasslib 工具会更方便。</li>
</ul>
</li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>这 14 种表（或者常量项结构）的共同点是：表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li>
<li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li>
<li>这 14 种常量项结构还有一个特点是，其中 13 个常量项占用的字节固定，只有 CONSTANT_Utf8_info 占用字节不固定，其大小由 length 决定。为什么？<strong>因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，</strong>比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过 UTF-8 编码，就可以知道其长度。</li>
<li>常量池：可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一。</li>
<li>常量池中为什么包含这些内容？</li>
</ul>
<blockquote>
<p>Java 代码在进行 javac 编译的时候，并不像 C 和 C++ 那样有”连接”这一步骤，而是在虚拟机加载 Class 文件的时候进行动态链接。也就是说，<strong>在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。</strong>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
</blockquote>
<h3 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h3><ul>
<li>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">标志为 public 类型</td>
</tr>
<tr>
<td align="center">ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">标志被声明为 final，只有类可以设置</td>
</tr>
<tr>
<td align="center">ACC_SUPER</td>
<td align="center">0x0020</td>
<td align="center">标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td align="center">ACC_INTERFACE</td>
<td align="center">0x0200</td>
<td align="center">标志这是一个接口</td>
</tr>
<tr>
<td align="center">ACC_ABSTRACT</td>
<td align="center">0x0400</td>
<td align="center">是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td align="center">ACC_SYNTHETIC</td>
<td align="center">0x1000</td>
<td align="center">标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td align="center">ACC_ANNOTATION</td>
<td align="center">0x2000</td>
<td align="center">标志这是一个注解</td>
</tr>
<tr>
<td align="center">ACC_ENUM</td>
<td align="center">0x4000</td>
<td align="center">标志这是一个枚举</td>
</tr>
</tbody></table>
<ul>
<li>类的访问权限通常为 ACC_ 开头的常量。</li>
<li>每一个种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的。比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL。</li>
<li>使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</li>
</ul>
<blockquote>
<ol>
<li>带有 ACC_INTERFACE 标志的 Class 文件表示的是接口而不是类，反之则表示的是类而不是接口。<ol>
<li>如果一个 Class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志。</li>
<li>如果没有设置 ACC_INTERFACE 标志，那么这个 Class 问价可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不能同时设置。</li>
</ol>
</li>
<li>ACC_SUPER 标志用于确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义。<strong>针对 Java 虚拟机指令集的编译器都应当设置这个标志。</strong>对于 Java SE 8 及后续版本来说，无论 Class 文件中这个标志的实际值是什么，也不管 Class 文件的版本。</li>
<li>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</li>
<li>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_INTERFACE 标志。</li>
<li>ACC_ENUM 标志标明该类或其父类为枚举类型。</li>
<li>表中没有使用的 access_flags 标志是为未来扩充而预留的，这些预留的标志在编译器中应该设置为 0，Java 虚拟机实现也应该忽略他们。</li>
</ol>
</blockquote>
<h3 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h3><ul>
<li>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">this_class</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">super_class</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces[interfaces_count]</td>
</tr>
</tbody></table>
<ul>
<li>这三项数据来确定这个类的继承关系<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
</li>
</ul>
<ol>
<li>this_class（类索引）</li>
</ol>
<ul>
<li>2 字节无符号整数，指向常量池的索引。它提供了类的全限定名，如 com&#x2F;atguigu&#x2F;java1&#x2F;Demo。this_class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为 CONSTANT_Class_info 类型结构体，该结构体表示这个 Class 文件所定义的类或接口。</li>
</ul>
<ol start="2">
<li>super_class（父类索引）</li>
</ol>
<ul>
<li>2 字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是 java&#x2F;lang&#x2F;Object 类。同时，由于 Java 不支持多继承，所以其父类只有一个。</li>
<li>superclass 指向的父类不能是 final。</li>
</ul>
<ol start="3">
<li>interfaces</li>
</ol>
<ul>
<li><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口。</p>
</li>
<li><p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的 CONSTANT_Class（当然这里就必须是接口，而不是类）。</p>
<p>3.1 interfaces_count（接口计数器）</p>
<p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p>
<p>3.2 interface[] （接口索引集合）</p>
<p>interfaces[] 中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员 interfaces[i] 必须为 CONSTANT_Class_info 结构，其中 0 &lt;&#x3D; i &lt; interfaces_count。在 interfaces[] 中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即 interfaces[0] 对应的是源代码中最左边的接口。</p>
</li>
</ul>
<h3 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h3><ul>
<li>用于描述接口或类中声明的变量。字段（field）包括<strong>类级变量以及实例级变量</strong>，但是不包括方法内部、代码块内部声明的局部变量。</li>
<li>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li>
<li>它指向常量池索引集合，它描述了每个字段的完整信息。比如<strong>字段的标识符、访问修饰符（public、private 或 protected）、是类变量还是实例变量（static 修饰符）、是否是常量（final 修饰符）</strong>等。</li>
</ul>
<blockquote>
<p>注意事项：</p>
<ul>
<li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的方文星，会自动添加指向外部类实例的字段。</li>
<li>在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</li>
</ul>
</blockquote>
<h4 id="字段计数器（fields-count）"><a href="#字段计数器（fields-count）" class="headerlink" title="字段计数器（fields_count）"></a>字段计数器（fields_count）</h4><p>fields_count 的值表示当前 Class 文件 fields 表的成员个数，使用两个字节来表示。</p>
<p>fields 表中每个成员都是一个 field_info 结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p>
<h4 id="fields-（字段表）"><a href="#fields-（字段表）" class="headerlink" title="fields []（字段表）"></a>fields []（字段表）</h4><p>fields 表中的每个成员都必须是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述。</p>
<p>一个字段的信息包括如下这些信息，这些信息中，<strong>各个修饰符都是布尔值，要么有，要么没有</strong>。</p>
<ul>
<li>作用域（public、private、protected 修饰符）</li>
<li>是实例变量还是类变量（static 修饰符）</li>
<li>可变性（final）</li>
<li>并发可见性（volatile 修饰符，是否强制从主内存读写）</li>
<li>可否序列化（transient 修饰符）</li>
<li>字段数据类型（基本数据类型、对象、数组）</li>
<li>字段名称</li>
</ul>
<p>字段表结构：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">含义</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">访问标志</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">字段名索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">描述符索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">属性计数器</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">属性集合</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<h5 id="字段表访问标识"><a href="#字段表访问标识" class="headerlink" title="字段表访问标识"></a>字段表访问标识</h5><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static 修饰符、final 修饰符、volatile 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">字段是否为 public</td>
</tr>
<tr>
<td align="center">ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">字段是否为 private</td>
</tr>
<tr>
<td align="center">ACC_PROTECTED</td>
<td align="center">0x0004</td>
<td align="center">字段是否为 protected</td>
</tr>
<tr>
<td align="center">ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">字段是否为 static</td>
</tr>
<tr>
<td align="center">ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">字段是否为 final</td>
</tr>
<tr>
<td align="center">ACC_VOLATILE</td>
<td align="center">0x0040</td>
<td align="center">字段是否为 volatile</td>
</tr>
<tr>
<td align="center">ACC_TRANSTENT</td>
<td align="center">0x0080</td>
<td align="center">字段是否为 transient</td>
</tr>
<tr>
<td align="center">ACC_SYNCHETIC</td>
<td align="center">0x1000</td>
<td align="center">字段是否为由编译器自动产生</td>
</tr>
<tr>
<td align="center">ACC_ENUM</td>
<td align="center">0x4000</td>
<td align="center">字段是否为 enum</td>
</tr>
</tbody></table>
<h5 id="字段名索引"><a href="#字段名索引" class="headerlink" title="字段名索引"></a>字段名索引</h5><p>根据字段名索引的值，查询常量池中的指定索引项即可。</p>
<h5 id="描述符索引"><a href="#描述符索引" class="headerlink" title="描述符索引"></a>描述符索引</h5><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）及代表无返回值的 void 类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">标志符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">基本数据类型 byte</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">基本数据类型 char</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">基本数据类型 double</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">基本数据类型 float</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">基本数据类型 int</td>
</tr>
<tr>
<td align="center">J</td>
<td align="center">基本数据类型 long</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">基本数据类型 short</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">基本数据类型 boolean</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">代表 void 类型</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td align="center">[</td>
<td align="center">数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
<h5 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h5><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在 attribute_count 中，属性具体内容存放在 attributes 数组中。</p>
<p>以常量属性为例，结构为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：对于常量属性而言，attribute_length 值恒为 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>methods: 指向常量池索引集合，它完整描述了每个方法的签名。</p>
<ul>
<li>在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li>
<li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li>
<li>一方面，methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法 <clinit>() 和实例初始化方法 <init>()）</init></clinit></li>
</ul>
<blockquote>
<p>使用注意事项：</p>
<p>在 Java 语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中。</p>
<p>也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p>
</blockquote>
<h4 id="methods-count（方法计数器）"><a href="#methods-count（方法计数器）" class="headerlink" title="methods_count（方法计数器）"></a>methods_count（方法计数器）</h4><p>methods_count 的值表示当前 Class 文件 methods 表的成员个数，使用两个字节来表示。</p>
<p>methods 表中每个成员都是一个 method_info 结构。</p>
<h4 id="methods-（方法表）"><a href="#methods-（方法表）" class="headerlink" title="methods[] （方法表）"></a>methods[] （方法表）</h4><ul>
<li>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所有的 Java 虚拟机指令。</li>
<li>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法。</li>
<li>方法表的结构实际跟字段表是一样的，方法表结构如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">含义</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">访问标志</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">方法名索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">描述符索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">属性计数器</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">属性集合</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<h5 id="方法表访问标志"><a href="#方法表访问标志" class="headerlink" title="方法表访问标志"></a>方法表访问标志</h5><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p>
<table>
<thead>
<tr>
<th align="center">标记名</th>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">public，方法可以从包外访问</td>
</tr>
<tr>
<td align="center">ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">private，方法只能本类中访问</td>
</tr>
<tr>
<td align="center">ACC_PROTECTED</td>
<td align="center">0X0004</td>
<td align="center">protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td align="center">ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">static，静态方法</td>
</tr>
</tbody></table>
<h3 id="属性表结合"><a href="#属性表结合" class="headerlink" title="属性表结合"></a>属性表结合</h3><p>方法表集合之后的属性表集合，<strong>指的是 Class 文件所携带的辅助信息</strong>，比如该 Class 文件的源文件的名称。以及任何带有 RetentionPolicy.CLASS 或者 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，<strong>一般无需深入了解</strong>。</p>
<p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p>
<p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h4 id="attributes-count（属性计数器）"><a href="#attributes-count（属性计数器）" class="headerlink" title="attributes_count（属性计数器）"></a>attributes_count（属性计数器）</h4><p>attributes_count 的值表示当前 Class 文件属性表的成员个数。属性表中每一项都是一个 attribute_info 结构。</p>
<h4 id="attributes-（属性表）"><a href="#attributes-（属性表）" class="headerlink" title="attributes[] （属性表）"></a>attributes[] （属性表）</h4><p>属性表的每个项的值必须是 attribute_info 结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p>
<h5 id="属性的通用格式"><a href="#属性的通用格式" class="headerlink" title="属性的通用格式"></a>属性的通用格式</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
<td align="center">属性名索引</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
<td align="center">属性长度</td>
</tr>
<tr>
<td align="center">u1</td>
<td align="center">info</td>
<td align="center">attribute_length</td>
<td align="center">属性表</td>
</tr>
</tbody></table>
<p>即只需说明属性的名称以及占用位数的长度即可，属性表具体的结构可以去自定义。</p>
<h5 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h5><p>属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种， Java 8 里面定义了 23 种属性。</p>
<p>下面这些是虚拟机中预定义的属性：</p>
<table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="center">使用位置</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Code</td>
<td align="center">方法表</td>
<td align="center">Java 代码编译成的字节码指令</td>
</tr>
<tr>
<td align="center">ConstantValue</td>
<td align="center">字段表</td>
<td align="center">final 关键字定义的常量池</td>
</tr>
<tr>
<td align="center">Deprecated</td>
<td align="center">类、方法、字段表</td>
<td align="center">被声明为 deprecated 的方法和字段</td>
</tr>
<tr>
<td align="center">Exceptions</td>
<td align="center">方法表</td>
<td align="center">方法抛出的异常</td>
</tr>
<tr>
<td align="center">EnclosingMethod</td>
<td align="center">类文件</td>
<td align="center">仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td align="center">InnerClass</td>
<td align="center">类文件</td>
<td align="center">内部类列表</td>
</tr>
<tr>
<td align="center">LineNumberTable</td>
<td align="center">Code 属性</td>
<td align="center">Java 源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td align="center">LocalVariableTable</td>
<td align="center">Code 属性</td>
<td align="center">方法的局部变量描述</td>
</tr>
<tr>
<td align="center">StackMapTable</td>
<td align="center">Code 属性</td>
<td align="center">JDK 1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数所需要的类是否匹配</td>
</tr>
<tr>
<td align="center">Signature</td>
<td align="center">类、方法表、字段表</td>
<td align="center">用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td align="center">SourceFile</td>
<td align="center">类文件</td>
<td align="center">记录源文件名称</td>
</tr>
<tr>
<td align="center">SourceDebugExtension</td>
<td align="center">类文件</td>
<td align="center">用于存储额外的调试信息</td>
</tr>
<tr>
<td align="center">Synthetic</td>
<td align="center">类、方法表、字段表</td>
<td align="center">标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td align="center">LocalVariableTypeTable</td>
<td align="center">类</td>
<td align="center">使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td align="center">RuntimeVisibleAnnotations</td>
<td align="center">类、方法表、字段表</td>
<td align="center">为动态注解提供支持</td>
</tr>
<tr>
<td align="center">RuntimeInvisibleAnnotations</td>
<td align="center">表、方法表、字段表</td>
<td align="center">用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td align="center">RuntimeVisibleParameterAnnotation</td>
<td align="center">方法表</td>
<td align="center">作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法</td>
</tr>
<tr>
<td align="center">RuntimeInvisibleParameterAnnotation</td>
<td align="center">方法表</td>
<td align="center">作用与 RuntimeInvisibleAnnotations 属性类似，作用对象哪个为方法参数</td>
</tr>
<tr>
<td align="center">AnnotationDefault</td>
<td align="center">方法表</td>
<td align="center">用于记录注解类元素的默认值</td>
</tr>
<tr>
<td align="center">BootstrapMethods</td>
<td align="center">类文件</td>
<td align="center">用于保存 invokeddynamic 指令引用的引导方式限定符</td>
</tr>
</tbody></table>
<h5 id="部分属性详解"><a href="#部分属性详解" class="headerlink" title="部分属性详解"></a>部分属性详解</h5><ul>
<li>ConstantValue 属性</li>
</ul>
<p>ConstantValue 属性表示一个常量字段的值。位于 field_info 结构的属性表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index; <span class="comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。(例如，值是 long 型的，在常量池中便是 CONSTANT_Long)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Deprecated 属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deprecated_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Code 属性</li>
</ul>
<p>Code 属性就是存放方法体里面的代码，但是，并非所有方法表都有 Code 属性，像接口或者抽象方法，他们没有具体的方法体，因此也就不会有 Code 属性了。</p>
<p>Code 属性表的结构，如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
<td align="center">属性名索引</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
<td align="center">属性长度</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_stack</td>
<td align="center">1</td>
<td align="center">操作数栈深度的最大值</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_locals</td>
<td align="center">1</td>
<td align="center">局部变量表所需的存续空间</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">code_length</td>
<td align="center">1</td>
<td align="center">字节码指令的长度</td>
</tr>
<tr>
<td align="center">u1</td>
<td align="center">code</td>
<td align="center">code_length</td>
<td align="center">存储字节码指令</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">exception_table_length</td>
<td align="center">1</td>
<td align="center">异常表长度</td>
</tr>
<tr>
<td align="center">exception_info</td>
<td align="center">exception_table</td>
<td align="center">exception_length</td>
<td align="center">异常表</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
<td align="center">属性集合计数器</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
<td align="center">属性集合</td>
</tr>
</tbody></table>
<p>可以看到：Code 属性表的前两项跟属性表是一致的，即 Code 属性表遵循属性表的结构，后面那些则是他自定义的结构。</p>
<ul>
<li>InnerClasses 属性</li>
</ul>
<p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个 CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的 ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK 1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile 结构的属性表。</p>
<ul>
<li>LineNumberTable 属性</li>
</ul>
<p>LineNumberTable 属性是可选变长属性，位于 Code 结构的属性表。</p>
<p>LineNumberTable 属性是<strong>用来描述 Java 源码行号与字节码行号之间的对应关系</strong>，这个属性可以用来在调试的时候定位代码执行的行数。</p>
<blockquote>
<p>start_pc，即字节码行号；line_number，即 Java 源代码行号</p>
</blockquote>
<p>在 Code 属性的属性表中，LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable 属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。</p>
<p>LineNumberTable 属性表结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 line_number;</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LocalVariableTable 属性</li>
</ul>
<p>LocalVariableTable 是可选变长属性，位于 Code 属性的属性表中。它被调试器<strong>用于确定方法在执行过程中局部变量的信息。</strong>在 Code 属性的属性中，LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。</p>
<ol>
<li>start_pc + length 表示这个变量在字节码中的生命周期起始和结束的偏移位置（this 生命周期从头0到结尾10）</li>
<li>index 就是这个变量在局部变量表中的槽位（槽位可复用）</li>
<li>name 就是变量名称</li>
<li>Descriptor 表示局部变量类型描述</li>
</ol>
<p>LocalVariableTable 属性表结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Signature 属性</li>
</ul>
<p>Signature 属性是可选的定长属性，位于 ClassFile，field_info 或 method_info 结构的属性表中。在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。</p>
<ul>
<li>SourceFile 属性</li>
</ul>
<p>SourceFile 属性结构</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
<td align="center">属性名索引</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
<td align="center">属性长度</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">sourcefile_index</td>
<td align="center">1</td>
<td align="center">源码文件索引</td>
</tr>
</tbody></table>
<p>可以看到，其长度总是固定的 8 个字节。</p>
<ul>
<li>其他属性</li>
</ul>
<p>Java 虚拟机中预定义的属性有 20 多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过手动去解读字节码文件，终于大概了解到其构成和原理了。</p>
<p>实际上，我们可以使用各种工具来帮我们去解读字节码文件，而不用直接去看这些 16 进制，太繁琐了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>本章主要介绍了 Class 文件的基本格式。</p>
<p>随着 Java 平台的不断发展，在将来，Class 文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整。</p>
<p>从 Java 虚拟机的角度看，通过 Class 文件，可以让更多的计算机语言支持 Java 虚拟机平台。因此，Class 文件结构不仅仅是 Java 虚拟机的执行入口，更是 Java 生态圈的基础和核心。</p>
<h2 id="使用-javap-指令解析-Class-文件"><a href="#使用-javap-指令解析-Class-文件" class="headerlink" title="使用 javap 指令解析 Class 文件"></a>使用 javap 指令解析 Class 文件</h2><p>自己分析类文件结构太麻烦了！Oracle 提供了 javap 工具。</p>
<p>当然这些信息中，有些信息（如本地变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等）需要在使用 javac 编译成 Class 文件时，指定参数才能输出，比如，你直接 javac xx.java，就不会再生成对应的局部变量表等信息，如果你使用 javac -g xx.java 就可以生成所有相关信息了。如果你使用的是 Eclipse，则默认情况下，Eclipse 在编译时会帮你生成局部变量表、指令和代码行盘一辆映射表等信息</p>
<p>通过反编译生成的汇编代码，我们可以深入的了解 Java 代码的工作机制。比如我们看到的 i++，这行代码实际运行时是先获取变量 i 的值，然后将这个值加 1，最后再将加 1 后的值赋值给变量 i。</p>
<h3 id="解析字节码的作用"><a href="#解析字节码的作用" class="headerlink" title="解析字节码的作用"></a>解析字节码的作用</h3><p>通过反编译生成的字节码文件，我们可以深入的了解 Java 代码的工作机制。但是，自己分析类文件结构太麻烦了，除了使用第三方的 jclasslib 工具之外，Oracle 官方也提供了工具：javap。</p>
<p>javap 是 JDK 自带的反解析工具。它的作用就是根据 Class 字节码文件，反解析出当前类对应的 Code 区（字节码指令）、局部变量表、异常表和代码行偏移量映射表、常量池等信息。</p>
<p>通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。</p>
<h3 id="javac-g-操作"><a href="#javac-g-操作" class="headerlink" title="javac -g 操作"></a>javac -g 操作</h3><p>解析字节码文件得到的信息中，有些信息（如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等）需要在使用 javac 编译成 Class 文件时，指定参数才能输出。</p>
<p>比如，你直接 javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用 javac -g xx.java 就可以生成所有相关信息了。如果你使用的 Eclipse 或 IDEA，则默认情况下，Eclipse、IDEA 在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息。</p>
<h3 id="javap-的用法"><a href="#javap-的用法" class="headerlink" title="javap 的用法"></a>javap 的用法</h3><p>javap 的用法格式：javap <options> <classes></classes></options></p>
<p>其中，classes 就是你要反编译的 Class 文件。</p>
<p>在命令行中直接输入 javap 或 javap -help 可以看到 javap 的 options 有如下选项：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201020121337.png" alt="image-20201020121336503"></p>
<p>一般常用的是 -v -l -c 三个选项：</p>
<ul>
<li><p>javap -l 会输出行号和本地变量表信息</p>
</li>
<li><p>javap -c 会对当前 Class 字节码进行反编译生成汇编代码</p>
</li>
<li><p>javap -v classxx 除了包含 -c 内容外，还会输出行号、局部变量表信息、常量池等信息</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>通过 javap 命令可以查看一个 Java 类反汇编得到的 Class 文件版本号、常量池、访问标识、变量表、指令代码行号表等信息。不显式类索引、父类索引、接口索引集合、<clinit>()、<init>() 等结构。</init></clinit></p>
</li>
<li><p>通过对前面的例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作：</p>
<ol>
<li>Java 栈中：局部变量表、操作数栈</li>
<li>Java 堆： 通过对象的地址引用去操作</li>
<li>常量池</li>
<li>其他如帧数据区、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下</li>
</ol>
</li>
<li><p>平常，我们比较关注的是 Java 类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，可以参考官方文档查看每个指令含义。</p>
</li>
</ol>
<h1 id="字节码指令集与解析举例"><a href="#字节码指令集与解析举例" class="headerlink" title="字节码指令集与解析举例"></a>字节码指令集与解析举例</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Java 字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行命令。</li>
<li>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为<strong>操作码，Opcode</strong>）以及跟随其后的零至多个代表此操作所需参数（称为<strong>操作数，Operands</strong>）而构成，由于 <strong>Java 虚拟机采用面向操作数栈而不是寄存器的结构</strong>，所以大多数的指令都不包含操作数，只有一个操作码。</li>
<li>由于限制了 Java 虚拟机操作码的长度为一个字节（即 0~255），这意味着指令集的操作码总数不可能超过 256 条。</li>
<li>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></li>
<li>熟悉虚拟机的指令对于动态字节码生成、反编译 Class 文件、 Class 文件修补都有着非常重要的价值。因此，阅读字节码作为了解 Java 虚拟机的基础技能，需要熟练掌握常见指令。</li>
</ul>
<h3 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h3><p>如果不考虑异常处理的话，那么 Java 虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    自动计算 PC 寄存器的值加 <span class="number">1</span>;</span><br><span class="line">    根据 PC 寄存器的指示位置，从字节码流中取出操作码;</span><br><span class="line">    <span class="keyword">if</span>(字节码存在操作数) 从字节码流中取出操作数;</span><br><span class="line">    执行操作码所定义的操作;</span><br><span class="line">&#125;<span class="keyword">while</span>(字节码长度 &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在 Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。</p>
<p>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</strong></p>
<ul>
<li>i 代表对 int 类型的数据操作</li>
<li>l 代表 long</li>
<li>s 代表 short</li>
<li>b 代表 byte</li>
<li>c 代表 char</li>
<li>f 代表 float</li>
<li>d 代表 double</li>
</ul>
<p>也有一些指令的助记符中<strong>没有明确地指明操作类型的字母</strong>，如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</p>
<p>还有另一些指令，如无条件跳转指令 goto 则是与<strong>数据类型无关的</strong>。</p>
<p>大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译器或运行期将 byte 和short 类型的数据带符号扩展（Sign-Extend）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 init 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。</p>
<h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p>由于完全介绍和学习这些指令需要花费大量时间，为了让大家能够更快地熟悉和了解这些基本指令，这里将 JVM 中的字节码指令集按用途大致分成 9 类：</p>
<ul>
<li>加载与存储指令</li>
<li>算术指令</li>
<li>类型转换指令</li>
<li>对象的创建与访问指令</li>
<li>方法调用与返回指令</li>
<li>操作数栈管理指令</li>
<li>比较控制指令</li>
<li>异常处理指令</li>
<li>同步控制指令</li>
</ul>
<p>在做值相关操作时：</p>
<ul>
<li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用等中取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。</li>
<li>一个指令，也可以从操作数栈中取出一到多个值（pop 多次），完成赋值、加减乘除、方法传参、系统调用等操作。</li>
</ul>
<h2 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h2><ul>
<li>作用</li>
</ul>
<p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。</p>
<ul>
<li>常用指令<ul>
<li>「局部变量压栈指令」将一个局部变量加载到操作数栈：<code>xload、xload_&lt;n&gt; </code>(<code>其中 x 为 i、l、f、d、a，n 为 0 到 3</code>)；<code>xaload、xaload&lt;n&gt; </code>(<code>其 x 为 i、l、f、d、a、b、c、s，n 为 0 到 3</code>)</li>
<li>「常量入栈指令」将一个常量加载到操作数栈：<code>bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、iconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</code></li>
<li>「出栈装入局部变量表指令」将一个数值从操作数栈存储到局部变量表：<code>xstore、xstore_&lt;n&gt;</code>(<code>其中 x 为 i、l、f、d、a，n 为 0 到 3</code>); <code>xastore</code>(<code>其中 x 为 i、l、f、d、a、b、c、s</code>)</li>
<li>扩充局部变量表的访问索引的指令：<code>wide</code></li>
</ul>
</li>
</ul>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>）。这些指令助记符实际上代表了一组指令（例如<code>iload_&lt;n&gt;</code>代表了<code>iload_0、iload_1、iload_2和iload_3</code>这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如 <code>iload</code>）的特殊形式，<strong>对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</strong></p>
<p>除此之外，它们的语义与原生的通用指令完全一致（例如 <code>iload_0</code>的语义与操作数为 0 时的<code>iload</code>指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<code>&lt;n&gt;</code>代表非负的整数，<code>&lt;i&gt;</code>代表是 int 类型数据，<code>&lt;l&gt;</code>代表 long 类型，<code>&lt;f&gt;</code>代表 float 类型，<code>&lt;d&gt;</code>代表 double 类型。</p>
<p>操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示。</p>
<h3 id="复习：再谈操作数栈与局部变量表"><a href="#复习：再谈操作数栈与局部变量表" class="headerlink" title="复习：再谈操作数栈与局部变量表"></a>复习：再谈操作数栈与局部变量表</h3><ol>
<li><strong>操作数栈（Operand Stacks）</strong></li>
</ol>
<p>我们知道，Java 字节码是 Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。</p>
<p>在解释执行过程中，每当为 Java 方法分配栈帧时，Java 虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p>
<p>具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023105040.png" alt="image-20201023105038983"></p>
<p>以加法指令 iadd 为例。假设在执行该指令之前，栈顶的两个元素分别为 int 值 1 和 int 值 2，那么 iadd 指令将弹出这两个 int，并将求得的和 int 值为 3 压入栈中。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023105234.png" alt="image-20201023105233678"></p>
<p>由于 iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为 2 的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p>
<ol start="2">
<li><strong>局部变量表（Local Variables）</strong></li>
</ol>
<p>Java 方法栈帧的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p>
<p>实际上，Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p>
<p>和操作数栈一样，long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023111630.png" alt="image-20201023111629266"></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">long</span> l, <span class="type">float</span> f)</span> &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025214235.png" alt="image-20201023112230399"></p>
<p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<p>在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<h3 id="局部变量压栈指令"><a href="#局部变量压栈指令" class="headerlink" title="局部变量压栈指令"></a>局部变量压栈指令</h3><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。</p>
<p>这类指令大体可以分为：</p>
<ul>
<li><code>xload_&lt;n&gt;</code>(<code>x</code>为<code>i、l、f、d、a，n为 0 到 3</code>)</li>
<li><code>xload</code>(<code>x</code>为<code>i、l、f、d、a</code>)</li>
</ul>
<p>说明：在这里，<code>x</code>的取值表示数据类型。</p>
<p>指令<code>xload_n</code>表示将第<code>n</code>个局部变量压入操作数栈，比如<code>iload_1、fload_0、aload_0</code>等指令，其中<code>aload_n</code>表示将一个对象引用压栈。</p>
<p>指令<code>xload</code>通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了 4 个，比如指令<code>iload、fload</code>等。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025214241.png" alt="image-20201023160540950"></p>
<h3 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h3><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const 系列、push 系列和 ldc 指令。</p>
<p><strong>指令 const 系列：</strong>用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：<code>iconst_&lt;i&gt;（i 从 -1 到 5）、lconst_&lt;l&gt;（l 从 0 到 1）、fconst_&lt;f&gt;（f 从 0 到 2）、dconst_&lt;d&gt;（d 从 0 到 1）、aconst_null</code></p>
<p>比如：</p>
<ul>
<li>iconst_m1 将 -1 压入操作数栈</li>
<li>iconst_x（x 为 0 到 5）将 x 压入栈</li>
<li>lconst_0、lconst_1 分别将长整数 0 和 1 压入栈</li>
<li>fconst_0、fconst_1、fconst_2 分别将浮点数 0、1、2 压入栈</li>
<li>dconst_0 和 dconst_1 分别将 double 型 0 和 1 压入栈</li>
<li>aconst_null 将 null 压入操作数栈</li>
</ul>
<p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整型，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p>
<p><strong>指令 push 系列：</strong>主要包括 bipush 和 sipush，它们的区别在于接受数据类型的不同，bipush 接收 8 位整数作为参数，sipush 接收 16 位整数，它们都将参数压入栈。</p>
<p><strong>指令 ldc 系列：</strong>如果以上指令都不能满足需求，那么可以使用万能的 ldc 指令，它可以接收一个 8 位的参数，该参数指向常量池中的 int、float 或者 String 的索引，将指定的内容压入堆栈。</p>
<p>类似的还有 ldc_w，它接收两个 8 位参数，能支持的索引范围大于 ldc。</p>
<p>如果要压入的元素是 long 或者 double 类型的，则使用 ldc2_w 指令，使用方式都是类似的。</p>
<p>总结如下：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023162900.png" alt="image-20201023162858985"></p>
<h3 id="出栈装入局部变量表指令"><a href="#出栈装入局部变量表指令" class="headerlink" title="出栈装入局部变量表指令"></a>出栈装入局部变量表指令</h3><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。</p>
<p>这类指令主要以 store 的形式存在，比如 xstore （x 为 i、l、f、d、a）、xstore_n（x 为 i、l、f、d、a，n 为 0 至 3）和 pasture（x 为 i、l、f、d、a、b、c、s）。</p>
<ul>
<li>其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它赋值给局部变量 n。</li>
<li>指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置。</li>
<li>xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定索引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组引用，iastore 会弹出这 3 个值，并将值赋给数组中指定索引的位置。</li>
</ul>
<p>一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的元素放置在局部变量表第 1 个位置。类似的还有 istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第 0、2、3 个位置。</p>
<p>由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于 3，那么可以使用 istore 指令，外加一个参数，用来表示需要存放的槽位位置。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023163834.png" alt="image-20201023163832907"></p>
<h2 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h2><ol>
<li><strong>作用</strong></li>
</ol>
<ul>
<li>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</li>
</ul>
<ol start="2">
<li><strong>分类</strong></li>
</ol>
<ul>
<li>大体上算术指令可以分为两种：对<strong>整型数据</strong>进行运算的指令与对<strong>浮点型类型数据</strong>进行运算的指令。</li>
</ul>
<ol start="3">
<li><strong>byte、short、char 和 boolean 类型说明</strong></li>
</ol>
<ul>
<li>在每一大类中，都有针对 Java 虚拟机具体数据类型的专用算术指令。但没有直接支持 byte、short、char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理。此外，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023164337.png" alt="image-20201023164335625"></p>
<ol start="4">
<li><strong>运算时的溢出</strong></li>
</ol>
<ul>
<li>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实 Java 虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为 0 时会导致虚拟机抛出异常 ArithmeticException。</li>
</ul>
<ol start="5">
<li><strong>运算模式</strong></li>
</ol>
<ul>
<li>向最接近数舍入模式：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。</li>
<li>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。</li>
</ul>
<ol start="6">
<li><strong>NaN 值使用</strong></li>
</ol>
<ul>
<li>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。</li>
</ul>
<h3 id="所有算数指令"><a href="#所有算数指令" class="headerlink" title="所有算数指令"></a>所有算数指令</h3><p>所有算术指令包括：</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imul、lmul、fmul、dmul</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem（remainder：余数）</li>
<li>取反指令：ineg、lneg、fneg、dneg（negation：取反）</li>
<li>自增指令：iinc</li>
<li>位运算指令，又可分为：<ul>
<li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
</ul>
</li>
<li>比较指令：dcmpg、dcmlp、fcmpg、fcmpl、lcmp</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令对应的图示：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023170604.png" alt="image-20201023170603743"></p>
<h3 id="比较指令的说明"><a href="#比较指令的说明" class="headerlink" title="比较指令的说明"></a>比较指令的说明</h3><ul>
<li>比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈</li>
<li>比较指令有：dcmpg、dcmpl、fcmpg、fcmpl、lcmp<ul>
<li>与前面讲解的指令类似，首字符 d 表示 double 类型，f 表示 float，l 表示 long</li>
</ul>
</li>
<li>对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令，以 float 为例，有 fcmpg 和 fcmpl 两个指令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同</li>
<li>指令 dcmpl 和 dcmpg 也是类似的，根据其命名可以推测其含义，在此不再赘述</li>
<li>指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令</li>
</ul>
<p>举例：</p>
<p>指令 fcmpg 和 fcmpl 都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2， 栈顶顺位第 2 位元素为 v1，若 v1 &#x3D; v2，则压入 0；若 v1 &gt;  v2 则压入 1；若 v1 &lt; v2 则压入 -1。</p>
<p>两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入 1，而 fcmpl 会压入 -1。</p>
<blockquote>
<p>  数值类型的数据才可以谈大小，boolean、引用数据类型不能比较大小。</p>
</blockquote>
<h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><p>类型转换指令说明：</p>
<ol>
<li>类型转换指令可以将两种不同的数值类型进行相互转换。</li>
<li>这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理<strong>字节码指令集中数据类型相关指令</strong>无法与<strong>数据类型</strong>一一对应的问题。</li>
</ol>
<h3 id="宽化类型转换（Widening-Numeric-Conversions）"><a href="#宽化类型转换（Widening-Numeric-Conversions）" class="headerlink" title="宽化类型转换（Widening Numeric Conversions）"></a>宽化类型转换（Widening Numeric Conversions）</h3><ol>
<li><strong>转换规则</strong></li>
</ol>
<p>Java 虚拟机直接支持以下数值的宽化类型转换（Widening Numeric Conversion，小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括：</p>
<ul>
<li>从 int 类型到 long、float 或者 double 类型，对应的指令为：i2l、i2f、i2d</li>
<li>从 long 类型到 float、double 类型。对应的指令为：l2f、l2d</li>
<li>从 flaot 类型到 double 类型。对应的指令为：f2d</li>
</ul>
<p>简化为：int –&gt; long –&gt; float –&gt; double</p>
<ol start="2">
<li><strong>精度损失问题</strong><ol>
<li>宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的。</li>
<li>从 int、long 类型数值转换到 float，或者 long 类型树脂转换到 double 时，将可能发生丢失精度——可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数数值。尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致 Java 虚拟机抛出运行时异常。</li>
<li><strong>从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的</strong>，对于 byte 类型转换为 int，虚拟机并没有做实质性的转化处理，知识简单地通过操作数栈交换了两个数据。而 byte 转为 long 时，使用的是 i2l，可以看到在内部 byte 在这里已经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点：<ol>
<li>一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大增，而<strong>虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过 256 个，为了节省指令资源，将 short 和 byte 当作 int 处理也是情理之中。</strong></li>
<li>另一方面，由于局部变量表中的槽位固定为 32 位，无论是 byte 或者 short 存入局部变量表，都会占用 32 位空间。从这个角度来说，也没有必要特意区分这几种数据类型。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="窄化类型转换（Narrowing-Numeric-Conversion）"><a href="#窄化类型转换（Narrowing-Numeric-Conversion）" class="headerlink" title="窄化类型转换（Narrowing Numeric Conversion）"></a>窄化类型转换（Narrowing Numeric Conversion）</h3><ol>
<li>转换规则</li>
</ol>
<p>Java 虚拟机也直接支持以下窄化类型转换：</p>
<ul>
<li>从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2c、i2s</li>
<li>从 long 类型到 int 类型。对应的指令有：l2i</li>
<li>从 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l</li>
<li>从 double 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f</li>
</ul>
<ol start="2">
<li>精度损失问题</li>
</ol>
<p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会<strong>导致数值丢失精度。</strong></p>
<p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是 Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</p>
<ol start="3">
<li><p>补充说明</p>
<ol>
<li>当一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）的时候，将遵循以下转换规则：<ol>
<li>如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0。</li>
<li>如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T（int 或 long）的表示范围之内，那转换结果就是 v。否则，将根据 v 的符号，转换为 T 所能表示的最大或者最小正数。</li>
</ol>
</li>
<li>当一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则：</li>
</ol>
<p>通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这 3 条规则判断：</p>
<ul>
<li>如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正负零。</li>
<li>如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正负无穷大。</li>
<li>对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。</li>
</ul>
</li>
</ol>
<h2 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h2><p>Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令和类型检查指令。</p>
<h3 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h3><p>虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令</p>
<ol>
<li><strong>创建类实例的指令：</strong></li>
</ol>
<p>创建类实例的指令：new</p>
<ul>
<li>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</li>
</ul>
<ol start="2">
<li><strong>创建数组的指令：</strong></li>
</ol>
<p>创建数组的指令：newarray、anewarray、multianewarray</p>
<ul>
<li>newarray：创建基本类型数组</li>
<li>anewarray：创建引用类型数组</li>
<li>multianewarray：创建多维数组</li>
</ul>
<p>上述创建指令可以用于创建对象或者数组，由于对象和数组在 Java 中的广泛使用，这些指令的使用频率也很高。</p>
<h3 id="字段访问指令"><a href="#字段访问指令" class="headerlink" title="字段访问指令"></a>字段访问指令</h3><p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p>
<ul>
<li>访问类字段（static 字段，或者称为类变量）的指令：getstatic、putstatic</li>
<li>访问类实例字段（非 static 字段，或者称为实例变量）的指令：getfield、putfield</li>
</ul>
<p>举例：</p>
<p>以 getstatic 指令为例，它含有一个操作数，为指向常量池的 Fieldref 索引，它的作用就是获取 Fieldref 指定的对象或者值，并将其压入操作数栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 getstatic #8 &lt;java/lang/System.out&gt;</span><br><span class="line">3 ldc #9 &lt;Hello&gt;</span><br><span class="line">5 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">8 return</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023182009.png" alt="image-20201023182008186"></p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023182029.png" alt="image-20201023182028441"></p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025214304.png" alt="image-20201023182046064"></p>
<h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><p>数组操作指令主要有：xastore 和 xaload 指令。具体为：</p>
<ul>
<li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore</li>
</ul>
<p>即：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023182324.png" alt="image-20201023182323185"></p>
<ul>
<li>取数组长度的指令：arraylength<ul>
<li>该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈</li>
</ul>
</li>
</ul>
<p>说明：</p>
<ul>
<li>指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。指令 xaload 在执行时，要求操作数中栈顶元素为数组索引 i，栈顶顺位第 2 个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 a[i] 重新压入堆栈。</li>
<li>xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定索引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组饮用，iastore 会弹出这 3 个值，并将值赋给数组中指定索引的位置。</li>
</ul>
<h3 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h3><p>检查类实例或数组类型的指令：instanceof、checkcast</p>
<ul>
<li>指令 checkcast 用于检查类型强制转换是否可以进行。如果可以进行，那么 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常。</li>
<li>指令 instanceof 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。</li>
</ul>
<h2 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h2><h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic</p>
<p>以下 5 条指令用于方法调用：</p>
<ul>
<li>invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是 Java 语言中<strong>最常见的方法分派方式。</strong></li>
<li>invokeinterface 指令用于<strong>调用接口方法</strong>，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</li>
<li>invokespecial 指令用于调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器）、私有方法和父类方法</strong>。这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态派发。</li>
<li>invokestatic 指令用于调用命名<strong>类中的类方法（static 方法）</strong>，这是<strong>静态绑定</strong>的。</li>
<li>invokedynamic 调用动态绑定的方法，这个是 JDK 1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面 4 条调用指令的分派逻辑都固化在 Java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<h3 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><p>方法调用结束前，需要进行返回。方法返回指令是<strong>根据返回值的类型区分</strong>的。</p>
<ul>
<li>包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、dreturn 和 areturn。</li>
<li>另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">返回类型</th>
<th align="center">返回指令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">Int(boolean、byte、char、short)</td>
<td align="center">ireturn</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">lreturn</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">freturn</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">dreturn</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">Return</td>
</tr>
</tbody></table>
<p>举例：</p>
<p>通过 ireturn 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p>
<p>如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区。</p>
<p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p>
<h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><p>如同操作一个普通数据结构中的堆栈那样，JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p>
<p>这类指令包括如下内容：</p>
<ul>
<li>将一个或两个元素从栈顶弹出，并且直接废弃：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、du p_x2、dup2_x2</li>
<li>将栈最顶端的两个 Slot 数值位置交换：swap、Java 虚拟机没有提供交换两个 64 位数据类型（long、double）数值的指令</li>
<li>指令 nop 是一个非常特殊的指令，它的字节码为 0x00。和汇编语言中的 nop 一样，它表示什么都不做，这条指令一般可用于调试、占位等</li>
</ul>
<p>这些指令属于通用型，对栈的压入或者弹出无需知名数据类型。</p>
<p>说明：</p>
<ul>
<li>不带 _x 的指令是复制栈顶数据并压入栈顶。包括两个指令，dup 和 dup2，dup 的系数代表要复制的 Slot 个数<ul>
<li>dup 开头的指令用于复制 1 个 Slot 的数据。例如 1 个 int 或 1 个 reference 类型数据</li>
<li>dup2 开头的指令用于复制 2 个 Slot 的数据。例如 1 个 long，或 2 个 int，或 1 个 int 加 1 个 float 类型数据</li>
</ul>
</li>
<li>带 _x 的指令是复制栈顶数据并插入栈顶以下的某个位置。共有 4 个指令，dup_x1、dup2_x1、dup_x2、dup2_x2。对于带 _x 的复制插入指令，只要将指令的 dup 和 x 的系数相加，结果即为需要插入的位置。因此<ul>
<li>dup_x1 插入位置：1+1&#x3D;2，即栈顶 2 个 Slot 下面</li>
<li>dup_x2 插入位置：1+2&#x3D;3，即栈顶 3 个 Slot 下面</li>
<li>dup2_x1 插入位置：2+1&#x3D;3，即栈顶 3 个 Slot 下面</li>
<li>dup2_x2 插入位置：2+2&#x3D;4，即栈顶 4 个 Slot 下面</li>
</ul>
</li>
<li>pop：将栈顶的 1 个 Slot 数值出栈。例如 1 个 short 类型数值</li>
<li>pop2：将栈顶的 2 个 Slot 数值出栈。例如 1 个 double 类型数值，或者 2 个 int 类型数值</li>
</ul>
<h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为比较指令、条件跳转指令、比较条件跳转指令、多条件分支跳转指令、无条件跳转指令等。</p>
<h3 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h3><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p>
<p>条件跳转指令有：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull。这些指令都接收两个字节的操作数，用于计算跳转的位置（16 位符号整数作为当前位置的 offset）。</p>
<p>它们的统一含义为：<strong>弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置</strong>。</p>
<p><strong>具体说明：</strong></p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023192148.png" alt="image-20201023192147287"></p>
<p><strong>注意：</strong></p>
<ol>
<li>与前面运算规则一致</li>
</ol>
<ul>
<li>对于 boolean、byte、char、short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成。</li>
<li>对于 long、float、double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。</li>
</ul>
<ol start="2">
<li>由于各类型的比较最终都会转为 int 类型的比较操作，所以 Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的。</li>
</ol>
<h3 id="比较条件跳转指令"><a href="#比较条件跳转指令" class="headerlink" title="比较条件跳转指令"></a>比较条件跳转指令</h3><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p>
<p>这类指令有：if_icmped、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmped 和 if_acmpne</p>
<p>其中指令助记符加上 “if_” 后，以字符 “i” 开头的指令针对 int 型整数操作（也包括 short 和 byte 类型），以字符 “a” 开头的指令表示对象引用的比较。</p>
<p><strong>具体说明：</strong></p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023192854.png" alt="image-20201023192853356"></p>
<p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。<strong>如果预设条件成立，则执行跳转，否则，继续执行下一条语句。</strong></p>
<h3 id="多条件分支跳转"><a href="#多条件分支跳转" class="headerlink" title="多条件分支跳转"></a>多条件分支跳转</h3><p>多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023193136.png" alt="image-20201023193135710"></p>
<p>从助记符上看，两者都是 switch 语句的实现，它们的区别：</p>
<ul>
<li>tableswitch 要求<strong>多个条件分支值是连续的</strong>，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，<strong>因此效率比较高。</strong></li>
<li>lookupswitch 内部<strong>存放着各个离散的 case-offset 对</strong>，每次执行都要搜索全部的 case-offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址，<strong>因此效率较低。</strong></li>
</ul>
<p>指令 tableswitch 的示意图如下图所示。由于 tableswitch 的 case 值是连续的，因此只需要记录最低值和最高值，以及每一项对应的 offset 偏移量，根据给定的 index 值通过简单的计算即可直接定位到 offset。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023193704.png" alt="image-20201023193702956"></p>
<p>指令 lookupswitch 处理的是离散的 case 值，但是出于效率考虑，将 case-offset 对按照 case 值大小排序，给定 index 时，需要查找与 index 相等的 case，获得其 offset，如果找不到则跳转到 default。指令 lookupswitch 如下图所示</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025214323.png" alt="image-20201023193841932"></p>
<h3 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h3><p>目前主要的无条件跳转指令为 goto，指令 goto 接收两个字节的操作数，共同组成一个带符号的整数，<strong>用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</strong></p>
<p>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令 goto_w，它和 goto 有相同的作用，但是它接收 4 个字节的操作数，可以表示更大的地址范围。</p>
<p>指令 jsr、jsr_w、ret 虽然也是无条件跳转的，但主要用于 try-finally 语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201023194154.png"></p>
<h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><h3 id="抛出异常指令"><a href="#抛出异常指令" class="headerlink" title="抛出异常指令"></a>抛出异常指令</h3><ol>
<li>athrow 指令</li>
</ol>
<p>在 Java 程序中显式抛出异常的操作（throw 语句）都是由 athrow 指令来实现的。</p>
<p>除了使用 throw 语句显式抛出异常情况之外，<strong>JVM 规范还规定了许多运行时一场会在其它 Java 虚拟机指令检测到异常状况时自动抛出</strong>。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常。</p>
<ol start="2">
<li>注意</li>
</ol>
<p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是<strong>在抛异常时，Java 虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上</strong></p>
<p>异常及异常的处理：</p>
<p>过程一：异常对象的生成过程 —&gt; throw(手动&#x2F;自动) —&gt; 指令：athrow</p>
<p>过程二：异常的处理：抓抛模型 try-catch-finally —&gt; 使用异常表</p>
<h3 id="异常处理与异常表"><a href="#异常处理与异常表" class="headerlink" title="异常处理与异常表"></a>异常处理与异常表</h3><ol>
<li>处理异常</li>
</ol>
<p>在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（早期使用 jsr、ret 指令），而是<strong>采用异常表来完成的。</strong></p>
<ol start="2">
<li>异常表</li>
</ol>
<p>如果一个方法定义了一个 try-catch 或者 try-finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者 finally 块的信息。异常表保存了每个异常处理信息。比如：</p>
<ul>
<li>起始位置</li>
<li>结束位置</li>
<li>程序计数器记录的代码处理的偏移地址</li>
<li>被捕获的异常类在常量池中的索引</li>
</ul>
<p><strong>当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，</strong>并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个县城将终止。如果这个异常在最后一个非守护线程里抛出，将会导致 JVM 自己终止，比如这个线程是个 main 线程。</p>
<p><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。</strong>在这种情况下， 如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finally 块来完成目标。</p>
<h2 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h2><p>Java 虚拟机支持两种同步结构：<strong>方法级同步</strong> 和 <strong>方法内部一段指令序列的同步</strong>，这两种同步都是使用 monitor 来支持的。</p>
<h3 id="方法级的同步"><a href="#方法级的同步" class="headerlink" title="方法级的同步"></a>方法级的同步</h3><p>方法级的同步：是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法。</p>
<p>当调用方法时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否设置。</p>
<ul>
<li>如果设置了，执行线程将先持有同步锁，然后执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁</li>
<li>在方法执行期间，执行线程持有了同步锁，其它任何线程都无法再获得同一个锁</li>
<li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 aload_0</span><br><span class="line">1 dup</span><br><span class="line">2 getdield #2 &lt;com/atguigu/java1/SynchronizedTest.i&gt;</span><br><span class="line">5 iconst_1</span><br><span class="line">6 iadd</span><br><span class="line">7 putfield #2 &lt;com/atguigu/java1/SynchronizedTest.i&gt;</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>这段代码和普通的无同步操作的代码没有什么不同，没有使用 monitorenter 和 monitorexit 进行同步区控制。这是因为，对于同步方法而言，当虚拟机通过方法的访问标识符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter 和 monitorexit 指令是隐式存在的，并未直接出现在字节码中。</p>
<h3 id="方法内指定指令序列的同步"><a href="#方法内指定指令序列的同步" class="headerlink" title="方法内指定指令序列的同步"></a>方法内指定指令序列的同步</h3><p>同步一段指令集序列：通常是由 Java 中的 synchronized 语句块来表示的。JVM 的指令集有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义。</p>
<p>当一个线程进入同步代码块时，它使用 monitorenter 指令请求进入。如果当前对象的监视器计数器为 0，则它会被准许进入，若为 1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为 0，才会被允许进入同步块。</p>
<p>当线程退出同步块时，需要使用 monitorexit 声明退出。在 Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p>
<p>指令 monitorenter 和 monitorexit 在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</p>
<p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须执行其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。</p>
<p>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，<strong>编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常</strong>，它的目的就是用来执行 monitorexit 指令。</p>
<h1 id="类的加载过程详解"><a href="#类的加载过程详解" class="headerlink" title="类的加载过程详解"></a>类的加载过程详解</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>在 Java 中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</p>
<p>按照 Java 虚拟机规范，从 Class 文件到加载到内存中的类，到类卸载出内存位置，它的整个生命周期包括如下七个阶段：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201024111217.png" alt="image-20201024111210347"></p>
<p>其中，验证、准备、解析 3 个部分统称为链接（Linking）。</p>
<p>从程序中类的使用过程看：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201024111422.png" alt="image-20201024111420862"></p>
<h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><p>蚂蚁金服：</p>
<p>描述一下 JVM 加载 Class 文件的原理机制？</p>
<p>一面：类加载过程</p>
<p>百度：</p>
<p>类加载的机制</p>
<p>Java 类加载过程？</p>
<p>简述 Java 类加载机制？</p>
<p>腾讯：</p>
<p>JVM 中类加载机制，类加载过程？</p>
<p>滴滴：</p>
<p>JVM 类加载机制</p>
<p>美团：</p>
<p>Java 类加载过程</p>
<p>描述一下 JVM 加载 Class 文件的原理机制</p>
<h2 id="过程一：Loading（加载）阶段"><a href="#过程一：Loading（加载）阶段" class="headerlink" title="过程一：Loading（加载）阶段"></a>过程一：Loading（加载）阶段</h2><h3 id="加载完成的操作"><a href="#加载完成的操作" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h3><h4 id="加载的理解"><a href="#加载的理解" class="headerlink" title="加载的理解"></a>加载的理解</h4><p><strong>所谓加载，简而言之就是将 Java 类的字节码文件加载到机器内存中，并在内存中构建出 Java 类的原型——类模板对象。</strong>所谓类模板对象，其实就是 Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到模板中，这样 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。</p>
<p>反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p>
<h4 id="加载完成的操作-1"><a href="#加载完成的操作-1" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h4><p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成 Class 的实例。</strong></p>
<p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p>
<ul>
<li>通过类的全名，获取类的二进制数据流；</li>
<li>解析类的二进制数据流为方法区内的数据结构（Java 类模型）；</li>
<li>创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h3 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合 JVM 规范即可）</p>
<ul>
<li>虚拟机可能通过文件系统读入一个 Class 后缀的文件（最常见）</li>
<li>读入 jar、zip 等归档数据包，提取类文件</li>
<li>事先存放在数据库中的类的二进制数据</li>
<li>使用类似于 HTTP 之类的协议通过网络进行加载</li>
<li>在运行时生成一段 Class 的二进制信息等</li>
</ul>
<p>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。</p>
<p>如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p>
<h3 id="类模型与-Class-实例的位置"><a href="#类模型与-Class-实例的位置" class="headerlink" title="类模型与 Class 实例的位置"></a>类模型与 Class 实例的位置</h3><ol>
<li><strong>类模型的位置</strong></li>
</ol>
<p>加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区（JDK 1.8 之前：永久代；JDK 1.8 之后：元空间）。</p>
<ol start="2">
<li><strong>Class 实例的位置</strong></li>
</ol>
<p>类将 .class 文件加载至元空间后，会在堆中创建一个 java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p>
<ol start="3">
<li><strong>图示</strong></li>
</ol>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201024113047.png" alt="image-20201024113046003"></p>
<p>外部可以通过访问代表 Order 类的 Class 对象来获取 Order 的类数据结构。</p>
<ol start="4">
<li><strong>再说明</strong></li>
</ol>
<p>Class 类的构造方法是私有的，只有 JVM 能够创建。</p>
<p>java.lang.Class 实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过 Class 类提供的接口，可以获得目标类所关联的 .class 文件中具体的数据结构：方法、字段等信息。</p>
<h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p>
<ol>
<li><p>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型。</p>
</li>
<li><p>JVM 使用指定的元素类型和数组来创建新的数组类。</p>
<p> 如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public。</p>
</li>
</ol>
<h2 id="过程二：Linking（链接）阶段"><a href="#过程二：Linking（链接）阶段" class="headerlink" title="过程二：Linking（链接）阶段"></a>过程二：Linking（链接）阶段</h2><h3 id="环节1-链接阶段之-Verification-（验证）"><a href="#环节1-链接阶段之-Verification-（验证）" class="headerlink" title="环节1:链接阶段之 Verification （验证）"></a>环节1:链接阶段之 Verification （验证）</h3><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
<p><strong>它的目的是保证加载的字节码是合法、合理并符合规范的。</strong></p>
<p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201024114116.png" alt="image-20201024114115928"></p>
<p><strong>整体说明：</strong></p>
<p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p>
<ul>
<li>其中<strong>格式验证会和加载阶段一起执行</strong>。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li>
<li><strong>格式验证之外的验证操作将会在方法区中进行。</strong></li>
</ul>
<p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。</p>
<p><strong>具体说明：</strong></p>
<ol>
<li><strong>格式验证</strong>：是否以魔数 0xCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</li>
<li>Java 虚拟机会进行字节码的<strong>语义检查</strong>，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</li>
</ol>
<ul>
<li>是否所有的类都有父类的存在（在 Java 里，除了 Object 外，其他类都应该有父类）</li>
<li>是否一些被定义为 final 的方法或者类被重写或继承了</li>
<li>非抽象类是否实现了所有抽象方法或者接口方法</li>
<li>是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；absract 情况下的方法，就不能是 final 的了）</li>
</ul>
<ol start="3">
<li>Java 虚拟机还会进行<strong>字节码验证</strong>，字节码验证也是<strong>验证过程中最为复杂的一个过程</strong>。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</li>
</ol>
<ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
<li>函数的调用是否传递了正确类型的参数</li>
<li>变量的赋值是不是给了正确的数据类型等</li>
</ul>
<p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100% 准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p>
<p><strong>在前面 3 次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</strong></p>
<ol start="4">
<li>校验器还将进行符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的</strong>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethdError。</li>
</ol>
<p>此阶段在解析环节才会执行。</p>
<h3 id="环节2-链接阶段之-Preparation-（准备）"><a href="#环节2-链接阶段之-Preparation-（准备）" class="headerlink" title="环节2:链接阶段之 Preparation （准备）"></a>环节2:链接阶段之 Preparation （准备）</h3><p>准备阶段（Preparation），简言之，为类的静态变量分配内存，并将其初始化为默认值。</p>
<p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。</p>
<p>Java 虚拟机为各类型变量默认的初始值如表所示：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201024120659.png" alt="image-20201024120658893"></p>
<p>注意：Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故对应的，boolean 的默认值就是 false。</p>
<p>注意：</p>
<ol>
<li><strong>这里不包含基本数据类型的字段用 static final 修饰的情况，因为 final 在编译的时候就会分配了，准备阶段会显式赋值。</strong></li>
<li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li>
<li>在这个阶段不会像初始化阶段中那样会有初始化或者代码被执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 基本数据类型：非 final 修饰的变量，在准备环节进行默认初始化赋值</span></span><br><span class="line"><span class="comment"> * final 修饰以后，在准备环节直接进行显式赋值</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 拓展：如果使用字面量的方式定义一个字符串的常量的话，也是在准备环节直接进行显式赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkingTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">constStr</span> <span class="operator">=</span> <span class="string">&quot;CONST&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">constStr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;CONST&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="环节3-链接阶段之-Resolution-（解析）"><a href="#环节3-链接阶段之-Resolution-（解析）" class="headerlink" title="环节3:链接阶段之 Resolution （解析）"></a>环节3:链接阶段之 Resolution （解析）</h3><p><strong>在准备阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</strong></p>
<ol>
<li><strong>具体描述：</strong></li>
</ol>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和内存分布无关。比较容理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 <code>println()</code> 方法被调用时，系统需要明确知道该方法的位置。</p>
<p>举例：输出操作 <code>System.out.println()</code> 对应的字节码：</p>
<p><code>invokevirtual #24 &lt;java/io/PrintStream.println&gt;</code></p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201024202317.png" alt="image-20201024202315773"></p>
<p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</strong></p>
<ol start="2">
<li><strong>小结</strong></li>
</ol>
<p><strong>所谓解析就是将符号引用转为直接引用</strong>，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。</p>
<p>不过 Java 虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在 HotSpot VM 中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</p>
<ol start="3">
<li><strong>字符串的复习</strong></li>
</ol>
<p>最后，再来看一下 CONSTANT_String 的解析。由于字符串在程序开发中有着重要的作用，因此，读者有必要了解一下 String 在 Java 虚拟机中的处理。<strong>当在 Java 代码中直接使用字符串常量时，就会在类中出现 CONSTANT_String</strong>，它表示字符串常量，并且会引用一个 CONSTANT_UTF8 的常量项。<strong>在 Java 虚拟机内部运行中的常量池，会维护一张字符串拘留表（intern），它会保存所有出现过的字符串常量，并且没有重复项</strong>。只要以 CONSTANT_String 形式出现的字符串也都会在这张表中。使用 String.intern() 方法可以得到一个字符串在拘留表中的引用，因为该表中没有重复项，所以任何字面相同的字符串的 String.intern() 方法返回总是相等的。</p>
<h2 id="过程三：Initialization（初始化）阶段"><a href="#过程三：Initialization（初始化）阶段" class="headerlink" title="过程三：Initialization（初始化）阶段"></a>过程三：Initialization（初始化）阶段</h2><p><strong>初始化阶段，简言之，为类的静态变量赋予正确的初始值</strong></p>
<ol>
<li><strong>具体描述</strong></li>
</ol>
<p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行 Java 字节码。（即：到了初始化阶段，才真正开始执行类中定义的 Java 程序代码）。</p>
<p><strong>初始化阶段的重要工作是执行类的初始化方法：<code>&lt;clinit&gt;()</code> 方法。</strong></p>
<ul>
<li>该方法仅能由 Java 编译器生成并由 JVM 调用，程序开发者无法自定义一个同名的方法，更无法直接在 Java 程序中调用该方法，虽然该方法也是由字节码指令所组成。</li>
<li>它是类静态成员的赋值语句以及 static 语句块合并产生的。</li>
</ul>
<ol start="2">
<li><p>说明</p>
<ol>
<li>在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的 <code>&lt;clinit&gt;</code> 总是在子类 <code>&lt;clinit&gt;</code> 之前被调用，也就是说，父类的 static 块优先级高于子类。</li>
<li>Java 编译器并不会为所有的类都产生 <code>&lt;clinit&gt;()</code> 初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含 <code>&lt;clinit&gt;()</code> 方法？</li>
</ol>
<ul>
<li>一个类中并没有声明任何的类变量，也没有静态代码块时；</li>
<li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时；</li>
<li>一个类中包含 static final 修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式。</li>
</ul>
</li>
</ol>
<h3 id="static-与-final-的搭配问题"><a href="#static-与-final-的搭配问题" class="headerlink" title="static 与 final 的搭配问题"></a>static 与 final 的搭配问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 哪些场景下，Java 编译器就不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationTest1</span> &#123;</span><br><span class="line">  <span class="comment">//场景1:对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> num1;</span><br><span class="line">  <span class="comment">//场景3：比如对于声明为 static final 的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：使用 static + final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</span></span><br><span class="line"><span class="comment"> * 情况1：在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="comment"> * 情况2：在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 在链接阶段的准备环节赋值的情况：</span></span><br><span class="line"><span class="comment"> * 1. 对于基本数据类型的字段来说，如果使用 static final 修饰，则显式赋值（直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> * 2. 对于 String 来说，如果使用字面量的方式赋值，使用 static final 修饰的话，则显式赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在初始化阶段&lt;clinit&gt;()中赋值的情况</span></span><br><span class="line"><span class="comment"> * 排除上述的在准备环节赋值的情况之外的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最终结论：使用 static + final 修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或 String 类型的显式赋值，是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);   <span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1000</span>); <span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;helloworld0&quot;</span>; <span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;helloworld1&quot;</span>); <span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lt-clinit-gt-的线程安全性"><a href="#lt-clinit-gt-的线程安全性" class="headerlink" title="&lt;clinit&gt;() 的线程安全性"></a><code>&lt;clinit&gt;()</code> 的线程安全性</h3><p>对于 <code>&lt;clinit&gt;()</code> 方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p>
<p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。</p>
<p>正是因为函数 <code>&lt;clinit&gt;()</code> 带锁线程安全的，因此，如果一个在类的 <code>&lt;clinit&gt;()</code> 方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p>
<p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行 <code>&lt;clinit&gt;()</code> 方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p>
<h3 id="类的初始化情况：主动使用-vs-被动使用"><a href="#类的初始化情况：主动使用-vs-被动使用" class="headerlink" title="类的初始化情况：主动使用 vs 被动使用"></a>类的初始化情况：主动使用 vs 被动使用</h3><p>Java 程序对类的使用分为两种：主动使用和被动使用。</p>
<p><strong>一、主动使用</strong></p>
<p>Class 只有在必须要首次使用的时候才会被装载，Java 虚拟机不会无条件地装载 Class 类型。Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的”使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成）。</p>
<ol>
<li>当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化</li>
<li>当调用类的静态方法时，即当使用了字节码 invokestatic 指令</li>
<li>当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putsttic 指令。（对应访问变量、赋值变量操作）</li>
<li>当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forname(“com.atguigu.java.Test”)</li>
<li>当初始化子类时，如果发现其分类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄对应的类）</li>
</ol>
<p><strong>针对 5，补充说明：</strong></p>
<p>当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
</ul>
<p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</p>
<p><strong>针对 7，说明：</strong></p>
<p>JVM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 <code>public static void main(String[])</code> 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载、链接和初始化。</p>
<p><strong>二、被动使用</strong></p>
<p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化。</strong></p>
<p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</strong></p>
<ol>
<li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化</li>
</ol>
<ul>
<li>当通过子类引用父类的静态变量，不会导致子类初始化</li>
</ul>
<ol start="2">
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用变量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</li>
<li>调用 ClassLoader 类的 <code>loadClass()</code> 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li>
</ol>
<p>如果针对代码，设置参数 <code>-XX:+TraceClassLoading</code>，可以追踪类的加载信息并打印出来。</p>
<h2 id="过程四：类的-Using（使用）"><a href="#过程四：类的-Using（使用）" class="headerlink" title="过程四：类的 Using（使用）"></a>过程四：类的 Using（使用）</h2><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化 3 个类加载步骤。一旦一个类型成功经历过这 3 个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用 new 关键字为其创建对象实例。</p>
<h2 id="过程五：类的-Unloading（卸载）"><a href="#过程五：类的-Unloading（卸载）" class="headerlink" title="过程五：类的 Unloading（卸载）"></a>过程五：类的 Unloading（卸载）</h2><p><strong>一、类、类的加载器、类的实例之间的引用关系</strong></p>
<p>在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 <code>getClassLoader()</code> 方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为<strong>双向关联关系</strong>。</p>
<p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 <code>getClass()</code> 方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 Java 类都有一个静态属性 Class，它引用代表这个类的 Class 对象。</p>
<p><strong>二、类的生命周期</strong></p>
<p>当 Sample 类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p>
<p><strong>一个类何时结束生命周期，取决于代表它的 Class 对象何时结束生命周期。</strong></p>
<p><strong>三、具体例子</strong></p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201024222947.png" alt="image-20201024222946266"></p>
<p>Loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它。</p>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Sample 类的 Class 对象也结束生命周期，Sample 类在方法区内的二进制数据<strong>被卸载</strong>。</p>
<p>当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 实例（可以通过哈希码查看是否是同一个实例）。</p>
<p><strong>四、类的卸载</strong></p>
<ol>
<li>启动类加载器加载的类型在整个运行期间是不可能被卸载的（JVM 和 JSL 规范）。</li>
<li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小</li>
<li>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景(比如：很多时候用户在开发自定义类的加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)</li>
</ol>
<p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能</p>
<h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类型</strong>。</p>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收。也就是 Java 堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGI、JSP 的重加载等，否则通常是很难达成的</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是”被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
<h1 id="再谈类的加载器"><a href="#再谈类的加载器" class="headerlink" title="再谈类的加载器"></a>再谈类的加载器</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>类加载器是 JVM 执行类加载机制的前提。</p>
<p>ClassLoader 的作用：</p>
<p>ClassLoader 是 Java 的核心组件，所有的 Class 都是由 ClassLoader 进行加载的，ClassLoader 负责通过各种方式将 Class 信息的二进制数据流读入 JVM 内部，转换为一个与目标类对应的 java.lang.Class 对象实例。然后交给 Java 虚拟机进行链接、初始化等操作。因此，ClassLoader 在整个装载阶段，只能影响到类的加载，而无法通过 ClassLoader 去改变类的链接和初始化行为。至于它是否可以运行，则由 Execution Engine 决定。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025101156.png" alt="image-20201025101149277"></p>
<p>类加载器最早出现在 Java 1.0 版本中，那个时候只是单纯地为了满足 Java Applet 应用而被研发出来，但如今类加载器却在 OSGI、字节码加解密领域大放异彩。这主要归功于 Java 虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在 JVM 内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p>
<h3 id="大厂面试题-1"><a href="#大厂面试题-1" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><p><strong>蚂蚁金服：</strong></p>
<p>深入分析 ClassLoader，双亲委派机制</p>
<p>类加载器的双亲委派模型是什么？</p>
<p>一面：双亲委派机制及使用原因</p>
<p><strong>百度：</strong></p>
<p>都有哪些类加载器，这些类加载器都加载哪些文件？</p>
<p>手写一个类加载器 Demo</p>
<p>Class 的 <code>forName(&quot;java.lang.String&quot;)</code> 和 Class 的 <code>getClassLoader()</code> 的 <code>loadClass(&quot;java.lang.String&quot;)</code> 有什么区别？</p>
<p><strong>腾讯：</strong></p>
<p>什么是双亲委派模型？</p>
<p>类加载器有哪些？</p>
<p><strong>小米：</strong></p>
<p>双亲委派模型介绍一下</p>
<p><strong>滴滴：</strong></p>
<p>简单说说你了解的类加载器</p>
<p>一面：讲一下双亲委派模型，以及其优点</p>
<p>字节跳动：</p>
<p>什么事类加载器，类加载器有哪些？</p>
<p><strong>京东：</strong></p>
<p>类加载器的双亲委派模型是什么？</p>
<p>双亲委派机制可以打破吗？为什么？</p>
<h3 id="类加载的分类"><a href="#类加载的分类" class="headerlink" title="类加载的分类"></a>类加载的分类</h3><p><strong>类的加载分类：显式加载 vs 隐式加载</strong></p>
<p>Class 文件的显式加载与隐式加载的方式是指 JVM 加载 Class 文件到内存的方式。</p>
<ul>
<li>显式加载指的是在代码中通过调用 ClassLoader 加载 Class 对象，如直接使用 <code>Class.forName(name)</code> 或 <code>this.getClass().getClassLoader().loadClass()</code> 加载 Class 对象。</li>
<li>隐式加载则是不直接在代码中调用 ClassLoader 的方法加载 Class 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 Class 文件时，该类的 Class 文件中引用了另外一个类的对象，此时额外引用的类将通过 JVM 自动加载到内存中。</li>
</ul>
<p>在日常开发中以上两种方式一般会混合使用。</p>
<h3 id="类加载器的必要性"><a href="#类加载器的必要性" class="headerlink" title="类加载器的必要性"></a>类加载器的必要性</h3><p>一般情况下，Java 开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到 java.lang.ClassNotFoundException 异常或 java.lang.NoClassDeFoundError 异常时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题。</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ol>
<li>何为类的唯一性？</li>
</ol>
<p>对于任意一个类，<strong>都需要由加载它的类加载器和这个类本身一同确认其在 Java 虚拟机中的唯一性</strong>。每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。</strong>否则，即使这两个类源自同一个 Class 文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<ol start="2">
<li>命名空间</li>
</ol>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p><strong>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</strong></p>
<h3 id="类加载机制的基本特征"><a href="#类加载机制的基本特征" class="headerlink" title="类加载机制的基本特征"></a>类加载机制的基本特征</h3><p>通常类加载机制有三个基本特征：</p>
<ul>
<li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider&#x2F;ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器”邻居”间，同一类型仍然可以被加载多次，因为相互并不可见。</li>
</ul>
<h2 id="复习：类的加载器分类"><a href="#复习：类的加载器分类" class="headerlink" title="复习：类的加载器分类"></a>复习：类的加载器分类</h2><p>JVM 支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025114009.png" alt="image-20201025114008769"></p>
<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的”父类”加载器。</li>
<li>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ClassLoader parent; <span class="comment">//父类加载器</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ParentClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChildClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">    <span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p>启动类加载器（引导类加载器）</p>
<ul>
<li>这个类加载使用 C&#x2F;C++ 语言实现的，嵌套在 JVM 内部</li>
<li>它用来加载 Java 的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li>
<li>并不继承自 java.lang.ClassLoader，没有父加载器</li>
<li>出于安全考虑，Bootstrap 启动类加载器之加载包名为 java、javax、sun 等开头的类</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025114750.png"></p>
<p>使用 <code>-XX:+TraceClassLoading</code> 参数</p>
<p>启动类加载器使用 C++ 编写的？Yes！</p>
<ul>
<li>C&#x2F;C++：指针函数 &amp; 函数指针、C++ 支持多继承、更加高效</li>
<li>Java ：由 C++ 演变而来，(C++)– 版，单继承</li>
</ul>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>扩展类加载器（Extension ClassLoader）</p>
<ul>
<li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现</li>
<li>继承于 ClassLoader 类</li>
<li>父类加载器为启动类加载器</li>
<li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre&#x2F;lib&#x2F;ext 子目录下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025115134.png" alt="image-20201025115133214"></p>
<h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>应用程序类加载器（系统类加载器，AppClassLoader）</p>
<ul>
<li>Java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现</li>
<li>继承于 ClassLoader 类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li>
<li><strong>应用程序中的类加载器默认是系统类加载器</strong></li>
<li>它是用户自定义类加载器的默认父加载器</li>
<li>通过 ClassLoader 的 <code>getSystemClassLoader()</code> 方法可以获取到该类加载器</li>
</ul>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><ul>
<li>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式</li>
<li>体现 Java 语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的 JAR 包，也可以是网络上的远程资源</li>
<li>通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例不胜枚举。例如，著名的 OSGI 组件框架，再如 Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无需重新打包发布应用程序就能实现</li>
<li>同时，自定义加载器能够实现应用隔离，例如 Tomcat、Spring 等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比 C&#x2F;C++ 程序要好太多，想不修改 C&#x2F;C++ 程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡所有美好的设想</li>
<li>自定义类加载器通常需要继承于 ClassLoader</li>
</ul>
<h2 id="测试不同的类加载器"><a href="#测试不同的类加载器" class="headerlink" title="测试不同的类加载器"></a>测试不同的类加载器</h2><p>每个 Class 对象都会包含一个定义它的 ClassLoader 的一个引用。</p>
<p>获取 ClassLoader 的途径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前类的 ClassLoader</span></span><br><span class="line">clazz.getClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前线程上下文的 ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得系统的 ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用 C++ 语言编写而成的，而另外两种类加载器则是使用 Java 语言编写的。由于引导类加载器压根儿就不是一个 Java 类，因此在 Java 程序中只能打印出空值。</p>
<p>数组类的 Class 对象，不是由类加载器去创建的，而是在 Java 运行期 JVM 根据需要自动创建的。对于数组类的类加载器来说，是通过 <code>Class.getClassLoader()</code> 返回的，与数组当中元素类型的类加载器是一样的：如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">6</span>];</span><br><span class="line">System.out.println(strArr.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//运行结果：null</span></span><br><span class="line"></span><br><span class="line">ClassLoaderTest[] test = <span class="keyword">new</span> <span class="title class_">ClassLoaderTest</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//运行结果：sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] inst = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(inst.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//运行结果：null</span></span><br></pre></td></tr></table></figure>

<h2 id="ClassLoader-源码解析"><a href="#ClassLoader-源码解析" class="headerlink" title="ClassLoader 源码解析"></a>ClassLoader 源码解析</h2><p>ClassLoader 与现有类加载的关系：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025121104.png" alt="image-20201025121103649"></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器都应该继承 ClassLoader 类。</p>
<h3 id="ClassLoader-的主要方法"><a href="#ClassLoader-的主要方法" class="headerlink" title="ClassLoader 的主要方法"></a>ClassLoader 的主要方法</h3><p>抽象类 ClassLoader 的主要方法：（内部没有抽象方法）</p>
<ul>
<li><code>public final ClassLoader getParent()</code></li>
</ul>
<p>返回该类加载器的超类加载器。</p>
<ul>
<li><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code></li>
</ul>
<p>加载名称为 name 的类，返回结果为 java.lang.Class 类的实例。如果找不到类，则返回 ClassNotFountException 异常。该方法中的逻辑就是双亲委派模式的实现。</p>
<ul>
<li><code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code></li>
</ul>
<p>查找二进制名称为 name 的类，返回结果为 java.lang.Class 类的实例。这是一个受保护的方法，JVM 鼓励我们重写此方法，需要自定义加载器遵循双亲委派机制，该方法会在检查完父类加载器之后被 <code>loadClass()</code> 方法调用。</p>
<p>在 JDK 1.2 之前，在自定义类加载时，总会去继承 ClassLoader 类并重写 <code>loadClass()</code> 方法，从而实现自定义的类加载类。但是在 JDK 1.2 之后已不再建议用户去覆盖 <code>loadClass()</code> 方法，而是建议把自定义的类加载逻辑写在 <code>findClass()</code> 方法中，从前面的分析可知，<code>findClass()</code> 方法是在 <code>loadClass()</code> 方法中被调用的，当 <code>loadClass()</code> 方法中父加载器加载失败后，则会调用自己的 <code>findClass()</code> 方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委派机制。</p>
<p>需要注意的是 ClassLoader 类中并没有实现 <code>findClass()</code> 方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException 异常，同时应该知道的是 <code>findClass()</code> 方法通常是和 <code>defineClass()</code> 方法一起使用的。<strong>一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 <code>findClass()</code> 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 <code>defineClass()</code> 方法生成类的 Class 对象。</strong></p>
<ul>
<li><code>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</code></li>
</ul>
<p>根据给定的字节数组 b 转换为 Class 的实例，off 和 len 参数表示实际 Class 信息在 byte 数组中的位置和长度，其中 byte 数组 b 是 ClassLoader 从外部获取的。这是受保护的方法，只有在自定义 ClassLoader 子类中可以使用。</p>
<p><code>defineClass()</code> 方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象（ClassLoader 中已实现该方法逻辑），通过这个方法不仅能够通过 Class 文件实例化 Class 对象，也可以通过其它方式实例化 Class 对象，如通过网络中接收一个类的字节码，然后转换为 byte 字节流创建对应的 Class 对象。</p>
<p><strong><code>defineClass()</code> 方法通常与 <code>findClass()</code> 方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 <code>findClass()</code> 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 <code>defineClass()</code> 方法生成类的 Class 对象。</strong></p>
<p>简单举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="comment">//获取类的字节数组</span></span><br><span class="line">  <span class="type">byte</span>[] classData = getClassData(name);</span><br><span class="line">  <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//使用 defineClass 生成 Class 对象</span></span><br><span class="line">    <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>protected final void resolveClass(Class&lt;?&gt; c)</code></li>
</ul>
<p>链接指定的一个 Java 类。使用该方法可以使用类的 Class 对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存，并设置初始值，同时将字节码文件中的符号引用转换为直接引用。</p>
<ul>
<li><code>protected final Class&lt;?&gt; findLoadedClass(String name)</code></li>
</ul>
<p>查找名称为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例。这个方法是 final 方法，无法被修改。</p>
<ul>
<li><code>private final ClassLoader parent;</code></li>
</ul>
<p>它也是一个 ClassLoader 的实例，这个字段所表示的 ClassLoader 也称为这个 ClassLoader 的双亲。在类加载的过程中，ClassLoader 可能会将某些请求交予自己的双亲处理。</p>
<h4 id="loadClass-的剖析"><a href="#loadClass-的剖析" class="headerlink" title="loadClass() 的剖析"></a><code>loadClass()</code> 的剖析</h4><p>测试代码：</p>
<p><code>ClassLoader.getSystemClassLoader().loadClass(&quot;com.atguigu.java.User&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the class with the specified &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt;.  The</span></span><br><span class="line"><span class="comment"> * default implementation of this method searches for classes in the</span></span><br><span class="line"><span class="comment"> * following order:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to check if the class</span></span><br><span class="line"><span class="comment"> *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #loadClass(String) loadClass&#125; method</span></span><br><span class="line"><span class="comment"> *   on the parent class loader.  If the parent is &#123;<span class="doctag">@code</span> null&#125; the class</span></span><br><span class="line"><span class="comment"> *   loader built into the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #findClass(String)&#125; method to find the</span></span><br><span class="line"><span class="comment"> *   class.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If the class was found using the above steps, and the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> resolve&#125; flag is true, this method will then invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #resolveClass(Class)&#125; method on the resulting &#123;<span class="doctag">@code</span> Class&#125; object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Subclasses of &#123;<span class="doctag">@code</span> ClassLoader&#125; are encouraged to override &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getClassLoadingLock getClassLoadingLock&#125; method</span></span><br><span class="line"><span class="comment"> * during the entire class loading process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  resolve</span></span><br><span class="line"><span class="comment"> *         If &#123;<span class="doctag">@code</span> true&#125; then resolve the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The resulting &#123;<span class="doctag">@code</span> Class&#125; object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassNotFoundException</span></span><br><span class="line"><span class="comment"> *          If the class could not be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="comment">//resolve:true 加载Class的同时进行解析操作</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123; <span class="comment">//同步操作，保证只能加载一次</span></span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SecureClassLoader-与-URLClassLoader"><a href="#SecureClassLoader-与-URLClassLoader" class="headerlink" title="SecureClassLoader 与 URLClassLoader"></a>SecureClassLoader 与 URLClassLoader</h3><p>接着 SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要针对 Class 源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多的是与它的子类 URLClassLoader 有所关联。</p>
<p>前面说过，ClassLoader 是一个抽象类，很多方法是空的没有实现，比如 <code>findClass()</code>、<code>findResource()</code> 等。而 URLClassLoader 这个实现类为这些方法提供了具体的实现。并新增了 URLClassPath 类协助取得 Class 字节码流等功能。<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类</strong>，这样就可以避免自己去编写 <code>findClass()</code> 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<h3 id="ExtClassLoader-与-AppClassLoader"><a href="#ExtClassLoader-与-AppClassLoader" class="headerlink" title="ExtClassLoader 与 AppClassLoader"></a>ExtClassLoader 与 AppClassLoader</h3><p>ExtClassLoader 并没有重写 <code>loadClass()</code> 方法，这足以说明其遵循双亲委派模式，而 AppClassLoader 重载了 <code>loadClass()</code> 方法，但最终调用的还是父类 <code>loadClass()</code> 方法，因此依然遵循双亲委派模式。</p>
<h3 id="Class-forName-与-ClassLoader-loadClass"><a href="#Class-forName-与-ClassLoader-loadClass" class="headerlink" title="Class.forName() 与 ClassLoader.loadClass()"></a><code>Class.forName()</code> 与 <code>ClassLoader.loadClass()</code></h3><ul>
<li><code>Class.forName()</code>：是一个静态方法，最常用的是 <code>Class.forName(String className);</code> 根据传入的类的权限定名返回一个 Class 对象。<strong>该方法在将 Class 文件加载到内存的同时，会执行类的初始化。</strong>如：</li>
</ul>
<p><code>Class.forName(&quot;com.atguigu.java.HelloWorld&quot;);</code></p>
<ul>
<li><code>ClassLoader.loadClass()</code> 这是一个实例方法，需要一个 ClassLoader 对象来调用该方法。该方法将 Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器，如：<code>ClassLoader c1 = .....; c1.loadClass(&quot;com.atguigu.java.HelloWorld&quot;);</code></li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义与本质"><a href="#定义与本质" class="headerlink" title="定义与本质"></a>定义与本质</h3><p>类加载器用来把类加载到 Java 虚拟机中。从 JDK 1.2 版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证 Java 平台的安全。</p>
<ol>
<li>定义</li>
</ol>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<ol start="2">
<li>本质</li>
</ol>
<p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025130802.png" alt="image-20201025130801165"></p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025130824.png" alt="image-20201025130823109"></p>
<h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><ol>
<li>双亲委派机制优势</li>
</ol>
<ul>
<li>避免类的重复加载，确保一个类的全局唯一性</li>
</ul>
<p>Java 类随着它的类加载器一起具备了一种带有优先级的层级关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次。</p>
<ul>
<li>保护程序安全，防止核心 API 被随意篡改</li>
</ul>
<ol start="2">
<li>代码支持</li>
</ol>
<p>双亲委派机制在 <code>java.lang.ClassLoader.loadClass(String, boolean)</code> 接口中体现。该接口的逻辑如下：</p>
<ol>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回；</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用 <code>parent.loadClass(name, false)</code> 接口进行加载；</li>
<li>反之，如果当前加载器的父类加载器为空，则调用 <code>findBootstrapClassOrNull(name)</code> 接口，让引导类加载器进行加载；</li>
<li>如果通过以上 3 条路径都没能成功加载，则调用 <code>findClass(name)</code> 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的 native 接口加载目标 Java 类。</li>
</ol>
<p>双亲委派的模型就隐藏在第 2 和第 3 步中。</p>
<ol start="3">
<li>举例</li>
</ol>
<p>假设当前加载的是 java.lang.Object 这个类，很显然，该类属于 JDK 中核心的不能再核心的一个类，因此一定只能由引导类加载器进行加载。当 JVM 准备加载 java.lang.Object 时，JVM 默认会使用系统类加载器去加载，按照上面 5 步加载的逻辑，在第 1 步从系统类的缓存中肯定查找不到该类，于是进入第 2 步。由于从系统类加载器的父类加载器是扩展类加载器，于是扩展类加载器继续从第 1 步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第 2 步。扩展类的父加载器是 null，因此系统调用 <code>findClass(String)</code>，最终通过引导类加载器进行加载。</p>
<ol start="4">
<li>思考</li>
</ol>
<p>如果在自定义的类加载器中重写 <code>java.lang.ClassLoader.loadClass(String)</code> 或 <code>java.lang.ClassLoader.loadClass(String, boolean)</code> 方法，抹去其中的双亲委派机制，仅保留上面这 4 步中的第 1 步和第 4 步，那么是不是就能够加载核心类库了呢？</p>
<p>这也不行！因为 JDK 还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 <code>java.lang.ClassLoader.defineClass(String, byte[], int, int, ProtectionDomain)</code> 方法，而该方法会执行 <strong><code>preDefineClass()</code> 接口</strong>，该接口中提供了对 JDK 核心类库的保护。</p>
<ol start="5">
<li>双亲委派模式的弊端</li>
</ol>
<p>检查类是否加载的委派过程是单向的，这个方式虽然从结构上说比较清晰，使各个 ClassLoader 的职责非常明确，但是同时会带来一个问题，即顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<strong>应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。</strong>比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<ol start="6">
<li>结论</li>
</ol>
<p><strong>由于 Java 虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong>比如 Tomcat 中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是 Servlet 规范推荐的一种做法。</p>
<h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><h4 id="破坏双亲委派机制1"><a href="#破坏双亲委派机制1" class="headerlink" title="破坏双亲委派机制1"></a>破坏双亲委派机制1</h4><p>双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者们的类加载器实现方式。</p>
<p>在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外情况，直到 Java 模块化出现为止，双亲委派模型主要出现过 3 次较大规模”被破坏”的情况。</p>
<p>第一次破坏双亲委派机制：</p>
<p>双亲委派模型的第一次”被破坏”其实发生在双亲委派模型出现之前——即 JDK 1.2 面世以前的”远古”时代</p>
<p>由于双亲委派模型在 JDK 1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader 则在 Java 的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协，<strong>为了兼容这些已有的代码，无法再以技术手段避免 <code>loadClass()</code> 被子类覆盖的可能性</strong>，只能在 JDK 1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 <code>findClass()</code>，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 <code>loadClass()</code> 中编写代码。上节我们已经分析过 <code>loadClass()</code> 方法，双亲委派的具体逻辑就实现在这里面，按照 <code>loadClass()</code> 方法的逻辑，如果父类加载失败，会自动调用自己的 <code>findClass()</code> 方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="破坏双亲委派机制2"><a href="#破坏双亲委派机制2" class="headerlink" title="破坏双亲委派机制2"></a>破坏双亲委派机制2</h4><p>第二次破坏双亲委派机制：线程上下文类加载器</p>
<p>双亲委派模型的第二次”被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题<strong>（越基础的类由越上层的加载器进行加载）</strong>，基础类型之所以被称为”基础”，是因为它们总是作为被用户代码继承、调用的 API 存在，但程序设计往往没有绝对不变的完美规则，<strong>如果有基础类型又要调用回用户代码，那该怎么办？</strong></p>
<p>这并非是不可能出现的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器来完成加载（在 JDK 1.3 时加入到 rt.jar），肯定属于 Java 中很基础的类型了。但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其它厂商实现并部署在应用程序的 ClassPath 下的 JNDI 服务提供者接口（Service Provider Interface. SPI)）的代码，现在问题来了，<strong>启动类加载器时绝对不可能认识、加载这些代码的，那该怎么办？</strong>（SPI：在 Java 平台中，通常把核心类 rt.jar 中提供外部服务、可由应用层自行实现的接口称为 SPI）。</p>
<p>为了解决这个困境，Java 的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）。</strong>这个类加载器可以通过 java.lang.Thread 类的 <code>setContextClassLoader()</code> 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，程序就可以做一些”舞弊”的事情了。JNDI 服务使用这个线程上下文类加载器去加载所需的 SPI 服务代码。这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java 中涉及 SPI 的加载基本上都采用这种方式来完成，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。不过，当 SPI 的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的方式，在  JDK 6 时，JDK 提供了 java.util.ServiceLoader 类，以 META-INF&#x2F;Services 中的配置信息，辅以责任链模式，这才算是给 SPI 的加载提供了一种相对合理的解决方案。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025150008.png" alt="image-20201025150007226"></p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<h4 id="破坏双亲委派机制3"><a href="#破坏双亲委派机制3" class="headerlink" title="破坏双亲委派机制3"></a>破坏双亲委派机制3</h4><p>第三次破坏双亲委派机制：</p>
<p>双亲委派模型的第三次”被破坏”是由于用户对程序动态性的追求而导致的。如：<strong>代码热替换（Hot Swap）</strong>、<strong>模块热部署（Hot Deployment）</strong>等。</p>
<p>IBM 公司主导的 JSR-291（即 OSGI R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每个程序模块（OSGI 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGI 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构。</strong></p>
<p>当收到类加载请求时，OSGI 将按照下面的顺序进行类搜索：</p>
<ol>
<li><em><em>将以 java.</em> 开头的类，委派给父类加载器加载</em>*</li>
<li><strong>否则，将委派列表名单内的类，委派给父类加载器加载</strong></li>
<li>否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载</li>
<li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载</li>
<li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载</li>
<li>否则，类查找失败</li>
</ol>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的。</p>
<p>小结：</p>
<p>这里，我们使用了”被破坏”这个词来形容上述不符合双亲委派模型原则的行为，<strong>但这里”被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</strong></p>
<p>正如：OSGI 中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，<strong>认为 OSGI 中对类加载器的运用是值得学习的，完全弄懂了 OSGI 的实现，就算是掌握了类加载器的精髓。</strong></p>
<h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p>热替换是指在程序运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了 PHP 源文件，这种改动就会立即生效，而无需重启 Web 服务器。</p>
<p>但对 Java 来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在 Java 中实现这一功能的一个可行的方法就是灵活运用 ClassLoader。</p>
<p>注意：由不同 ClassLoader 加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的 ClassLoader 加载同一个类，在虚拟机内部，会认为这 2 个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025151429.png" alt="image-20201025151428041"></p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ul>
<li>保护程序安全</li>
<li>保护 Java 原生的 JDK 代码</li>
</ul>
<p><strong>Java 安全模型的核心就是 Java 沙箱（Sandbox）</strong>，什么是沙箱？沙箱就是一个限制程序运行的环境。</p>
<p>沙箱机制就是将 Java 代码<strong>限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。</strong>通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。所有的 Java 程序运行都可以指定沙箱，可以定制安全策略。</p>
<h3 id="JDK-1-0-时期"><a href="#JDK-1-0-时期" class="headerlink" title="JDK 1.0 时期"></a>JDK 1.0 时期</h3><p>在 Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱（Sandbox）机制。如下图所示 JDK 1.0 安全模型：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025152133.png" alt="image-20201025152132278"></p>
<h3 id="JDK-1-1-时期"><a href="#JDK-1-1-时期" class="headerlink" title="JDK 1.1 时期"></a>JDK 1.1 时期</h3><p>JDK 1.0 中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 JDK 1.1 版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。如下图所示 JDK 1.1 安全模型：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025152317.png" alt="image-20201025152316421"></p>
<h3 id="JDK-1-2-时期"><a href="#JDK-1-2-时期" class="headerlink" title="JDK 1.2 时期"></a>JDK 1.2 时期</h3><p>在 JDK 1.2 版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示 JDK 1.2 安全模型：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025152530.png" alt="image-20201025152529351"></p>
<h3 id="JDK-1-6-时期"><a href="#JDK-1-6-时期" class="headerlink" title="JDK 1.6 时期"></a>JDK 1.6 时期</h3><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（JDK 1.6）：</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025152834.png" alt="image-20201025152833261"></p>
<h2 id="自定义类的加载器"><a href="#自定义类的加载器" class="headerlink" title="自定义类的加载器"></a>自定义类的加载器</h2><ol>
<li>为什么要自定义类加载器？</li>
</ol>
<ul>
<li>隔离加载类</li>
</ul>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。（类的仲裁 –&gt; 类冲突）。</p>
<ul>
<li>修改类加载的方式</li>
</ul>
<p>类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点按需进行动态加载。</p>
<ul>
<li>扩展加载源</li>
</ul>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载。</p>
<ul>
<li>防止源码泄露</li>
</ul>
<p>Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
<ol start="2">
<li>常见的场景</li>
</ol>
<ul>
<li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是 Java EE 和 OSGI、JPMS 等框架。</li>
<li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li>
</ul>
<ol start="3">
<li>注意</li>
</ol>
<p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及 Java 类型转换，则加载器反而容易产生不美好的事情。在做 Java 类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p>
<ol>
<li>实现方式</li>
</ol>
<ul>
<li>Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器都应该继承 ClassLoader 类</li>
<li>在自定义 ClassLoader 的子类时候，我们常见的会有两种做法：<ul>
<li>方式一：重写 <code>loadClass()</code> 方法</li>
<li>方式二：重写 <code>findClass()</code> 方法</li>
</ul>
</li>
</ul>
<ol start="2">
<li>对比</li>
</ol>
<p>这两种方法本质上差不多，毕竟 <code>loadClass()</code> 也会调用 <code>findClass()</code>，但是从逻辑上讲我们最好不要直接修改 <code>loadClass()</code> 的内部逻辑。建议的做法是只在 <code>findClass()</code> 里重写自定义类的加载方法，根据参数指定类的名字，返回对应的 Class 对象的引用。</p>
<ul>
<li><code>loadClass()</code> 这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写 <code>loadClass()</code> 方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li>
<li>当编写好自定义类加载器后，便可以在程序中调用 loadClass() 方法来实现类加载操作。</li>
</ul>
<ol start="3">
<li>说明</li>
</ol>
<ul>
<li>其父类加载器是系统类加载器</li>
<li>JVM 中的所有类加载都会使用 <code>java.lang.ClassLoader.loadClass(String)</code> 接口（自定义类加载器并重写 <code>java.lang.ClassLoader.loadClass(String)</code> 接口的除外），连 JDK 的核心类库也不能例外</li>
</ul>
<h2 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h2><p>为了保证兼容性，JDK 9 没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动：</p>
<ol>
<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（Platform Class Loader）。可以通过 ClassLoader 的新方法 <code>getPlatformClassLoader()</code> 来获取。</li>
</ol>
<blockquote>
<p>JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无需再保留 <JAVA_HOME>\lib\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。</JAVA_HOME></p>
</blockquote>
<ol start="2">
<li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader</li>
</ol>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。</p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025154838.png" alt="image-20201025154837119"></p>
<p>如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。</p>
<ol start="3">
<li><p>在 Java 9 中，类加载器有了名称。该名称在构造方法中指定，可以通过 <code>getName()</code> 方法来获取。平台类加载器的名称是 Platform，应用类加载器的名称是 App。<strong>类加载器的名称在调试与类加载器相关的问题时会非常有用。</strong></p>
</li>
<li><p>启动类加载器现在是在 JVM 内部和 Java 类库共同协作实现的类加载器（以前是 C++ 实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回 null，而不会得到 BootClassLoader 实例。</p>
</li>
<li><p>类加载的委派关系也发生了变动</p>
</li>
</ol>
<blockquote>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责哪个模块的加载器完成加载。</p>
</blockquote>
<p><strong>双亲委派模式示意图</strong></p>
<p><img src="https://pic3.zhimg.com/v2-5221d33a65579aa32c80c04e3d08219a_b.webp" data-original="/master/2023/12/04/JVM-mid/20201025155359.png" alt="image-20201025155359046"></p>
<p>附加：</p>
<p>在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：</p>
<ul>
<li>启动类加载器负责加载的模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.base									java.security.sasl</span><br><span class="line">java.datatransfer					java.xml</span><br><span class="line">java.desktop							jdk.httpserver</span><br><span class="line">java.instrument						jdk.internal.vm.ci</span><br><span class="line">java.logging							jdk.management</span><br><span class="line">java.management						jdk.management.agent</span><br><span class="line">java.management.rmi				jdk.naming.rmi</span><br><span class="line">java.naming								jdk.net</span><br><span class="line">java.prefs								jdk.sctp</span><br><span class="line">java.rmi									jdk.unsupported</span><br></pre></td></tr></table></figure>

<ul>
<li>平台类加载器负责加载的模块</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.activation*					jdk.accessibility</span><br><span class="line">java.compiler*						jdk.charsets</span><br><span class="line">java.corba*								jdk.crypto.cryptoki</span><br><span class="line">java.scripting						jdk.crypto.ec</span><br><span class="line">java.se										jdk.dynalink</span><br><span class="line">java.se.se								jdk.incubator.httpclient</span><br><span class="line">java.security.jgss				jdk.internal.vm.compiler*</span><br><span class="line">java.smartcardio					jdk.jsobject</span><br><span class="line">java.sql									jdk.localedata</span><br><span class="line">java.sql.rowset						jdk.naming.dns</span><br><span class="line">java.transaction*					jdk.scripting.nashorn</span><br><span class="line">java.xml.bind*						jdk.security.auth</span><br><span class="line">java.xml.crypto						jdk.security.jgss</span><br><span class="line">java.xml.ws*							jdk.xml.dom</span><br><span class="line">java.xml.ws.annotation*		jdk.zipfs</span><br></pre></td></tr></table></figure>

<ul>
<li>应用程序类加载器负责加载的模块</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jdk.aot										jdk.jdeps</span><br><span class="line">jdk.attach								jdk.jdi</span><br><span class="line">jdk.compiler							jdk.jdwp.agent</span><br><span class="line">jdk.editpad								jdk.jlink</span><br><span class="line">jdk.hotspot.agent					jdk.jshell</span><br><span class="line">jdk.internal.ed						jdk.jstatd</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://huangjm0508.gitee.io">HUANG jm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://huangjm0508.gitee.io/2023/12/04/JVM-mid/">https://huangjm0508.gitee.io/2023/12/04/JVM-mid/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://huangjm0508.gitee.io" target="_blank">HUANGjm 's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/master/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://img1.baidu.com/it/u=1124169842,3402755948&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/master/2023/12/04/JVM-down/" title="JVM下篇：性能监控与调优篇"><img class="cover" src="https://img2.baidu.com/it/u=1609519678,2974733914&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="onerror=null;src='/master/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM下篇：性能监控与调优篇</div></div></a></div><div class="next-post pull-right"><a href="/master/2023/12/04/JVM-up/" title="JVM上篇：内存与垃圾回收篇"><img class="cover" src="https://img2.baidu.com/it/u=4088804987,3950260204&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="onerror=null;src='/master/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM上篇：内存与垃圾回收篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/master/2023/12/04/JVM-down/" title="JVM下篇：性能监控与调优篇"><img class="cover" src="https://img2.baidu.com/it/u=1609519678,2974733914&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-04</div><div class="title">JVM下篇：性能监控与调优篇</div></div></a></div><div><a href="/master/2023/12/04/JVM-up/" title="JVM上篇：内存与垃圾回收篇"><img class="cover" src="https://img2.baidu.com/it/u=4088804987,3950260204&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-04</div><div class="title">JVM上篇：内存与垃圾回收篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/master/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUANG jm</div><div class="author-info__description">越努力越幸运</div></div><div class="card-info-data site-data is-center"><a href="/master/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/master/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/master/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！这里是我的学习生活分享!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Class 文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">字节码文件的跨平台性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%9A%84%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">Java 的前端编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%9C%8B%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.3.</span> <span class="toc-text">透过字节码指令看代码细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9F%BA%E7%9F%B3%EF%BC%9AClass-%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">虚拟机的基石：Class 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E9%87%8C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">字节码文件里是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E4%BA%8B%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%EF%BC%88byte-code%EF%BC%89%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">什么事字节码指令（byte code）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E4%BE%9B%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">如何解读供虚拟机解释执行的二进制字节码？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.3.</span> <span class="toc-text">Class 文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AD%94%E6%95%B0%EF%BC%9AClass-%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%87%E5%BF%97"><span class="toc-number">1.3.1.</span> <span class="toc-text">魔数：Class 文件的标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">1.3.2.</span> <span class="toc-text">Class 文件版本号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9A%E5%AD%98%E6%94%BE%E6%89%80%E6%9C%89%E5%B8%B8%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">常量池：存放所有常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9A%E5%AD%98%E6%94%BE%E6%89%80%E6%9C%89%E5%B8%B8%E9%87%8F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">常量池计数器：存放所有常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">常量池表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">字面量和符号引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%A8%E9%99%90%E5%AE%9A%E5%90%8D"><span class="toc-number">1.3.3.2.1.1.</span> <span class="toc-text">全限定名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%90%8D%E7%A7%B0"><span class="toc-number">1.3.3.2.1.2.</span> <span class="toc-text">简单名称</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.3.3.2.1.3.</span> <span class="toc-text">描述符</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">常量类型和结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.3.3.2.3.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%A0%87%E8%AF%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">访问标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88"><span class="toc-number">1.3.5.</span> <span class="toc-text">类索引、父类索引、接口索引集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88%EF%BC%88Fields%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">字段表集合（Fields）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88fields-count%EF%BC%89"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">字段计数器（fields_count）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fields-%EF%BC%88%E5%AD%97%E6%AE%B5%E8%A1%A8%EF%BC%89"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">fields []（字段表）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%A0%87%E8%AF%86"><span class="toc-number">1.3.6.2.1.</span> <span class="toc-text">字段表访问标识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%90%8D%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.2.2.</span> <span class="toc-text">字段名索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.2.3.</span> <span class="toc-text">描述符索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-number">1.3.6.2.4.</span> <span class="toc-text">属性表集合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-number">1.3.7.</span> <span class="toc-text">方法表集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#methods-count%EF%BC%88%E6%96%B9%E6%B3%95%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%89"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">methods_count（方法计数器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#methods-%EF%BC%88%E6%96%B9%E6%B3%95%E8%A1%A8%EF%BC%89"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">methods[] （方法表）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97"><span class="toc-number">1.3.7.2.1.</span> <span class="toc-text">方法表访问标志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%BB%93%E5%90%88"><span class="toc-number">1.3.8.</span> <span class="toc-text">属性表结合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#attributes-count%EF%BC%88%E5%B1%9E%E6%80%A7%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%89"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">attributes_count（属性计数器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#attributes-%EF%BC%88%E5%B1%9E%E6%80%A7%E8%A1%A8%EF%BC%89"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">attributes[] （属性表）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.8.2.1.</span> <span class="toc-text">属性的通用格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.8.2.2.</span> <span class="toc-text">属性类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.8.2.3.</span> <span class="toc-text">部分属性详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.8.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.9.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-javap-%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90-Class-%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">使用 javap 指令解析 Class 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">解析字节码的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javac-g-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.</span> <span class="toc-text">javac -g 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javap-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">javap 的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">字节码指令集与解析举例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">执行模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">字节码与数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text">指令分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">加载与存储指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">复习：再谈操作数栈与局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.2.</span> <span class="toc-text">局部变量压栈指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.3.</span> <span class="toc-text">常量入栈指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E8%A3%85%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.4.</span> <span class="toc-text">出栈装入局部变量表指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">算术指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4"><span class="toc-number">2.3.1.</span> <span class="toc-text">所有算数指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">2.3.2.</span> <span class="toc-text">比较指令的说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="toc-number">2.4.</span> <span class="toc-text">类型转换指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88Widening-Numeric-Conversions%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">宽化类型转换（Widening Numeric Conversions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88Narrowing-Numeric-Conversion%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">窄化类型转换（Narrowing Numeric Conversion）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.</span> <span class="toc-text">对象的创建与访问指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.1.</span> <span class="toc-text">创建指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.2.</span> <span class="toc-text">字段访问指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.3.</span> <span class="toc-text">数组操作指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.4.</span> <span class="toc-text">类型检查指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-number">2.6.</span> <span class="toc-text">方法调用与返回指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">2.6.1.</span> <span class="toc-text">方法调用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-number">2.6.2.</span> <span class="toc-text">方法返回指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">2.7.</span> <span class="toc-text">操作数栈管理指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">2.8.</span> <span class="toc-text">控制转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">2.8.1.</span> <span class="toc-text">条件跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">2.8.2.</span> <span class="toc-text">比较条件跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC"><span class="toc-number">2.8.3.</span> <span class="toc-text">多条件分支跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="toc-number">2.8.4.</span> <span class="toc-text">无条件跳转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">2.9.</span> <span class="toc-text">异常处理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E6%8C%87%E4%BB%A4"><span class="toc-number">2.9.1.</span> <span class="toc-text">抛出异常指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="toc-number">2.9.2.</span> <span class="toc-text">异常处理与异常表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">2.10.</span> <span class="toc-text">同步控制指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%BA%A7%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">2.10.1.</span> <span class="toc-text">方法级的同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E6%8C%87%E5%AE%9A%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">2.10.2.</span> <span class="toc-text">方法内指定指令序列的同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">类的加载过程详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">大厂面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%80%EF%BC%9ALoading%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-number">3.2.</span> <span class="toc-text">过程一：Loading（加载）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.1.</span> <span class="toc-text">加载完成的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">加载的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E6%93%8D%E4%BD%9C-1"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">加载完成的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">二进制流的获取方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E-Class-%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.2.3.</span> <span class="toc-text">类模型与 Class 实例的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.2.4.</span> <span class="toc-text">数组类的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%BA%8C%EF%BC%9ALinking%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-number">3.3.</span> <span class="toc-text">过程二：Linking（链接）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E8%8A%821-%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8B-Verification-%EF%BC%88%E9%AA%8C%E8%AF%81%EF%BC%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">环节1:链接阶段之 Verification （验证）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E8%8A%822-%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8B-Preparation-%EF%BC%88%E5%87%86%E5%A4%87%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">环节2:链接阶段之 Preparation （准备）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E8%8A%823-%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8B-Resolution-%EF%BC%88%E8%A7%A3%E6%9E%90%EF%BC%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">环节3:链接阶段之 Resolution （解析）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%89%EF%BC%9AInitialization%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-number">3.4.</span> <span class="toc-text">过程三：Initialization（初始化）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E4%B8%8E-final-%E7%9A%84%E6%90%AD%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.1.</span> <span class="toc-text">static 与 final 的搭配问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-clinit-gt-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.4.2.</span> <span class="toc-text">&lt;clinit&gt;() 的线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8-vs-%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.3.</span> <span class="toc-text">类的初始化情况：主动使用 vs 被动使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%9B%9B%EF%BC%9A%E7%B1%BB%E7%9A%84-Using%EF%BC%88%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">过程四：类的 Using（使用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%BA%94%EF%BC%9A%E7%B1%BB%E7%9A%84-Unloading%EF%BC%88%E5%8D%B8%E8%BD%BD%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">过程五：类的 Unloading（卸载）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.6.1.</span> <span class="toc-text">回顾：方法区的垃圾回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">再谈类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">大厂面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.2.</span> <span class="toc-text">类加载的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">4.1.3.</span> <span class="toc-text">类加载器的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">4.1.4.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">4.1.5.</span> <span class="toc-text">类加载机制的基本特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">复习：类的加载器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">引导类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">系统类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">用户自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">测试不同的类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">4.4.</span> <span class="toc-text">ClassLoader 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassLoader-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">ClassLoader 的主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loadClass-%E7%9A%84%E5%89%96%E6%9E%90"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">loadClass() 的剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SecureClassLoader-%E4%B8%8E-URLClassLoader"><span class="toc-number">4.4.2.</span> <span class="toc-text">SecureClassLoader 与 URLClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExtClassLoader-%E4%B8%8E-AppClassLoader"><span class="toc-number">4.4.3.</span> <span class="toc-text">ExtClassLoader 与 AppClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-forName-%E4%B8%8E-ClassLoader-loadClass"><span class="toc-number">4.4.4.</span> <span class="toc-text">Class.forName() 与 ClassLoader.loadClass()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.5.1.</span> <span class="toc-text">定义与本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-number">4.5.2.</span> <span class="toc-text">优势与劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">4.5.3.</span> <span class="toc-text">破坏双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B61"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">破坏双亲委派机制1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B62"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">破坏双亲委派机制2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B63"><span class="toc-number">4.5.3.3.</span> <span class="toc-text">破坏双亲委派机制3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.4.</span> <span class="toc-text">热替换的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">4.6.</span> <span class="toc-text">沙箱安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-1-0-%E6%97%B6%E6%9C%9F"><span class="toc-number">4.6.1.</span> <span class="toc-text">JDK 1.0 时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-1-1-%E6%97%B6%E6%9C%9F"><span class="toc-number">4.6.2.</span> <span class="toc-text">JDK 1.1 时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-1-2-%E6%97%B6%E6%9C%9F"><span class="toc-number">4.6.3.</span> <span class="toc-text">JDK 1.2 时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-1-6-%E6%97%B6%E6%9C%9F"><span class="toc-number">4.6.4.</span> <span class="toc-text">JDK 1.6 时期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.7.</span> <span class="toc-text">自定义类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.7.1.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-9-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.8.</span> <span class="toc-text">Java 9 新特性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/master/2024/03/06/SkyTakeOut/" title="麦老头炸鸡"><img src="https://img1.baidu.com/it/u=3286805665,73344517&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1200&amp;h=639" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="麦老头炸鸡"/></a><div class="content"><a class="title" href="/master/2024/03/06/SkyTakeOut/" title="麦老头炸鸡">麦老头炸鸡</a><time datetime="2024-03-06T13:34:03.024Z" title="发表于 2024-03-06 21:34:03">2024-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/12/16/leetcode/" title="LeetCode刷题笔记"><img src="https://img2.baidu.com/it/u=36909932,775376129&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="LeetCode刷题笔记"/></a><div class="content"><a class="title" href="/master/2023/12/16/leetcode/" title="LeetCode刷题笔记">LeetCode刷题笔记</a><time datetime="2023-12-16T15:46:30.346Z" title="发表于 2023-12-16 23:46:30">2023-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/12/07/SpringCloudMeet/" title="SpringCloud面试篇"><img src="https://img2.baidu.com/it/u=1412736571,1141577351&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1280&amp;h=800" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="SpringCloud面试篇"/></a><div class="content"><a class="title" href="/master/2023/12/07/SpringCloudMeet/" title="SpringCloud面试篇">SpringCloud面试篇</a><time datetime="2023-12-07T08:58:25.474Z" title="发表于 2023-12-07 16:58:25">2023-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/12/07/SpringCloudSenior/" title="SpringCloud高级篇"><img src="https://img0.baidu.com/it/u=1137974169,2357129072&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="SpringCloud高级篇"/></a><div class="content"><a class="title" href="/master/2023/12/07/SpringCloudSenior/" title="SpringCloud高级篇">SpringCloud高级篇</a><time datetime="2023-12-07T08:12:23.029Z" title="发表于 2023-12-07 16:12:23">2023-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/master/2023/12/07/SpringCloudUtility/" title="SpringCloud实用篇"><img src="https://img2.baidu.com/it/u=3840651282,2081575526&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/master/img/404.jpg'" alt="SpringCloud实用篇"/></a><div class="content"><a class="title" href="/master/2023/12/07/SpringCloudUtility/" title="SpringCloud实用篇">SpringCloud实用篇</a><time datetime="2023-12-07T07:29:54.944Z" title="发表于 2023-12-07 15:29:54">2023-12-07</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By HUANG jm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/master/js/utils.js"></script><script src="/master/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>