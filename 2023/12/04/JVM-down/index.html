<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM下篇：性能监控与调优篇 | HUANGjm 's blog</title><meta name="robots" content="noindex"><meta name="author" content="HUANG jm"><meta name="copyright" content="HUANG jm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="性能调优概述大厂面试题支付宝： 1支付宝三面：JVM 性能调优都做了些什么？  小米： 12有做过 JVM 内存优化吗？从 SQL、JVM、架构、数据库四个方面讲讲优化思路  蚂蚁金服： 12345JVM 的编译优化JVM 性能调优都做了什么？JVM 诊断调优工具用过哪些？二面：JVM 怎样调优，堆内存、栈空间设置多少合适？三面：JVM 相关的分析工具使用过的有哪些？具体的性能调优步骤是什么？">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM下篇：性能监控与调优篇">
<meta property="og:url" content="https://github.com/hjianming/hjianming.github.io/2023/12/04/JVM-down/index.html">
<meta property="og:site_name" content="HUANGjm &#39;s blog">
<meta property="og:description" content="性能调优概述大厂面试题支付宝： 1支付宝三面：JVM 性能调优都做了些什么？  小米： 12有做过 JVM 内存优化吗？从 SQL、JVM、架构、数据库四个方面讲讲优化思路  蚂蚁金服： 12345JVM 的编译优化JVM 性能调优都做了什么？JVM 诊断调优工具用过哪些？二面：JVM 怎样调优，堆内存、栈空间设置多少合适？三面：JVM 相关的分析工具使用过的有哪些？具体的性能调优步骤是什么？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=1609519678,2974733914&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800">
<meta property="article:published_time" content="2023-12-04T15:36:38.953Z">
<meta property="article:modified_time" content="2024-03-14T04:01:50.029Z">
<meta property="article:author" content="HUANG jm">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=1609519678,2974733914&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/hjianming/hjianming.github.io/2023/12/04/JVM-down/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM下篇：性能监控与调优篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-14 12:01:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=1609519678,2974733914&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800')"><nav id="nav"><span id="blog-info"><a href="/" title="HUANGjm 's blog"><span class="site-name">HUANGjm 's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM下篇：性能监控与调优篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-04T15:36:38.953Z" title="发表于 2023-12-04 23:36:38">2023-12-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-14T04:01:50.029Z" title="更新于 2024-03-14 12:01:50">2024-03-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM下篇：性能监控与调优篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="性能调优概述"><a href="#性能调优概述" class="headerlink" title="性能调优概述"></a>性能调优概述</h1><h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><p>支付宝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">支付宝三面：JVM 性能调优都做了些什么？</span><br></pre></td></tr></table></figure>

<p>小米：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有做过 JVM 内存优化吗？</span><br><span class="line">从 SQL、JVM、架构、数据库四个方面讲讲优化思路</span><br></pre></td></tr></table></figure>

<p>蚂蚁金服：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM 的编译优化</span><br><span class="line">JVM 性能调优都做了什么？</span><br><span class="line">JVM 诊断调优工具用过哪些？</span><br><span class="line">二面：JVM 怎样调优，堆内存、栈空间设置多少合适？</span><br><span class="line">三面：JVM 相关的分析工具使用过的有哪些？具体的性能调优步骤是什么？</span><br></pre></td></tr></table></figure>

<p>阿里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何进行 JVM 调优？有哪些方法？</span><br><span class="line">如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？</span><br></pre></td></tr></table></figure>

<p>字节跳动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三面：JVM 如何调优、参数怎么调？</span><br></pre></td></tr></table></figure>

<p>拼多多：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从 SQL、JVM、架构、数据库四个方面讲讲优化思路</span><br></pre></td></tr></table></figure>

<p>京东：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM 诊断调优工具用过哪些？</span><br><span class="line">每秒几十万并发的秒杀系统为什么会频繁发生 GC？</span><br><span class="line">日均百万级交易系统如何优化 JVM？</span><br><span class="line">线上生产系统 OOM 如何监控及定位与解决？</span><br><span class="line">高并发系统如何基于 G1 垃圾回收器优化性能？</span><br></pre></td></tr></table></figure>

<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><h3 id="生产环境中的问题"><a href="#生产环境中的问题" class="headerlink" title="生产环境中的问题"></a>生产环境中的问题</h3><ul>
<li>生产环境繁盛了内存溢出该如何处理？</li>
<li>生产环境应该给服务器分配多少内存合适？</li>
<li>如何对垃圾回收器的性能进行调优？</li>
<li>生产环境 CPU 负载飙高该如何处理？</li>
<li>生产环境应该给应用分配多少线程合适？</li>
<li>不加 log，如何确定请求是否执行了某一行代码？</li>
<li>不加 log，如何实时查看某个方法的入参与返回值？</li>
</ul>
<h3 id="为什么要调优？"><a href="#为什么要调优？" class="headerlink" title="为什么要调优？"></a>为什么要调优？</h3><ul>
<li>防止出现 OOM</li>
<li>解决 OOM</li>
<li>减少 Full GC 出现的频率</li>
</ul>
<h3 id="不同阶段的考虑"><a href="#不同阶段的考虑" class="headerlink" title="不同阶段的考虑"></a>不同阶段的考虑</h3><ul>
<li>上线前</li>
<li>项目运行阶段</li>
<li>线上出现 OOM</li>
</ul>
<h2 id="调优概述"><a href="#调优概述" class="headerlink" title="调优概述"></a>调优概述</h2><h3 id="监控的依据"><a href="#监控的依据" class="headerlink" title="监控的依据"></a>监控的依据</h3><ul>
<li>运行日志</li>
<li>异常堆栈</li>
<li>GC 日志</li>
<li>线程快照</li>
<li>堆转储快照</li>
</ul>
<h3 id="调优的大方向"><a href="#调优的大方向" class="headerlink" title="调优的大方向"></a>调优的大方向</h3><ul>
<li>合理地编写代码</li>
<li>充分并合理地使用硬件资源</li>
<li>合理地进行 JVM 调优</li>
</ul>
<h2 id="性能优化的步骤"><a href="#性能优化的步骤" class="headerlink" title="性能优化的步骤"></a>性能优化的步骤</h2><ul>
<li>第 1 步（发现问题）性能监控：一种以非强行或入侵方式 <strong>收集或查看</strong> 应用运营性能数据的活动。监控通常是指一种在生产、质量评估或者开发环境下实施的带有 <strong>预防或主动性</strong> 的活动。当应用相关干系人提出性能问题却 <strong>没有提供足够多的线索</strong> 时，首先我们需要进行性能监控，随后是性能分析。<ul>
<li>GC 频繁</li>
<li>CPU load 过高</li>
<li>OOM </li>
<li>内存泄漏</li>
<li>死锁</li>
<li>程序响应时间较长</li>
</ul>
</li>
<li>第 2 步（排查问题）性能分析：一种以 <strong>侵入方式</strong> 收集运行性能数据的活动，它会影响应用的吞吐量或响应性。性能分析是针对性能问题的答复结果，关注的范围通常比性能监控更加集中。性能分析很少在生产环境下进行，通常是在质量评估、<strong>系统测试或者开发环境下进行</strong>，是性能监控之后的步骤。<ul>
<li>打印 GC 日志，通过 GCViewer 或者 <a target="_blank" rel="noopener" href="http://gceasy.io/">http://gceasy.io</a> 来分析日志信息</li>
<li>灵活运用命令行工具，jstack、jmap、jinfo 等</li>
<li>dump 出堆文件，使用内存分析工具分析文件</li>
<li>使用阿里 Arthas、jconsole、JVisualVM 来实时查看 JVM 状态</li>
<li>jstack 查看堆栈信息</li>
</ul>
</li>
<li>第 3 步（解决问题）性能调优：一种为改善应用响应性或吞吐量而更改参数、源代码、属性配置的活动，性能调优是在性能监控、性能分析之后的活动。<ul>
<li>适当增加内存，根据业务背景选择垃圾回收器</li>
<li>优化代码，控制内存使用</li>
<li>增加机器，分散节点压力</li>
<li>合理设置线程池线程数量</li>
<li>使用中间件提高程序效率，比如缓存，消息队列等</li>
</ul>
</li>
</ul>
<h2 id="性能评价测试指标"><a href="#性能评价测试指标" class="headerlink" title="性能评价测试指标"></a>性能评价测试指标</h2><h3 id="停顿时间（响应时间）"><a href="#停顿时间（响应时间）" class="headerlink" title="停顿时间（响应时间）"></a>停顿时间（响应时间）</h3><p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。</p>
<p>常用操作的响应时间列表：</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">响应时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">打开一个站点</td>
<td align="center">几秒</td>
</tr>
<tr>
<td align="center">数据库查询一条记录（有索引）</td>
<td align="center">十几毫秒</td>
</tr>
<tr>
<td align="center">机械磁盘一次寻址定位</td>
<td align="center">4 毫秒</td>
</tr>
<tr>
<td align="center">从机械磁盘顺序读取 1M 数据</td>
<td align="center">2 毫秒</td>
</tr>
<tr>
<td align="center">从 SSD 磁盘顺序读取 1M 数据</td>
<td align="center">0.3 毫秒</td>
</tr>
<tr>
<td align="center">从远程分布式换成 Redis 读取一个数据</td>
<td align="center">0.5 毫秒</td>
</tr>
<tr>
<td align="center">从内存读取 1M 数据</td>
<td align="center">十几微秒</td>
</tr>
<tr>
<td align="center">Java 程序本地方法调用</td>
<td align="center">几微秒</td>
</tr>
<tr>
<td align="center">网络传输 2Kb 数据</td>
<td align="center">1 微妙</td>
</tr>
</tbody></table>
<p>在垃圾回收环节中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</span><br><span class="line">-XX:MaxGCPauseMillis</span><br></pre></td></tr></table></figure>

<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>对单位时间内完成的工作量（请求）的量度。在 GC 中：运行用户代码的时间占总运行时间的比例（总运行时间：程序的运行时间 + 内存回收的时间）。</p>
<p>吞吐量为 1-1&#x2F;(1+n)。<code>-XX:GCTimeRatio=n</code>。</p>
<h3 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h3><p>同一时刻，对服务器有实际交互的请求数。</p>
<h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><p>Java 堆区所占的内存大小。</p>
<h3 id="相互间的关系"><a href="#相互间的关系" class="headerlink" title="相互间的关系"></a>相互间的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以高速公路通行状况为例：</span><br><span class="line"></span><br><span class="line">吞吐量：每天通过高速公路收费站的车辆的数据</span><br><span class="line"></span><br><span class="line">并发数：高速公路上正在行驶的车辆的数目</span><br><span class="line"></span><br><span class="line">响应时间：车速</span><br></pre></td></tr></table></figure>

<h1 id="JVM监控及诊断工具-命令行篇"><a href="#JVM监控及诊断工具-命令行篇" class="headerlink" title="JVM监控及诊断工具-命令行篇"></a>JVM监控及诊断工具-命令行篇</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p>
<p>Java 作为最流行的编程语言之一，其应用性能诊断一直收到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络 I&#x2F;O、垃圾收集等。想要定位这些问题，一款非常优秀的性能诊断工具必不可少。</p>
<p>体会一：使用数据说明问题，使用知识分析问题，使用工具处理问题。</p>
<p>体会二：无监控、不调优。</p>
<h3 id="简单命令行工具"><a href="#简单命令行工具" class="headerlink" title="简单命令行工具"></a>简单命令行工具</h3><p>在我们刚接触 Java 学习的时候，大家肯定最先了解的两个命令就是 javac、java，那么除此之外，还有没有其他的命令可以供我们使用呢？我们进入到安装 JDK 的 bin 目录，发现还有一系列辅助工具。这些辅助工具用来获取目标 JVM 不同方面、不同层次的信息，帮助开发人员很好地解决 Java 应用程序的一些疑难杂症。</p>
<h2 id="jps：查看正在运行的-Java-进程"><a href="#jps：查看正在运行的-Java-进程" class="headerlink" title="jps：查看正在运行的 Java 进程"></a>jps：查看正在运行的 Java 进程</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>jps（Java Process Status）：显示指定系统内所有的 HotSpot 虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p>
<p>说明：对于本地虚拟机进程来说，进程的本地虚拟机 ID 与操作系统的进行 ID 是一致的，是唯一的。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><code>jps [options] [hostid]</code></p>
<p><strong>options 参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-q：仅仅显示 LVMID（local virtual machine id），即本地虚拟机唯一 ID。不显式主类的名称等</span><br><span class="line"></span><br><span class="line">-l：输出应用程序主类的全类名或如果进程执行的是 jar 包，则输出 jar 完整路径</span><br><span class="line"></span><br><span class="line">-m：输出虚拟机进程启动时传递给主类 main() 的参数</span><br><span class="line"></span><br><span class="line">-v：列出虚拟机进程启动时的 JVM 参数。比如：-Xms20m -Xmx50m 是启动程序指定的 JVM 参数</span><br><span class="line"></span><br><span class="line">说明：以上参数可以综合使用。</span><br><span class="line"></span><br><span class="line">补充：如果某 Java 进程关闭了默认开启的 UsePerfData 参数（即使用参数 -XX:-UsePerfData），那么 jps 命令（以及下面介绍的 jstat）将无法探知该 Java 进程。</span><br></pre></td></tr></table></figure>

<p><strong>hostid 参数</strong></p>
<p>RMI 注册表中注册的主机名。<br>如果想要远程监控主机上的 Java 程序，需要安装 jstatd。</p>
<p>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络访问，尽管 <strong>这种技术容易受到 IP 地址欺诈攻击。</strong></p>
<p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行 jstatd 服务器，而是在本地使用 jstat 和 jps 工具。</p>
<h2 id="jstat：查看-JVM-统计信息"><a href="#jstat：查看-JVM-统计信息" class="headerlink" title="jstat：查看 JVM 统计信息"></a>jstat：查看 JVM 统计信息</h2><h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><p>jstat（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。</p>
<p>在没有 GUI 图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p><code>jstat -&lt;option&gt; [t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p>
<p>查看命令相关参数：<code>jstat -h</code>或<code>jstat -help</code></p>
<p><strong>option 参数</strong></p>
<p>选项 option 可以由以下值构成：</p>
<ul>
<li>类装载相关的<ul>
<li>-class：显示 ClassLoader 的相关信息，类的装载、卸载数量、总空间、类装载所消耗的时间等。</li>
</ul>
</li>
<li>垃圾回收相关的<ul>
<li>-gc：显示与 GC 相关的堆信息。包括 Eden 区、两个 Survivor 区、老年代、永久代等的容量、已用空间、GC 时间合计等信息。</li>
<li>-gccapacity：显示内容与 -gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间。</li>
<li>-gcutil：显示内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比。</li>
<li>-gccause：与 -gcutil 功能一样，但是会额外输出导致最后一次或当前正在发生的 GC 产生的原因。</li>
<li>-gcnew：显示新生代 GC 状况。</li>
<li>-gcnewcapacity：显示内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间。</li>
<li>-geold：显示老年代 GC 状况。</li>
<li>-gcoldcapacity：显示内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间。</li>
<li>-gcpermcapacity：显示永久代使用到的最大、最小空间。</li>
</ul>
</li>
<li>JIT 相关的<ul>
<li>-compiler：显示 JIT 编译器编译过的方法、耗时等信息。</li>
<li>-printcomilation：输出已经被 JIT 编译的方法。</li>
</ul>
</li>
</ul>
<p>新生代相关：</p>
<ul>
<li>S0C 是第一个幸存者区的大小（字节）</li>
<li>S1C 是第二个幸存者区的大小（字节）</li>
<li>S0U 是第一个幸存者区已使用的大小（字节）</li>
<li>S1U 是第二个幸存者区已使用的大小（字节）</li>
<li>EC 是 Eden 空间的大小（字节）</li>
<li>EU 是 Eden 空间已使用大小（字节）</li>
</ul>
<p>老年代相关：</p>
<ul>
<li>OC 是老年代的大小（字节）</li>
<li>OU 是老年代已使用的大小（字节）</li>
</ul>
<p>方法区（元空间）相关：</p>
<ul>
<li>MC 是方法区的大小</li>
<li>MU 是方法区已使用的大小</li>
<li>CCSC 是压缩类空间的大小</li>
<li>CCSU 是压缩类空间已使用的大小</li>
</ul>
<p>其他：</p>
<ul>
<li>YGC 是指从应用程序启动到采样时 Young GC 次数</li>
<li>YGCT 是指从应用程序启动到采样时 Young GC 消耗的时间（秒）</li>
<li>FGC 是指从应用程序启动到采样时 Full GC 次数</li>
<li>FGCT 是指从应用程序启动到采样时 Full GC 消耗的时间（秒）</li>
<li>GCT 是指从应用程序启动到采样时 GC 的总时间</li>
</ul>
<p><strong>interval 参数</strong></p>
<p>用于指定输出统计数据的周期，单位为毫秒。即：查询间隔。</p>
<p><strong>count 参数</strong></p>
<p>用于指定查询的总次数。</p>
<p><strong>-t 参数</strong></p>
<p>可以在输出信息前加上一个 Timestamp 列，显示程序的运行时间。单位：秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们可以比较 Java 进程的启动时间以及总 GC 时间（GCT 列），或者两次测量的间隔时间以及总 GC 时间的增量，来得出 GC 时间占运行时间的比例。</span><br><span class="line"></span><br><span class="line">如果该比例超过 20%，则说明目前堆的压力较大；如果该比例超过 90%，则说明堆里几乎没有可用空间，随时都可能抛出 OOM 异常。</span><br></pre></td></tr></table></figure>

<p><strong>-h 参数</strong></p>
<p>可以在周期性数据输出时，输出多少行数据后输出一个表头信息。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>jstat 还可以用来判断是否出现内存泄漏。</p>
<ul>
<li>第 1 步：在长时间运行的 Java 程序中，我们可以运行 jstat 命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</li>
<li>第 2 步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</li>
</ul>
<h2 id="jinfo：实时查看和修改-JVM-配置参数"><a href="#jinfo：实时查看和修改-JVM-配置参数" class="headerlink" title="jinfo：实时查看和修改 JVM 配置参数"></a>jinfo：实时查看和修改 JVM 配置参数</h2><h3 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h3><p>jinfo（Configuration Info for Java）：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。</p>
<p>在很多情况下，Java 应用程序不会指定所有的 Java 虚拟机参数。而此时，开发人员可能不知道某一个具体的 Java 虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但是有了 jinfo 工具，开发人员可以很方便地找到 Java 虚拟机参数的当前值。</p>
<img src="/master/2023/12/04/JVM-down/MyBlog\source\_posts\img\image-20220506174227578.png" alt="image-20220506174227578" style="zoom:67%;">

<p>官方帮助文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html">https://docs.oracle.com/en/java/javase/11/tools/jinfo.html</a></p>
<h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><p><code>jinfo [options] pid</code></p>
<p>说明：Java 进程 ID 必须要加上。</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">选项说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">no option</td>
<td align="center">输出全部的参数和系统属性</td>
</tr>
<tr>
<td align="center">-flag name</td>
<td align="center">输出对应名称的参数</td>
</tr>
<tr>
<td align="center">-flag [+-] name</td>
<td align="center">开启或关闭对应名称的参数，只有被标记为 manageable 的参数才可以被动态修改</td>
</tr>
<tr>
<td align="center">-flag name&#x3D;value</td>
<td align="center">设定对应名称的参数</td>
</tr>
<tr>
<td align="center">-flags</td>
<td align="center">输出全部的参数</td>
</tr>
<tr>
<td align="center">-sysprops</td>
<td align="center">输出系统属性</td>
</tr>
</tbody></table>
<p><strong>查看</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jinfo -sysprops PID：可以查看由 System.getProperties() 取得的参数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jinfo -flags PID：查看曾经赋过值的一些参数。</span><br><span class="line"></span><br><span class="line">jinfo -flag 具体参数 PID：查看某个 Java 进程的具体参数的值。</span><br></pre></td></tr></table></figure>

<p><strong>修改</strong></p>
<p>jinfo 不仅可以查看运行时某一个 Java 虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。但是，并非所有参数都支持动态修改。参数只有被标记为 manageable 的 flag 可以被实时修改。其实，这个修改能力是极其有限的。</p>
<img src="/master/2023/12/04/JVM-down/MyBlog\source\_posts\img\image-20220506175130045.png" alt="image-20220506175130045" style="zoom:67%;">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">针对 boolean 类型：jinfo -flag[+|-] 具体参数 PID。</span><br><span class="line"></span><br><span class="line">针对非 boolean 类型：jinfo -flag 具体参数=具体参数值 PID。</span><br></pre></td></tr></table></figure>

<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial：查看所有 JVM 参数启动的初始值。</span><br><span class="line"></span><br><span class="line">java -XX:+PrintFlagsFinal：查看所有 JVM 参数的最终值。</span><br><span class="line"></span><br><span class="line">java -XX:+PrintCommandLineFlags：查看那些已经被用户或者 JVM 设置过的详细的 XX 参数的名称和值。</span><br></pre></td></tr></table></figure>

<h2 id="jmap：导出内存映像文件-amp-内存使用的情况"><a href="#jmap：导出内存映像文件-amp-内存使用的情况" class="headerlink" title="jmap：导出内存映像文件&amp;内存使用的情况"></a>jmap：导出内存映像文件&amp;内存使用的情况</h2><h3 id="基本情况-3"><a href="#基本情况-3" class="headerlink" title="基本情况"></a>基本情况</h3><p>jmap（JVM Memory Map）：作用一方面是获取 dump 文件（堆转储快照文件，二进制文件），它还可以获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等。</p>
<p>开发人员可以在控制台输入命令 <code>jmap -help</code> 查阅 jmap 工具的具体使用方式和一些标准选项配置。</p>
<p>官方帮助文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">https://docs.oracle.com/en/java/javase/11/tools/jmap.html</a></p>
<h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h3><p>它的基本使用语法为：</p>
<p><code>jmap [option] &lt;pid&gt;</code></p>
<p><code>jmap [option] &lt;executable &lt;core&gt;&gt;</code></p>
<p><code>jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</code></p>
<p>其中 option 包括：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-dump</td>
<td align="center">生成 dump 文件</td>
</tr>
<tr>
<td align="center">-finalizerinfo</td>
<td align="center">以 ClassLoader 为统计口径输出永久代的内存状态信息</td>
</tr>
<tr>
<td align="center">-heap</td>
<td align="center">输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息、以及内存的使用信息等</td>
</tr>
<tr>
<td align="center">-histo</td>
<td align="center">输出堆空间中对象的统计信息，包括类、实例数量和合计容量</td>
</tr>
<tr>
<td align="center">-permstat</td>
<td align="center">以 ClassLoader 为统计口径输出永久代的内存状态信息</td>
</tr>
<tr>
<td align="center">-F</td>
<td align="center">当虚拟机进程对 -dump 选项没有任何响应时，强制执行生成 dump 文件</td>
</tr>
</tbody></table>
<p>说明：这些参数和 Linux 下输入显示的命令多少会有不同，包括也受 JDK 版本的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-dump：生成 Java 堆转储快照：dump 文件，特别的：-dump:live 只保存堆中的存活对象。</span><br><span class="line"></span><br><span class="line">-heap：输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息，以及内存的使用信息等。</span><br><span class="line"></span><br><span class="line">-histo：输出堆中对象的统计信息，包括类、实例数量和合计容量。特别的，-histo:live 只统计堆中的存活对象。</span><br><span class="line"></span><br><span class="line">-permstat：以 ClassLoader 为统计口径输出永久代的内存状态信息，仅 Linux/Solaris 平台有效。</span><br><span class="line"></span><br><span class="line">-finalizerinfo：显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象，仅 Linux/Solaris 平台有效。</span><br><span class="line"></span><br><span class="line">-F：当虚拟机进程对 -dump 选项没有任何响应时，可使用此选项强制执行生成 dump 文件，仅 Linux/Solaris 平台有效。</span><br><span class="line"></span><br><span class="line">-h | -help：jmap 工具使用的帮助命令。</span><br><span class="line"></span><br><span class="line">-j&lt;flag&gt;：传递参数给 jmap 启动的 JVM。</span><br></pre></td></tr></table></figure>

<h3 id="使用-1：导出内存映像文件"><a href="#使用-1：导出内存映像文件" class="headerlink" title="使用 1：导出内存映像文件"></a>使用 1：导出内存映像文件</h3><p>一般来说，使用 jmap 指令生成 dump 文件的操作算得上是最常用的 jmap 命令之一，将堆中所有存货对象导出至一个文件之中。</p>
<p>Heap Dump 又叫做堆转储文件，指一个 Java 进程在某个时间点的内存快照。Heap Dump 在触发内存快照的时候会保存此刻的信息如下：</p>
<p><code>All Object</code>：<code>Class, fields, primitive, values and reference</code></p>
<p><code>All Classes</code>：<code>ClassLoader, name, super class, static fields</code></p>
<p><code>Garbage Collection Roots</code>：<code>Objects defined to be reachable by the JVM</code></p>
<p><code>Thread Stacks and Local Variables</code>：<code>The call-stacks of threads at the moment of the snapshot, and per-frame information about local objects</code></p>
<p>说明：</p>
<ol>
<li>通常在写 Heap Dump 文件前会触发一次 Full GC，所以 Heap Dump 文件里保存的都是 Full GC 后留下的对象信息。</li>
<li>由于生成 dump 文件比价耗时，因此大家需要耐心等待，尤其是大内存镜像生成 dump 文件则需要耗费更长的时间来完成。</li>
</ol>
<ul>
<li>手动的方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=&lt;filename.hprof&gt;&lt;pid&gt;</span><br><span class="line"></span><br><span class="line">jmap -dump:live,format=b,file=&lt;filename.hprof&gt;&lt;pid&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>自动的方式</li>
</ul>
<p>当程序发生 OOM 退出系统时，一些瞬时信息都随着程序的终止而消失，而重现 OOM 问题往往比较困难或者耗时。此时若能在 OOM 时，自动导出 dump 文件就显得十分迫切。</p>
<p>这里介绍一种比较常用的取得堆快照文件的方法，即使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError：在程序发生 OOM 时，导出应用程序的当前堆快照。</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath=&lt;filename.hprof&gt;：可以指定堆快照的保存位置。</span><br><span class="line"></span><br><span class="line">例如： -Xmx100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\m.hprof</span><br></pre></td></tr></table></figure>

<h3 id="使用-2：显示堆内存相关信息"><a href="#使用-2：显示堆内存相关信息" class="headerlink" title="使用 2：显示堆内存相关信息"></a>使用 2：显示堆内存相关信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap PID</span><br><span class="line"></span><br><span class="line">jmap -histo PID</span><br></pre></td></tr></table></figure>

<h3 id="使用-3：其他作用"><a href="#使用-3：其他作用" class="headerlink" title="使用 3：其他作用"></a>使用 3：其他作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -permstat PID：查看系统的 ClassLoader 信息。</span><br><span class="line"></span><br><span class="line">jmap -finalizerinfo：查看堆积在 finalizer 队列中的对象</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由于 jmap 将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap 需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由 jmap 导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p>
<p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么 :live 选项将无法探知到这些对象。</p>
<p>另外，如果某个线程长时间无法跑到安全点，jmap 将一直等下去。与前面讲得 jstat 则不同，垃圾回收器会主动将 jstat 所需要的摘要数据保存至固定位置中，而 jstat 只需直接读取即可。</p>
<h2 id="jhat：JDK-自带堆分析工具"><a href="#jhat：JDK-自带堆分析工具" class="headerlink" title="jhat：JDK 自带堆分析工具"></a>jhat：JDK 自带堆分析工具</h2><h3 id="基本情况-4"><a href="#基本情况-4" class="headerlink" title="基本情况"></a>基本情况</h3><p>jhat（JVM Heap Analysis Tool）：Sun JDK 提供的 jhat 命令与 jmap 命令搭配使用，用于分析 jmap 生成的 Heap Dump 文件（堆转储快照）。jhat 内置了一个微型的 HTTP&#x2F;HTML 服务器，生成 dump 文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）。</p>
<p>使用了 jhat 命令，就启动了一个 HTTP 服务器，端口是 7000，即 <a target="_blank" rel="noopener" href="http://localhost:7000/%E3%80%82">http://localhost:7000/。</a></p>
<p>说明：jhat 命令在 JDK 9、JDK 10 中已经被删除，官方建议使用 VisualVM 代替。</p>
<h3 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">option 参数：</span><br><span class="line"></span><br><span class="line">-stack false|true：关闭|打开对象分配调用栈跟踪</span><br><span class="line"></span><br><span class="line">-refs false|true：关闭|打开对象引用跟踪</span><br><span class="line"></span><br><span class="line">-port port-number：设置 jhat HTTP Server 的端口号，默认 7000</span><br><span class="line"></span><br><span class="line">-exclude exclude-file：执行对象查询时需要排除的数据成员列表文件</span><br><span class="line"></span><br><span class="line">-baseline exclude-file：指定一个基准堆转储</span><br><span class="line"></span><br><span class="line">-debug int：设置 debug 级别</span><br><span class="line"></span><br><span class="line">-version：启动后显示版本信息就退出</span><br><span class="line"></span><br><span class="line">-j&lt;flag&gt;：传入启动参数，比如 -j -Xmx512m</span><br></pre></td></tr></table></figure>

<h2 id="jstack：打印-JVM-中线程快照"><a href="#jstack：打印-JVM-中线程快照" class="headerlink" title="jstack：打印 JVM 中线程快照"></a>jstack：打印 JVM 中线程快照</h2><h3 id="基本情况-5"><a href="#基本情况-5" class="headerlink" title="基本情况"></a>基本情况</h3><p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p>
<p>生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用 jstack 显示各个线程调用的堆栈情况。</p>
<p>官方帮助文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html%E3%80%82">https://docs.oracle.com/en/java/javase/11/tools/jstack.html。</a></p>
<p>在 Thread Dump 中，要留意下面几种状态：</p>
<ul>
<li>死锁，Deadlock（重点关注）</li>
<li>等待资源，Waiting on condition（重点关注）</li>
<li>等待获取监视器，Waiting on monitor entry（重点关注）</li>
<li>阻塞，Blocked（重点关注）</li>
<li>执行中，Runnable</li>
<li>暂停，Suspended</li>
<li>对象等待中，Object.wait() 或 TIMED_WAITING</li>
<li>停止，Parked</li>
</ul>
<h3 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a>基本语法</h3><img src="/master/2023/12/04/JVM-down/MyBlog\source\_posts\JVM\image-20220506192000733.png" alt="image-20220506192000733" style="zoom:67%;">

<p>它的基本使用语法为：</p>
<p><code>jstack option PID</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jstack 管理远程进程的话，需要在远程程序的启动参数中增加：</span><br><span class="line"></span><br><span class="line">-Djava.rmi.server.hostname=&quot;hostname&quot;</span><br><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">-Dcom.sun.management.jmxremote.port=8888</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">option 参数：</span><br><span class="line"></span><br><span class="line">-F：当正常输出的请求不被响应时，强制输出线程堆栈</span><br><span class="line"></span><br><span class="line">-l：除堆栈外，显示关于锁的附加信息</span><br><span class="line"></span><br><span class="line">-m：如果调用到本地方法的话，可以显示 C/C++ 的堆栈</span><br><span class="line"></span><br><span class="line">-h：帮助操作</span><br></pre></td></tr></table></figure>

<h2 id="jcmd：多功能命令行"><a href="#jcmd：多功能命令行" class="headerlink" title="jcmd：多功能命令行"></a>jcmd：多功能命令行</h2><h3 id="基本情况-6"><a href="#基本情况-6" class="headerlink" title="基本情况"></a>基本情况</h3><p>在 JDK 1.7 以后，新增了一个命令行工具 jcmd。它是一个多功能的工具，可以用来实现前面除了 jstat 之外所有命令的功能。比如：用它来导出堆、内存使用、查看 Java 进程、导出线程信息、执行 GC、JVM 运行时间等。</p>
<p>官方帮助文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">https://docs.oracle.com/en/java/javase/11/tools/jcmd.html</a></p>
<p>jcmd 拥有 jmap 的大部分功能，并且在 Oracle 的官方网站上也推荐使用 jcmd 命令代替 jmap 命令。</p>
<h3 id="基本语法-6"><a href="#基本语法-6" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jcmd -l：列出所有的 JVM 进程</span><br><span class="line"></span><br><span class="line">jcmd PID help：针对指定的进程，列出支持的所有命令</span><br><span class="line"></span><br><span class="line">jcmd PID 具体命令：显示指定进程的指令命令的数据</span><br></pre></td></tr></table></figure>

<p>你可以探索 jcmd 中的下述功能，看看有没有适合你项目的监控项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Compiler.CodeHeap_Analytics</span><br><span class="line">Compiler.codecache</span><br><span class="line">Compiler.codelist</span><br><span class="line">Compiler.directives_add</span><br><span class="line">Compiler.directives_clear</span><br><span class="line">Compiler.directives_print</span><br><span class="line">Compiler.directives_remove</span><br><span class="line">Compiler.queue</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.finalizer_info</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.heap_info</span><br><span class="line">GC.run</span><br><span class="line">GC.run_finalization</span><br><span class="line">VM.class_hierarchy</span><br><span class="line">VM.classloader_stats</span><br><span class="line">VM.classloaders</span><br><span class="line">VM.command_line</span><br><span class="line">VM.dynlibs</span><br><span class="line">VM.flags</span><br><span class="line">VM.info</span><br><span class="line">VM.log</span><br><span class="line">VM.metaspace</span><br><span class="line">VM.native_memory</span><br><span class="line">VM.print_touched_methods</span><br><span class="line">VM.set_flag</span><br><span class="line">VM.stringtable</span><br><span class="line">VM.symboltable</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.systemdictionary</span><br><span class="line">VM.unlock_commercial_features</span><br><span class="line">VM.uptime</span><br><span class="line">VM.version</span><br></pre></td></tr></table></figure>

<h2 id="jstatd：远程主机信息收集"><a href="#jstatd：远程主机信息收集" class="headerlink" title="jstatd：远程主机信息收集"></a>jstatd：远程主机信息收集</h2><p>之前的指令只涉及到监控本机的 Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如 jps、jstat）。为了启用远程监控，则需要配合使用 jstatd 工具。</p>
<p>命令 jstatd 是一个 RMI 服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd 服务器将本机的 Java 应用程序信息传递到远程计算机。</p>
<img src="/master/2023/12/04/JVM-down/MyBlog\source\_posts\img\image-20220506193716253.png" alt="image-20220506193716253" style="zoom:67%;">

<h1 id="JVM监控及诊断工具-GUI篇"><a href="#JVM监控及诊断工具-GUI篇" class="headerlink" title="JVM监控及诊断工具-GUI篇"></a>JVM监控及诊断工具-GUI篇</h1><h2 id="工具概述"><a href="#工具概述" class="headerlink" title="工具概述"></a>工具概述</h2><p>使用上一章命令行工具或组合能帮您获取目标 Java 应用性能相关的基础信息，但它们存在下列局限：</p>
<ol>
<li>无法获取方法级别的分析数据，如方法间的调用关系，各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</li>
<li>要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</li>
<li>分析数据通过终端输出，结果展示不够直观。</li>
</ol>
<p>为此，JDK 提供了一些内存泄漏的分析工具，如 JConsole、jVisual VM 等，用于辅助开发人员定位问题，但这些工具很多时候并不足以满足快速定位的需求，所以这里我们介绍的工具相对多一些、丰富一些。</p>
<p>图形化综合诊断工具：</p>
<ul>
<li><p>JDK 自带的工具</p>
<ul>
<li><p>JConsole：JDK 自带的可视化监控工具、查看 Java 应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等。</p>
<p>位置：jdk\bin\JConsole.exe</p>
</li>
<li><p>Visual VM：Visual VM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机上运行的基于 Java 技术的应用程序的详细信息。</p>
<p>位置：jdk\bin\jvisualvm.exe</p>
</li>
<li><p>JVM：Java Mission Control，内置 Java Flight Recorder，能够以极低的性能开销收集 Java 虚拟机的性能数据。</p>
</li>
</ul>
</li>
<li><p>第三方工具</p>
<ul>
<li>MAT：MAT（Memory Analyzer Tool）是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java Heap 分析工具，它可以帮助我们查看内存泄漏和减少内存消耗。</li>
<li>JProfiler：商业软件，需要付费，功能强大。</li>
<li>Arthas：Alibaba 开源的 Java 诊断工具。</li>
<li>Btrace：Java 运行时追踪工具，可以在不停机的情况下，跟踪指定的方法调用、构造函数调用和系统内存等信息。</li>
</ul>
</li>
</ul>
<h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><ul>
<li>从 Java 5 开始，在 JDK 中自带的 Java 监控和管理控制台。</li>
<li>用于对 JVM 中内存、线程和类等的监控，是一个基于 JMX（Java Management Extensions）的 GUI 性能监控工具。</li>
</ul>
<p>官方教程：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/JConsole.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/JConsole.html</a></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>jdk&#x2F;bin 目录下，启动 JConsole.exe 即可，不需要使用 jps 命令来查询。</p>
<h3 id="三种连接方式"><a href="#三种连接方式" class="headerlink" title="三种连接方式"></a>三种连接方式</h3><ul>
<li>Local：使用 JConsole 连接一个正在本地系统运行的 JVM，并且执行程序的和运行 JConsole 的需要是同一个用户，JConsole 使用文件系统的授权通过 RMI 连接器连接到平台的 MBean 服务器上。这种从本地连接的监控能力只有 Sun 的 JDK 具有。</li>
<li>Remote：使用下面的 URL 通过 RMI 连接器连接到一个 JMX 代理，service:jmx:rmi:&#x2F;&#x2F;&#x2F;jndi&#x2F;rmi:&#x2F;&#x2F;hostName:portNum&#x2F;jmxrmi。JConsole 为建立连接，需要在环境变量中设置 mx.remote.credentials 来指定用户名和密码，从而进行授权。</li>
<li>Advanced：使用一个特殊的 URL 连接 JMX 代理。一般情况使用自己定制的连接器而不是 RMI 提供的连接器来连接 JMX 代理，或者是一个使用 JDK 1.4 的实现了 JMX 和 JMX Remote 的应用。</li>
</ul>
<h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h3><ul>
<li>监控内存</li>
<li>监控线程</li>
<li>监控死锁</li>
<li>类加载与虚拟机信息</li>
</ul>
<h2 id="Visual-VM"><a href="#Visual-VM" class="headerlink" title="Visual VM"></a>Visual VM</h2><h3 id="基本概述-1"><a href="#基本概述-1" class="headerlink" title="基本概述"></a>基本概述</h3><p>Visual VM 是一个功能强大的多合一故障诊断和性能监控的可视化工具。</p>
<p>它继承了多个 JDK 命令行工具，使用 Visual VM 可用于显示虚拟机进程及进程的配置和环境信息（jps、jinfo），监视应用程序的 CPU、GC、堆、方法区及线程的信息（jstat、jstack）等，甚至代替 JConsole。</p>
<p>在 JDK 6 update 7 以后，Visual VM 便作为 JDK 的一部分发布（Visual VM 在 JDK&#x2F;bin 目录下）。</p>
<p>此外，Visual VM 也可以作为独立的软件安装。首页：<a target="_blank" rel="noopener" href="https://visualvm.github.io/index.html">https://visualvm.github.io/index.html</a></p>
<h3 id="插件的安装"><a href="#插件的安装" class="headerlink" title="插件的安装"></a>插件的安装</h3><p>Visual VM 的一大特点是支持插件扩展，并且插件安装非常方便。我们既可以通过离线下载插件文件 *.nbm，然后在 Plugin 对话框的已下载页面下，添加已下载的插件。也可以在可用插件页面下，在线安装插件。插件地址：<a target="_blank" rel="noopener" href="https://visualvm.github.io/pluginscenters.html">https://visualvm.github.io/pluginscenters.html</a></p>
<p>IDEA 安装 Visual VM Launcher 插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Preferences --&gt; Plugins --&gt; 搜索 Visual VM Launcher，安装重启即可。</span><br></pre></td></tr></table></figure>

<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>本地连接：监控本地 Java 进程的 CPU、类、线程等。</p>
<p>远程连接：</p>
<ol>
<li>确定远程服务器的 IP 地址</li>
<li>添加 JMX（通过 JMX 技术具体监控远端服务器哪个 Java 进程）</li>
<li>修改 bin&#x2F;catalina.sh 文件，连接远程的 Tomcat</li>
<li>在 ..&#x2F;conf 中添加 jmxremote.access 和 jmxremote.password 文件</li>
<li>将服务器地址改为公网 IP 地址</li>
<li>设置阿里云安全策略和防火墙策略</li>
<li>启动 Tomcat，查看 Tomcat 启动日志和端口监听</li>
<li>JMX 中输入端口号、用户名、密码登录</li>
</ol>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>生成&#x2F;读取堆内存快照</li>
<li>查看 JVM 参数和系统属性</li>
<li>查看运行中的虚拟机进程</li>
<li>生成&#x2F;读取线程快照</li>
<li>程序资源的实时监控</li>
<li>其他功能：<ol>
<li>JMX 代理连接</li>
<li>远程环境监控</li>
<li>CPU 分析和内存分析</li>
</ol>
</li>
</ol>
<h2 id="Eclipse-MAT"><a href="#Eclipse-MAT" class="headerlink" title="Eclipse MAT"></a>Eclipse MAT</h2><h3 id="基本概述-2"><a href="#基本概述-2" class="headerlink" title="基本概述"></a>基本概述</h3><p>MAT（Memory Analyzer Tool）工具是一款功能强大的 Java 堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。</p>
<p>MAT 是基于 Eclipse 开发的，不仅可以单独使用，还可以作为插件的形式嵌入在 Eclipse 中使用，是一款免费的性能分析工具，使用起来非常方便。可以在 <a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a> 下载并使用 MAT。</p>
<h3 id="获取堆-dump-文件"><a href="#获取堆-dump-文件" class="headerlink" title="获取堆 dump 文件"></a>获取堆 dump 文件</h3><p><strong>dump 文件内容</strong></p>
<p>MAT 可以分析 Heap dump 文件。在进行内存分析时，只要获得了反映当前设备内存映像的 hprof 文件，通过 MAT 打开就可以直观地看到当前的内存信息。</p>
<p>一般来说：这些内存信息包含：</p>
<ul>
<li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li>
<li>所有的类信息，包括 ClassLoader、类名称、父类、静态变量等。</li>
<li>GCRoot 到所有的这些对象的引用路径。</li>
<li>线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）。</li>
</ul>
<p><strong>两点说明</strong></p>
<p>说明 1：</p>
<p>MAT 不是一个万能的工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun、HP、SAP 所采用的 HPROF 二进制堆存储文件。以及 IBM 的 PHD 堆存储文件等都能被很好地解析。</p>
<p>说明 2：</p>
<p>最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。虽然 MAT 有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从 MAT 展现给我们的信息当中通过经验和直觉来判断才能发现。</p>
<p><strong>获取 dump 文件</strong></p>
<p>方法一：通过前一章介绍的 jmap 工具生成，可以生成任意一个 Java 进程的 dump 文件；</p>
<p>方法二：通过配置 JVM 参数生成</p>
<ul>
<li>选项”<code>-XX:+HeapDumpOnOutOfMemoryError</code>“或”<code>-XX:+HeapDumpBeforeFullGC</code>“</li>
<li>选项”<code>-XX:HeapDumpPath</code>“所代表的含义就是当程序出现 OutOfMemory 时，将会在相应的目录下生成一份 dump 文件。如果不指定选项”<code>XX:HeapDumpPath</code>“则在当前目录下生成 dump 文件。</li>
</ul>
<p>对比：考虑到生产环境中几乎不可能在线对其进行分析，大家都是采用离线分析，因此使用 jmap+MAT 工具是最常见的组合。</p>
<p>方法三：使用 Visual VM 可以导出堆 dump 文件。</p>
<p>方法四：使用 MAT 既可以打开一个已有的堆快照，也可以通过 MAT 直接从活动 Java 程序中导出堆快照。该功能将借助 jps 列出当前正在运行的 Java 进程，以供选择并获取快照。</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220513113547589.png" alt="image-20220513113547589"></p>
<h3 id="分析堆-dump-文件"><a href="#分析堆-dump-文件" class="headerlink" title="分析堆 dump 文件"></a>分析堆 dump 文件</h3><p><strong>histogram</strong></p>
<p>展示了各个类的实例数目以及这些实例的 Shallow Heap 或 Retained Heap 的总和。</p>
<p>MAT 的直方图和 jmap 的 -histo 子命令一样，都能够展示各个类的实例数目以及这些实例的 Shallow Heap 总和。但是，MAT 的直方图还能够计算 Retained Heap，并支持基于实例数目或 Retained Heap 的排序方式（默认为 Shallow Heap）。</p>
<p>此外，MAT 还可以将直方图中的类按照超类、类加载器或者包名分组。</p>
<p>当选中某个类时，MAT 界面左上角的 Inspector 窗口将展示该类的 Class 实例的相关信息，如类加载器等。</p>
<p><strong>Thread Overview</strong></p>
<ul>
<li>查看系统中的 Java 线程</li>
<li>查看局部变量的信息</li>
</ul>
<p><strong>获得对象相互引用的关系</strong></p>
<ul>
<li>with outgoing references</li>
<li>with incoming references</li>
</ul>
<p><strong>浅堆与深堆</strong></p>
<ul>
<li><p>Shallow Heap</p>
<p>浅堆（Shallow Heap）是指一个对象所消耗的内存。在 32 位系统中，一个对象引用会占据 4 个字节，一个 int 类型会占据 4 个字节，long 型变量会占据 8 个字节，每个对象头需要占用 8 个字节。根据堆快照格式不同，对象的大小可能会向 8 字节进行对齐。 </p>
<p>以 String 为例：2 个 int 值共占 8 字节，对象引用占用 4 字节，对象头 8 字节，合计 20 字节，向 8 字节对齐，故占 24 字节。（JDK 7 中）</p>
<p>这 24 字节为 String 对象的浅堆大小。它与 String 的 value 实际取值无关，无论字符串长度如何，浅堆大小始终是 24 字节。</p>
</li>
<li><p>Retained Heap</p>
<p>保留集（Retained Set）：</p>
<p>对象 A 的保留集指当对象 A 被垃圾回收后，可以被释放的所有对象集合（包括对象 A 本身），即对象 A 的保留集可以被认为是只能通过对象 A 被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象 A 所持有的对象的集合。</p>
<p>深堆（Retained Heap）：</p>
<p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p>
<p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p>
</li>
<li><p>对象实际大小</p>
<p>另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受。但实际上，这个概念和垃圾回收无关。</p>
<p>下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。那么对象 A 的浅堆大小只是 A 本身，不含 C 和 D，而 A 的实际大小为A、C、D 三者之和。而 A 的深堆大小为 A 与 D 之和，由于对象 C 还可以通过对象 B 访问到，因此不在对象 A 的深堆范围内。</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220513115746866.png" alt="image-20220513115746866"></p>
</li>
<li><p>练习</p>
<p>看图理解 Retained Size</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220513115845005.png" alt="image-20220513115845005"></p>
<p>上图中，GC Roots 直接引用了 A 和 B 两个对象。</p>
<p>A 对象的 Retained Size&#x3D;A 对象的 Shallow Size</p>
<p>B 对象的 Retained Size&#x3D;B 对象的 Shallow Size + C 对象的 Shallow Size</p>
<p>这里不包括 D 对象，因为 D 对象被 GC Roots 直接引用。</p>
</li>
<li><p>支配树（Dominator Tree）</p>
<p>支配树的概念源自图论。</p>
<p>MAT 提供了一个称为支配树（Dominator Tree）的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象 B 的路径都经过对象 A，则认为对象 A 支配对象 B。如果对象 A 是离对象 B 最近的一个支配对象，则认为对象 A 为对象 B 的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：</p>
<ul>
<li>对象 A 的子树（所有被对象 A 支配的对象集合）表示对象 A 的保留集（Retained Set），即深堆。</li>
<li>如果对象 A 支配对象 B，那么对象 A 的直接支配者也支配对象 B。</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
<p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象 A 和 B 由根对象直接支配，由于在到对象 C 的路径中，可以经过 A，也可以经过 B，因此对象 C 的直接支配者也是根对象。对象 F 与对象 D 相互引用，因为到对象 F 的所有路径必然经过对象 D，因此，对象 D 是对象 F 的直接支配者。而到对象 D 的所有路径中，必然经过对象 C，即使是从对象 F 到对象 D 的引用，从根节点出发，也是经过对象 C 的，所以，对象 D 的直接支配者为对象 C。</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220513121457201.png" alt="image-20220513121457201"></p>
<p>同理，对象 E 支配对象 G。到达对象 H 的可以通过对象 D，也可以通过对象 E，因此对象 D 和 E 都不能支配对象 H，而经过对象 C 既可以到达 D 也可以到达 E，因此对象 C 为对象 H 的直接支配者。</p>
<p>在 MAT 中，单击工具栏上的对象支配树按钮，可以打开对象支配树视图。</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220513121643751.png" alt="image-20220513121643751"></p>
<p>下图显示了对象支配树视图的一部分。该截图显示部分 Lily 学生的 history 队列的直接支配对象。即当 Lily 对象被回收，也会一并回收的所有对象。显然能被 3 或者 5 整除的网页不会出现在该列表中，因为它们同时被另外两名学生对象引用。</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220513121813229.png" alt="image-20220513121813229"></p>
</li>
</ul>
<h2 id="再谈内存泄漏"><a href="#再谈内存泄漏" class="headerlink" title="再谈内存泄漏"></a>再谈内存泄漏</h2><h3 id="内存泄露的理解与分类"><a href="#内存泄露的理解与分类" class="headerlink" title="内存泄露的理解与分类"></a>内存泄露的理解与分类</h3><p><strong>何为内存泄漏（Memory Leak）</strong></p>
<p><img src="/master/2023/12/04/JVM-down/image-20220513152746452.png" alt="image-20220513152746452"></p>
<p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况，由于代码的实现不同就会出现很多种内存泄漏问题（让 JVM 误以为此对象还在引用中，无法回收，造成内存泄漏）。</p>
<p><strong>内存泄漏（Memory Leak）的理解</strong></p>
<p>严格来说，只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 OOM，也可以叫做宽泛意义上的”内存泄漏”。</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220513153747796.png" alt="image-20220513153747796"></p>
<p>对象 X 引用对象 Y，X 的生命周期比 Y 的生命周期长，那么当 Y 生命周期结束的时候，X 依然引用着 Y，这时候，垃圾回收器是不会回收对象 Y 的；如果对象 X 还引用着生命周期比较短的 A、B、C，对象 A 又引用着对象 A、B、C，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<p><strong>内存泄漏和内存溢出的关系</strong></p>
<ol>
<li><p>内存泄漏（Memory Leak）</p>
<p>申请了内存用完了不释放，比如一共有 1024M 的内存，分配了 521M 的内存一直不回收，那么可以用的内存只有 521M 了，仿佛泄漏掉了一部分。</p>
</li>
<li><p>内存溢出（Out Of Memory）</p>
<p>申请内存时，没有足够的内存可以使用。</p>
</li>
</ol>
<p>可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。</p>
<p><strong>泄漏的分类</strong></p>
<p>经常发生：发生内存泄露的代码会被多次执行，每次执行，泄漏一块内存；</p>
<p>偶尔发生：在某些特定情况下才会发生；</p>
<p>一次性：发生内存泄漏的方法只会执行一次；</p>
<p>隐式泄漏：一直占着内存不释放，直到执行结束；严格地说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</p>
<h3 id="Java-中内存泄漏的-8-种情况"><a href="#Java-中内存泄漏的-8-种情况" class="headerlink" title="Java 中内存泄漏的 8 种情况"></a>Java 中内存泄漏的 8 种情况</h3><ol>
<li><p>静态集合类</p>
<p>静态集合类，如 HashMap、LinkedList 等等。如果这些容器为静态的，那么它们的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">comTests</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例模式</p>
<p>单例模式，和静态集合导致内存泄漏的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部独享也不会被回收，那么就会造成内存泄漏。</p>
</li>
<li><p>内部类持有外部类</p>
<p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
</li>
<li><p>各种连接，如数据库连接、网络连接和 IO 连接等</p>
<p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用 close 方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。</p>
<p>否则，如果在访问数据库的过程中，对 Connection、Statement 或 ResultSet 不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 异常日志</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 1.关闭结果集 Statement</span></span><br><span class="line">        <span class="comment">// 2.关闭声明的对象 ResultSet</span></span><br><span class="line">        <span class="comment">// 3.关闭连接 Connection</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量不合理的作用域</p>
<p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为 null，很有可能导致内存泄漏发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsingRandom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        readFromNet(); <span class="comment">// 从网络中接受数据保存到 msg 中</span></span><br><span class="line">        saveDB(); <span class="comment">// 把 msg 保存到数据库中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面这个伪代码，通过 readFromNet 方法把接受的消息保存在变量 msg 中，然后调用 saveDB 方法把 msg 的内容保存到数据库中，此时 msg 已经就没有用了，由于 msg 的生命周期与对象的生命周期相同，此时 msg 还不能回收，因此造成了内存泄漏。</p>
<p>实际上这个 msg 变量可以放在 receiveMsg 方法内部，当方法使用完，那么 msg 的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。</p>
</li>
<li><p>改变哈希值</p>
<p>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p>
<p>否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏。</p>
<p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把 String 当做 HashMap 的 key 值。</p>
<p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可改变。</p>
</li>
<li><p>缓存泄露</p>
<p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，它就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
<p>对于这个问题，可以使用 WeakHashMap 代表缓存，此种 Map 的特点是，当除了自身有对 key 的引用外，此 key 没有其他引用那么此 map 会自动丢弃此值。</p>
</li>
<li><p>监听器和回调</p>
<p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的 API 中注册回调，却没有显示的取消，那么就会积聚。</p>
<p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为 WeakHashMap 中的键。</p>
</li>
</ol>
<h3 id="支持使用-OQL-语言查询对象信息"><a href="#支持使用-OQL-语言查询对象信息" class="headerlink" title="支持使用 OQL 语言查询对象信息"></a>支持使用 OQL 语言查询对象信息</h3><p>MAT 支持一种类似于 SQL 的查询语言 OQL（Object Query Language），OQL 使用类 SQL 语法，可以在堆中进行对象的查找和筛选。</p>
<p><strong>SELECT 子句</strong></p>
<p>在 MAT 中，SELECT 子句的格式与 SQL 基本一致，用于指定要显示的列，SELECT 子句中可以使用”*”，查看结果对象的引用实例（相当于 outgoing reference）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></table></figure>

<p>使用”OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> objects v.elementData <span class="keyword">FROM</span> java.util.Vector v</span><br><span class="line"><span class="keyword">SELECT</span> objects s.value <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p>在 SELECT 子句中，使用”AS RETAINED SET”关键字可以得到所得对象的保留集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AS</span> RETAINED <span class="keyword">SET</span> <span class="operator">*</span> <span class="keyword">FROM</span> com.atguigu.mat.Student</span><br></pre></td></tr></table></figure>

<p>“DISTINCT” 关键字用于在结果集中去除重复对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> OBJECTS classof(s) <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p><strong>FROM 子句</strong></p>
<p>FROM 子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p>下列使用正则表达式，限定搜索范围，输出所有 com.atguigu 包下所有类的实例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> &quot;com\.atguigu\..&quot;</span><br></pre></td></tr></table></figure>

<p>也可以直接使用类的地址进行搜索。使用类的地址的好处是可以区分被不同 ClassLoader 加载的同一种类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="number">0x37a0b4d</span></span><br></pre></td></tr></table></figure>

<p><strong>WHERE 子句</strong></p>
<p>WHERE 子句用于指定 OQL 的查询条件。OQL 查询将只返回满足 WHERE 子句指定条件的对象。WHERE 子句的格式与传统 SQL 极为相似。</p>
<p>下例返回长度大于 10 的 char 数组。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="type">char</span>[] s <span class="keyword">WHERE</span> s.lenght <span class="operator">&gt;</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>下例返回所有 value 域不为 null 的字符串，使用”&#x3D;”操作符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> s.value <span class="operator">!=</span> <span class="keyword">null</span> </span><br></pre></td></tr></table></figure>

<p>WHERE 子句支持多个条件的 AND、OR 运算。下例返回数组长度大于 15，并且深堆大于 1000 字节的所有 Vector 对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v <span class="keyword">WHERE</span> v.elementData.<span class="variable">@length</span> <span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">AND</span> v.<span class="variable">@retainedHeapSize</span> <span class="operator">&gt;</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p><strong>内置对象与方法</strong></p>
<p>OQL 中可以访问堆内对象的属性，也可以访问堆内代理对象的属性，访问堆内对象的属性时，格式如下：</p>
<p><code>[&lt;alias&gt;.] &lt;field&gt;.&lt;field&gt;.&lt;field&gt;</code>，其中 alias 为对象名称。</p>
<p>访问 java.io.File 对象的 path 属性，并进一步访问 path 的 value 属性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> toString(f.path.value) <span class="keyword">FROM</span> java.io.File f</span><br></pre></td></tr></table></figure>

<p>下例显示了 String 对象的内容、objectId 和 objectAddress：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.toString(), s.<span class="variable">@objectId</span>, s.<span class="variable">@objectAddress</span> <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></table></figure>

<p>下例显示了 java.util.Vector 内部数组的长度：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> v.elementData.<span class="variable">@length</span> <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></table></figure>

<p>下例显示了所有的 java.util.Vector 对象及其子类型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INSTANCEOF java.util.Vector</span><br></pre></td></tr></table></figure>

<h2 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h2><h3 id="基本概述-3"><a href="#基本概述-3" class="headerlink" title="基本概述"></a>基本概述</h3><p><strong>介绍</strong></p>
<p>在运行 Java 的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在 Eclipse 里面有 Eclipse Memory Analyzer Tool（MAT）插件可以测试，而在 IDEA 中也有这么一个插件，就是 JProfiler。</p>
<p>JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p>
<p>官网下载地址：<a target="_blank" rel="noopener" href="https://www.ej-technologies.com/products/jprofiler/overview.html">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p>
<p><strong>特点</strong></p>
<ul>
<li>使用方便、界面操作友好（简单且强大）</li>
<li>对被分析的应用影响小（提供模板）</li>
<li>CPU、Thread、Memory 分析功能尤其强大</li>
<li>支持对 JDBC、NoSQL、JSP、Servlet、Socket 等进行分析</li>
<li>支持多种模式（离线、在线）的分析</li>
<li>支持监控本地、远程的 JVM</li>
<li>跨平台，拥有多种操作系统的安装版本</li>
</ul>
<p><strong>主要功能</strong></p>
<ol>
<li>方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法。</li>
<li>内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄漏问题，优化内存使用。</li>
<li>线程和锁：JProfiler 提供多种针对线程和锁的分析视图助您发现多线程问题。</li>
<li>高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于 JDBC 调用，您可能希望找出执行最慢的 SQL 语句。JProfiler 支持对这些子系统进行集成分析。</li>
</ol>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><p><strong>下载与安装</strong></p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://www.ej-technologies.com/download/jprofiler/version_100">https://www.ej-technologies.com/download/jprofiler/version_100</a></p>
<img src="/master/2023/12/04/JVM-down/MyBlog\source\_posts\img\image-20220514084020810.png" alt="image-20220514084020810" style="zoom:67%;">

<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p><strong>数据采集方式</strong></p>
<p>JProfiler 数据采集方式分为两种：Sampling（样本采集）和 Instrumentation（重构模式）</p>
<ul>
<li>Instrumentation：这是 JProfiler 全功能模式，在 class 加载之前，JProfiler 把相关功能代码写入到需要分析的 class 的 bytecode 中，对正在运行的 JVM 有一定影响。<ul>
<li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li>
<li>缺点：若要分析的 class 较多，则对应用的性能影响较大，CPU 开销可能很高（取决于 Filter 的控制）。因此使用此模式一般配合 Filter 使用，只对特定的类或包进行分析。</li>
</ul>
</li>
<li>Sampling：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。<ul>
<li>优点：对 CPU 的开销非常低，对应用影响小（即使你不配置任何 FIlter）。</li>
<li>缺点：一些数据、特性不能提供（例如：方法的调用次数、执行时间）。</li>
</ul>
</li>
</ul>
<p>注意：JProfiler 本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为 JProfiler 的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是 JProfiler 的数据采集类型。</p>
<p><strong>遥感监测 Telemetries</strong></p>
<p><strong>内存视图 Live Memory</strong></p>
<p>Live Memory 内存剖析：class&#x2F;class instance 的相关信息。例如对象的个数、大小、对象创建的方法执行栈，对象创建的热点。</p>
<ul>
<li><p>所有对象 All Objects</p>
<p>显示所有加载的类的列表和在堆上分配的实例数。只有 Java 1.5（JVMTI）才会显示此视图。</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220514085144635.png" alt="image-20220514085144635"></p>
</li>
<li><p>记录对象 Record Objects</p>
<p>查看特定时间段对象的分配，并记录分配的调用堆栈。</p>
</li>
<li><p>分配访问树 Allocation Call Tree</p>
<p>显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的 J2EE 组件。</p>
</li>
<li><p>分配热点 Allocation Hot Spots</p>
<p>显示一个列表，包括方法、类、包或分配已选类的 J2EE 组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</p>
</li>
<li><p>类追踪器 Class Tracker</p>
<p>类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</p>
</li>
</ul>
<blockquote>
<p>分析：内存中的对象的情况。</p>
<ul>
<li>频繁创建的 Java 对象：死循环、循环次数过多。</li>
<li>存在大的对象：读取文件时，byte[] 应该边读边写。如果长时间不写出的话，导致 byte[] 过大。</li>
<li>存在内存泄漏。</li>
</ul>
</blockquote>
<p><strong>CPU 视图 CPU Views</strong></p>
<p>JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或 J2EE 组件等不同层上。</p>
<ul>
<li><p>访问树 Call Tree</p>
<p>显示一个积累的自顶向下的树，树中包含所有在 JVM 中已记录的访问队列。JDBC、JMS 和 JNDI 服务请求都被注释在请求树中。请求树可以根据 Servlet 和 JSP 对 URL 的不同需要进行拆分。</p>
</li>
<li><p>热点 Hot Spots</p>
<p>显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC、JMS 和 JNDI 服务请求以及按照 URL 请求来进行计算。</p>
</li>
<li><p>访问图 Call Graph</p>
<p>显示一个从已选方法、类、包或 J2EE 组件开始的访问队列的图。</p>
</li>
<li><p>方法统计 Method Statistics</p>
<p>显示一段时间内记录的方法的调用时间细节。</p>
</li>
</ul>
<p><strong>线程视图 Threads</strong></p>
<p>JProfiler 通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现，对线程剖析。</p>
<ul>
<li><p>线程历史 Thread History</p>
<p>显示一个与线程活动和线程状态在一起的活动时间表。</p>
</li>
<li><p>线程监控 Thread Monitor</p>
<p>显示一个列表，包括所有的活动线程以及它们目前的活动状况。</p>
</li>
<li><p>线程转储 Thread Dumps</p>
<p>显示所有线程的堆栈跟踪。</p>
</li>
</ul>
<p>线程分析主要关系三个方面：</p>
<ol>
<li>Web 容器的线程最大数。比如：Tomcat 的线程容量应该略大于最大并发数。</li>
<li>线程阻塞。</li>
<li>线程死锁。</li>
</ol>
<p><strong>监视器&amp;锁 Monitors&amp;Locks</strong></p>
<p>监控和锁 Monitors&amp;Locks 所有线程持有锁 的情况以及锁的信息。</p>
<p>观察 JVM 的内部线程并查看状态：</p>
<ul>
<li>死锁探测图表 Current Locking Graph：显示 JVM 中的当前死锁图表。</li>
<li>目前使用的监测器 Current Monitors：显示目前使用的监测器并且包括它们的关联线程。</li>
<li>锁定历史图表 Locking History Graph：显示记录在 JVM 中的锁定历史。</li>
<li>历史检测记录 Monitor History：显示重大的等待时间和阻塞时间的历史记录。</li>
<li>监控器使用统计 Monitor Usage Statistics：显示分组监测、线程和监测类的统计检测数据。</li>
</ul>
<h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><h3 id="基本概述-4"><a href="#基本概述-4" class="headerlink" title="基本概述"></a>基本概述</h3><p><strong>背景</strong></p>
<p>前面，我们介绍了 JDK 自带的 jVisual VM 等免费工具，以及商业化工具 JProfiler。这两款工具在业界知名度也比较高，它们的优点是可以图形界面上看到各维度的性能数据，使用者根据这些数据进行综合分析，然后判断哪里出现了性能问题。</p>
<p>但是这两款软件也有个缺点，都必须在服务端项目进程中配置相关的监控参数。然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根部连不上线上环境。并且类似于 JProfiler 这样的商业工具，是需要付费的。</p>
<p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？阿里巴巴开源性能分析神器 Arthas（阿尔萨斯）。</p>
<p><strong>概述</strong></p>
<p>Arthas（阿尔萨斯）是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。在线排查问题，无需重启，动态跟踪 Java 代码，实时监控 JVM 状态。</p>
<p>Arthas 支持 JDK 6+，支持 Linux&#x2F;Mac&#x2F;Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p>
<p>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p>
<ul>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到 JVM 的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
</ul>
<p><strong>基于哪些工具开发而来</strong></p>
<ul>
<li>greys-anatomy：Arthas 代码基于 Greys 二次开发而来，非常感谢 Greys 之前所有的工作，以及 Greys 原作者对 Arthas 提出的意见和建议！</li>
<li>termd：Arthas 的命令行实现基于 termd 开发，是一款优秀的命令行程序开发框架，感谢 termd 提供了优秀的框架。</li>
<li>crash：Arthas 的文本渲染功能基于 crash 中的文本渲染功能开发，感谢 crash 在这方面所做的优秀工作。</li>
<li>cli：Arthas 的命令行界面基于 vert.x 提供的 cli 库进行开发，感谢 vert.x 在这方面做的优秀工作。</li>
<li>compiler：Arthas 里的内存编译器代码来源。</li>
<li>Apache Commons Net：Arthas 里的 Telnet Client 代码来源。</li>
<li>JavaAgent：运行在 main 方法之前的拦截器，它内定的方法名叫 premain，也就是说先执行 premain 方法然后再执行 main 方法。</li>
<li>ASM：一个通用的 Java 字节码操作和分析框架。它可以用于修改现有的类或直接以二进制形式动态生成类。ASM 提供了一些常见的字节码转换和分析算法，可以从它们构建定制的复杂转换和代码分析工具。ASM 提供了与其他 Java 字节码框架类似的功能，但是主要关注性能。因为它被设计和实现得尽可能小和快，所以非常适合在动态系统中使用（当然也可以以静态方式使用，例如在编译器中）。</li>
</ul>
<p><strong>官方使用文档：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/zh-cn/">https://arthas.aliyun.com/zh-cn/</a></strong></p>
<h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p><strong>安装</strong></p>
<p>安装方式一：可以直接在 Linux 上通过命令下载。可以咋官方 GitHub 上进行下载，如果速度较慢，可以尝试国内的码云 Gitee 下载。</p>
<ul>
<li>GitHub 下载：<code>wget https://alibaba.github.io/arthas-boot.jar</code></li>
<li>Gitee 下载：<code>wget https://arthas.gitee.io/arthas-boot.jar</code></li>
</ul>
<p>安装方式二：也可以在浏览器直接访问 <a target="_blank" rel="noopener" href="https://alibaba.github.io/arthas/arthas-boot.jar%EF%BC%8C%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E4%B8%8A%E4%BC%A0%E5%88%B0">https://alibaba.github.io/arthas/arthas-boot.jar，等待下载成功后，上传到</a> Linux 服务器上。</p>
<p>卸载：若在 Linux&#x2F;Unix&#x2F;Mac 平台，删除下面的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.arthas/</span><br><span class="line">rm -rf ~/logs/arthas</span><br></pre></td></tr></table></figure>

<p>Windows 平台直接删除 user home 下面的 .arthas 和 logs&#x2F;arthas 目录。</p>
<p><strong>工程目录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arthas-agent：基于 JavaAgent 技术的代理</span><br><span class="line">bin：一些启动脚本</span><br><span class="line">arthas-boot：Java 版本的一键安装启动脚本</span><br><span class="line">arthas-client：Telnet Client 代码</span><br><span class="line">arthas-common：一些公用的工具类和枚举类</span><br><span class="line">arthas-core：核心库，各种 Arthas 命令的交互和实现</span><br><span class="line">arthas-demo：示例代码</span><br><span class="line">arthas-memorycompiler：内存编译器代码，Fork From：https://github.com/skalogs/SkaETL/tree/master/compiler</span><br><span class="line">arthas-packaing：Maven 打包相关</span><br><span class="line">arthas-site：Arthas 站点</span><br><span class="line">arthas-spy：编织到目标类中的各个切面</span><br><span class="line">static：静态资源</span><br><span class="line">arthas-testcase：测试</span><br></pre></td></tr></table></figure>

<p><strong>启动</strong></p>
<p>Arthas 只是一个 Java 程序，所以可以直接使用 java -jar 运行。</p>
<p>执行成功后，Arthas 提供了一种命令行方式的交互方式，Arthas 会检测当前服务器上的 Java 进程，并将进程列表展示出来，用户输入对应的编号（1、2、3、4……）进行选择，然后回车。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方式 1：</span><br><span class="line">java -jar arthas-boot.jar</span><br><span class="line"></span><br><span class="line"># 选择进程（输入[]内编号（不是 PID）回车）</span><br><span class="line">[INFO] arthas-boot version:3.1.4</span><br><span class="line">[INFO] Found existing java process, please choose one and hit RETURN.</span><br><span class="line">* [1]:11616 com.Arthas</span><br><span class="line">  [2]:8676</span><br><span class="line">  [3]:16200 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">  [4]:21032 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">方式 2：运行时选择 Java 进程 PID</span><br><span class="line">java -jar arthas-boot.jar [PID]</span><br></pre></td></tr></table></figure>

<p><strong>查看日志：cat ~&#x2F;logs&#x2F;arthas&#x2F;arthas.log</strong></p>
<p><strong>查看帮助：java -jar arthas-boot.jar -h</strong></p>
<p><strong>Web Console</strong></p>
<p>除了在命令行查看外，Arthas 目前还支持 Web Console。在成功启动连接进程之后就已经自动启动，可以直接访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p>
<p><strong>退出</strong></p>
<p>最后一行 <code>[arthas@7457]$</code>，说明打开进入了监控客户端，在这里就可以执行相关命令进行查看了。</p>
<ul>
<li>使用 quit\exit：退出当前客户端。</li>
<li>使用 stop\shutdown：关闭 Arthas 服务端，并退出所有客户端。</li>
</ul>
<h3 id="相关诊断指令"><a href="#相关诊断指令" class="headerlink" title="相关诊断指令"></a>相关诊断指令</h3><p><strong>基础指令</strong></p>
<p><img src="/master/2023/12/04/JVM-down/image-20220514095949248.png" alt="image-20220514095949248"></p>
<p><strong>JVM 相关</strong></p>
<p><img src="/master/2023/12/04/JVM-down/image-20220514095959764.png" alt="image-20220514095959764"></p>
<p><strong>class&#x2F;classloader 相关</strong></p>
<p><img src="/master/2023/12/04/JVM-down/image-20220514100022509.png" alt="image-20220514100022509"></p>
<p><strong>monitory&#x2F;watch&#x2F;trace 相关</strong></p>
<p><img src="/master/2023/12/04/JVM-down/image-20220514100038644.png" alt="image-20220514100038644"></p>
<p><strong>其它</strong></p>
<p>使用 &gt; 将结果重写到日志文件，使用 &amp; 指令命令是后台运行，session 断开不影响任务执行（生命周期默认为 1 天）。</p>
<p>jobs：列出所有 job。</p>
<p>kill：强制终止任务。</p>
<p>fg：将暂停的任务拉到前台执行。</p>
<p>bg：将暂停的任务放到后台执行。</p>
<p>grep：搜索满足条件的结果。</p>
<p>plaintext：将命令的结果去除 ANSI 颜色。</p>
<p>wc：按行统计输出结果。</p>
<p>options：查看或设置 Arthas 全局开关。</p>
<p>profiler：使用 async-profiler 对应用采样，生成火焰图。</p>
<h2 id="Java-Mission-Control"><a href="#Java-Mission-Control" class="headerlink" title="Java Mission Control"></a>Java Mission Control</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>在 Oracle 收购 Sun 之前，Oracle 的 JRockit 虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。</p>
<p>在 Oracle 收购 Sun 之后，Oracle 公司同时拥有了 Sun HotSpot 和 JRockit 两款虚拟机。根据 Oracle 对于 Java 的战略，在今后的发展中，会将 JRockit 的优秀特性移植到 HotSpot 上。其中，一个重要的改进就是在 Sun 的 JDK 中加入了 JRockit 的支持。</p>
<p>在 Oracle JDK 7u40 之后，Mission Control 这款工具已经绑定在 Oracle JDK 中发布。</p>
<p>自 Java 11 开始，本节介绍的 JFR 已经开源。但在之前的 Java 版本，JFR 属于 Commercial Feature，需要通过 Java 虚拟机参数 <code>-XX:+UnlockCommercialFeatures</code>开启。</p>
<p>如果有兴趣可以查看 OpenJDK 的 Mission Control 项目：<a href="https://github.com/JDKMissionControl/jmc">https://github.com/JDKMissionControl/jmc</a></p>
<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>Mission Control 位于 <code>%JAVA_HOME/bin/jmc.exe</code>，双击即可运行。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Java Mission Control（简称 JMC），Java 官方提供的性能强劲的工具。是一个用于对  Java 应用程序进行管理、监视、概要分析和故常排除的工具套件。</p>
<p>它包含一个 GUI 客户端，以及众多用来收集 Java 虚拟机性能数据的插件，如 JMX Console（能够访问用来存放虚拟机各个子系统运行数据的 MXBeans），以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p>
<p>JMC 的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着 JMC 来做压测（唯一影响可能是 Full GC 多了）。</p>
<h3 id="功能：实时监控-JVM-运行时的状态"><a href="#功能：实时监控-JVM-运行时的状态" class="headerlink" title="功能：实时监控 JVM 运行时的状态"></a>功能：实时监控 JVM 运行时的状态</h3><p>如果是远程服务器，使用前要开 JMX。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote.port=$&#123;YOUR PORT&#125;</span><br><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false</span><br><span class="line">-Djava.rmi.server.hostname=$&#123;YOUR HOST/IP&#125;</span><br><span class="line"></span><br><span class="line">文件--&gt;连接--&gt;创建新连接，填入上面 JMX 参数的 host 和 port</span><br></pre></td></tr></table></figure>

<h3 id="Java-Flight-Recorder"><a href="#Java-Flight-Recorder" class="headerlink" title="Java Flight Recorder"></a>Java Flight Recorder</h3><p><strong>事件类型</strong></p>
<p>当启用时，JFR 将记录运行过程中发生的一系列事件。其中包括 Java 层面的事件，如线程事件、锁事件，以及 Java 虚拟机内部的事件，如新建对象、垃圾回收和即时编译事件。</p>
<p>按照发生时机以及持续时间来划分，JFR 的事件共有四种类型，它们分别为以下四种。</p>
<ol>
<li>瞬时事件（Instant Event），用户关心的是它们发生与否，例如异常、线程启动事件。</li>
<li>持续事件（Duration Event），用户关心的是它们的持续时间，例如垃圾回收事件。</li>
<li>计时事件（Timed Event），是时长超出指定阈值的持续事件。</li>
<li>取样事件（Sample Event），是周期性取样的事件。</li>
</ol>
<p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时间统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法。</p>
<p><strong>启动方式</strong></p>
<ul>
<li><p>方式 1：使用 <code>-XX:StartFlightRecording=参数</code></p>
<p>第一种是在运行目标 Java 程序时添加 <code>-XX:StartFlightRecording=参数</code>。</p>
<p>比如：下面命令中，JFR 将会在 Java 虚拟机启动 5s 后（对应 delay&#x3D;5s）收集数据，持续 20s（对应 duration&#x3D;20s）。当收集完毕后，JFR 会将收集得到的数据保存至指定的文件中（对应 filename&#x3D;myrecording.jfr）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:StartFilghtRecording=delay=5s,duration=20s,filname=myrecording.jfr,settings=profile MyApp</span><br></pre></td></tr></table></figure>

<p>由于 JFR 将持续收集数据，如果不加以限制，那么 JFR 可能会填满硬盘的所有空间。因此，我们有必要对这种模式下所收集的数据进行限制。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:StartFilghtRecording=maxage=10m,maxsiez=100m,name=SomeLabel MyApp</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式 2：使用 jcmd 的 JFR.* 子命令</p>
<p>通过 jcmd 来让 JFR 开始收集数据、停止收集数据，或者保存所收集的数据，对应的子命令分别为 JFR.start、JFR.stop，以及 JFR.dump。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jcmd &lt;PID&gt; JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel</span></span><br></pre></td></tr></table></figure>

<p>上述命令运行之后，目标进程中的 JFR 已经开始收集数据。此时，我们可以通过下述命令来导出已经收集到的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jcmd &lt;PID&gt; JFR.dump name=SomeLabel filename=myrecording.jfr</span></span><br></pre></td></tr></table></figure>

<p>最后，我们可以通过下述命令关闭目标进程中的 JFR：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jcmd &lt;PID&gt; JFR.stop name=SomeLabel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方式 3：JMC 的 JFR 插件</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220514104007455.png" alt="image-20220514104007455"></p>
</li>
</ul>
<p><strong>Java Flight Recorder 取样分析</strong></p>
<p>要采用取样，必须先添加参数：</p>
<ul>
<li><code>-XX:+UnlockCommercialFeatures</code></li>
<li><code>-XX:+FlightRecorder</code></li>
</ul>
<p>取样时间默认 1 分钟，可自行按需调整，事件设置选为 profiling，然后可以设置取样 profile 信息，例如：</p>
<ul>
<li>加上对象数量的统计：Java Virtual Machine -&gt; GC -&gt; Detailed -&gt; Object Count&#x2F;Object Count after GC。</li>
<li>方法调用采样的间隔从 10ms 改为 1ms（但不能低于 1ms，否则会影响性能了）：Java Virtual Machine -&gt; Profiling -&gt; Method Profiling Sample&#x2F;Method Sampling Information。</li>
<li>Socket 与 File 采样，10ms 太久，但即使改为 1ms 也未必能抓住什么，可以干脆取消掉：Java Application -&gt; File Read&#x2F;FileWrite&#x2F;Socket Read&#x2F;Socket Write。</li>
</ul>
<p>然后就开始 Profile，到时间后 Profile 结束，会自动把记录下载回来，在 JMC 中展示。</p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="Flame-Graphs（火焰图）"><a href="#Flame-Graphs（火焰图）" class="headerlink" title="Flame Graphs（火焰图）"></a>Flame Graphs（火焰图）</h3><p>在追求极致性能的场景下，了解你的程序运行过程中 CPU 在干什么很重要，火焰图就是一种非常直观的展示 CPU 在整个生命周期过程中时间分配的工具。</p>
<p>火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用栈中的 CPU 消耗瓶颈。</p>
<p>网上的关于 Java 火焰图的讲解大部分来自于 Brendan Gregg 的博客：<a target="_blank" rel="noopener" href="http://www.brendangregg.com/flamegraphs.html">http://www.brendangregg.com/flamegraphs.html</a></p>
<p><img src="/master/2023/12/04/JVM-down/image-20220514104938454.png" alt="image-20220514104938454"></p>
<p>火焰图，简单通过 x 轴横条宽度来度量时间指标，y 轴代表线程栈的层次。</p>
<h3 id="Tprofiler"><a href="#Tprofiler" class="headerlink" title="Tprofiler"></a>Tprofiler</h3><ul>
<li><p>案例</p>
<p>使用 JDK 自身提供的工具进行 JVM 调优可以将 TPS 由 2.5 提升到 20（提升了 7 倍），并准确定位系统瓶颈。</p>
<p>系统瓶颈有：应用里静态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p>
<p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 TProfiler 来定位这些性能代码，成功解决掉了 GC 过于频繁的性能瓶颈，并最终在上次优化的基础上将 TPS 再提升了 4 倍，即提升到 100。</p>
</li>
<li><p>TProfiler 配置部署、远程操作、日志阅读都不太复杂，操作还是很简单的。但是其却是能够起到一针见血、立竿见影的效果，帮我们解决了 GC 过于频繁的性能瓶颈。</p>
</li>
<li><p>TProfiler 最重要的特性就是能够统计出你指定时间段内 JVM 的 top method，这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRockit 首席开发者 Marcus Hirt 在其私人博客《Low Overhead Method Profiling with Java Mission Control》下的评论中曾明确指出 JRMC 并不支持 TOP 方法的统计。</p>
</li>
<li><p>TProfiler 的下载</p>
<p><a href="https://github.com/alibaba/TProfiler">https://github.com/alibaba/TProfiler</a></p>
</li>
</ul>
<h3 id="BTrace——Java-运行时追踪工具"><a href="#BTrace——Java-运行时追踪工具" class="headerlink" title="BTrace——Java 运行时追踪工具"></a>BTrace——Java 运行时追踪工具</h3><p>常见的动态追踪工具有 BTrace、HouseMD（该项目已经停止开发）、Greys-Anatomy（国人开发，个人开发者）、Byteman（JBoss 出品），注意 Java 运行时追踪工具并不限于这几种，但是这几个是相对比较常用的。</p>
<p>BTrace 是 Sun Kenai 云计算开发平台下的一个开源项目，旨在为 Java 提供安全可靠的动态跟踪分析工具。先看一下 BTrace 的官方定义：</p>
<blockquote>
<p>BTrace is a safe, dynamic tracing tool for the Java platform. BTrace can be used to dynamically trace a running Java program(similar to DTrace for OpenSolaris applications and OS). BTrace dynamically instruments the classes of the target application to inject tracing code(“bytecode tracing”).</p>
</blockquote>
<p>简洁明了，大意是一个 Java 平台的安全的动态追踪工具。可以用来动态地追踪一个运行的 Java 程序。BTrace 动态调整目标应用程序的类以注入追踪代码（”字节码跟踪”）。</p>
<h1 id="JVM运行时参数"><a href="#JVM运行时参数" class="headerlink" title="JVM运行时参数"></a>JVM运行时参数</h1><h2 id="JVM-参数选项类型"><a href="#JVM-参数选项类型" class="headerlink" title="JVM 参数选项类型"></a>JVM 参数选项类型</h2><h3 id="类型一：标准参数选项"><a href="#类型一：标准参数选项" class="headerlink" title="类型一：标准参数选项"></a>类型一：标准参数选项</h3><p><strong>特点</strong></p>
<p>比较稳定，后续版本基本不会变化，以<code>-</code>开头。</p>
<p><strong>各种选项</strong></p>
<p>运行 Java 或者 <code>java -help</code> 可以看到所有的标准选项。</p>
<p><strong>补充内容：-server 与 -client</strong></p>
<p>HotSpot JVM 有两种模式，分别是 server 和 client，分别通过 -server 和 -client 模式设置：</p>
<ol>
<li>在 32 位 Windows 系统上，默认使用 Client 类型的 JVM。要想使用 Server 模式，则机器配置至少有 2 个以上的 CPU 和 2G 以上的物理内存。Client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器。</li>
<li>64 位机器上只支持 Server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器。</li>
</ol>
<p>关于 Server 和 Client 的官网介绍为：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/techontes/guides/vm/server-class.html">https://docs.oracle.com/javase/8/docs/techontes/guides/vm/server-class.html</a></p>
<h3 id="类型二：-X-参数选项"><a href="#类型二：-X-参数选项" class="headerlink" title="类型二：-X 参数选项"></a>类型二：-X 参数选项</h3><p><strong>特点</strong></p>
<p>非标准化参数，功能比较稳定，以 <code>-X</code> 开头。</p>
<p><strong>各种选项</strong></p>
<p>运行 <code>java -X</code> 命令可以看到所有的 X 选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-Xmixed								混合模式执行（默认）</span><br><span class="line">-Xint								仅解释模式执行</span><br><span class="line">-Xcomp								仅采用即时编译器模式</span><br><span class="line">-Xbootclasspath:&lt;用;分隔的目录和 zip/jar 文件&gt;	设置搜索路径以引导类和资源</span><br><span class="line">-Xbootclasspath/a:&lt;用;分隔的目录和 zip/jar 文件&gt;	附加在引导类路径末尾</span><br><span class="line">-Xbootclasspath/p:&lt;用;分隔的目录和 zip/jar 文件&gt;	置于引导类路径之前</span><br><span class="line">-Xdiag								显示附加诊断消息</span><br><span class="line">-Xnoclassgc							禁用类垃圾收集</span><br><span class="line">-Xincgc								启用增量垃圾收集</span><br><span class="line">-Xloggc:&lt;file&gt;						将 GC 状态记录在文件中（带时间戳）</span><br><span class="line">-Xbatch								禁用后台编译</span><br><span class="line">-Xms&lt;size&gt;							设置初始 Java 堆大小</span><br><span class="line">-Xmx&lt;size&gt;							设置最大 Java 堆大小</span><br><span class="line">-Xss&lt;size&gt;							设置 Java 线程堆栈大小</span><br><span class="line">-Xprof								输出 CPU 配置文件数据</span><br><span class="line">-Xfuture							启用最严格的检查，预期将来的默认值</span><br><span class="line">-Xrs								减少 Java/VM 对操作系统信号的使用</span><br><span class="line">-Xcheck:jni							对 JNI 函数执行其他检查</span><br><span class="line">-Xshare:off							不尝试使用共享类数据</span><br><span class="line">-Xshare:auto						在可能的情况下使用共享类数据（默认）</span><br><span class="line">-Xshare:on							要求使用共享类数据，否则将失败</span><br><span class="line">-XshowSettings						显示所有设置并继续</span><br><span class="line">-XshowSettings:all					显示所有设置并继续</span><br><span class="line">-XshowSettings:vm					显示所有与 VM 相关的设置并继续</span><br><span class="line">-XshowSettings:properties			显示所有属性设置并继续</span><br><span class="line">-XshowSettings:locale				显示所有与区域设置相关的设置并继续</span><br></pre></td></tr></table></figure>

<p><strong>JVM 的 JIT 编译模式相关的选项</strong></p>
<ul>
<li><code>-Xint</code>：禁用 JIT，所有字节码都被解释执行，这个模式的速度是最慢的。</li>
<li><code>-Xcomp</code>：所有字节码第一次使用就都被编译成本地代码，然后再执行。</li>
<li><code>-Xmixed</code>：混合模式，默认模式，让 JIT 根据程序运行的情况，有选择地将某些代码编译成本地代码</li>
</ul>
<p><strong>特别地</strong></p>
<p>-Xmx -Xms -Xss 属于 XX 参数？</p>
<ul>
<li><code>-Xms&lt;size&gt;</code>：设置初始 Java 堆大小，等价于 <code>-XX:InitialHeapSize</code>。</li>
<li><code>-Xmx&lt;size&gt;</code>：设置最大 Java 堆大小，等价于 <code>-XX:MaxHeapSize</code>。</li>
<li><code>-Xss&lt;size&gt;</code>：设置 Java 线程堆栈大小，<code>-XX:ThreadStackSize</code>。</li>
</ul>
<h3 id="类型三：-XX-参数选项"><a href="#类型三：-XX-参数选项" class="headerlink" title="类型三：-XX 参数选项"></a>类型三：-XX 参数选项</h3><p><strong>特点</strong></p>
<ul>
<li>非标准化参数</li>
<li>使用的最多的参数类型</li>
<li>实验性选项</li>
<li>以 <code>-XX</code> 开头</li>
</ul>
<p><strong>作用</strong></p>
<p>用于开发和调试 JVM。</p>
<p><strong>分类</strong></p>
<ul>
<li><p>Boolean 类型格式</p>
<ul>
<li><p><code>-XX:+&lt;option&gt;</code> 表示启用 option 属性。</p>
</li>
<li><p><code>-XX:- &lt;option&gt;</code> 表示禁用 option 属性。</p>
</li>
<li><p>说明：因为有的指令默认是开启的，所以可以使用 <code>-</code> 关闭。</p>
<blockquote>
<p>  <code>-XX:+UseParallelGC</code> 选择垃圾收集器为并行收集器</p>
<p>  <code>-XX:+UseG1GC</code> 表示启用 G1 收集器</p>
<p>  <code>-XX:+UseAdaptiveSizePolicy</code> 自动选择年轻代区大小和相应的 Survivor 区比例</p>
</blockquote>
</li>
</ul>
</li>
<li><p>非 Boolean 类型模式（key-value 类型）</p>
<ul>
<li><p>子类型 1：数值型格式 <code>-XX:&lt;option&gt;=&lt;number&gt;</code>。</p>
<blockquote>
<p>  number 表示数值，number 可以带上单位，比如：’m’、’M’ 表示兆，’k’、’K’ 表示 Kb，’g’、’G’ 表示 g</p>
<p>  例如：</p>
<p>  <code>-XX:NewSize=1024m</code>：表示设置新生代初始大小为 1024M。</p>
<p>  <code>-XX:MaxGCPauseMillis=500</code>：表示设置 GC 停顿时间：500 毫秒。</p>
<p>  <code>-XX:GCTimeRatio=19</code>：表示设置吞吐量。</p>
<p>  <code>-XX:NewRatio=2</code>：表示新生代与老年代的比例。</p>
</blockquote>
</li>
<li><p>子类型 2：非数值型格式 <code>-XX:&lt;name&gt;=&lt;string&gt;</code>。</p>
<blockquote>
<p>  <code>-XX:HeapDumpPath=/usr/local/heapdump.hprof</code>：用来指定 Heap 转存文件的存储路径。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>特别地</strong></p>
<ul>
<li><code>-XX:+PrintFlagsFinal</code><ul>
<li>输出所有参数的名称和默认值。</li>
<li>默认不包括 Diagnostic 和 Experimental 的参数。</li>
<li>可以配合 <code>-XX:+UnlockDiagnosticVMOptions</code> 和 <code>-XX:UnlockExperimentalVMOptions</code> 使用。</li>
</ul>
</li>
</ul>
<h2 id="添加-JVM-参数选项"><a href="#添加-JVM-参数选项" class="headerlink" title="添加 JVM 参数选项"></a>添加 JVM 参数选项</h2><h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><h3 id="运行-jar-包"><a href="#运行-jar-包" class="headerlink" title="运行 jar 包"></a>运行 jar 包</h3><p><code>java -Xms50m -Xmx50m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -jar demo.jar</code></p>
<h3 id="通过-Tomcat-运行-war-包"><a href="#通过-Tomcat-运行-war-包" class="headerlink" title="通过 Tomcat 运行 war 包"></a>通过 Tomcat 运行 war 包</h3><ul>
<li>Linux 系统下可以在 tomcat&#x2F;bin&#x2F;catalina.sh 中添加类似如下配置： JAVA_OPTS&#x3D;”-Xms512M -Xmx1024M”。</li>
<li>Windows 系统下在 catalina.bat 中添加类似如下配置： set “JAVA_OPTS&#x3D;Xms512M -Xmx1024M”。</li>
</ul>
<h3 id="程序运行过程中"><a href="#程序运行过程中" class="headerlink" title="程序运行过程中"></a>程序运行过程中</h3><ul>
<li>使用 jinfo -flag <name>&#x3D;<value> <pid> 设置非 Boolean 类型参数。</pid></value></name></li>
<li>使用 jinfo -flag [+ | -] <name> <pid> 设置 Boolean 类型参数。</pid></name></li>
</ul>
<h2 id="常用的-JVM-参数选项"><a href="#常用的-JVM-参数选项" class="headerlink" title="常用的 JVM 参数选项"></a>常用的 JVM 参数选项</h2><h3 id="打印设置的-XX-选项及值"><a href="#打印设置的-XX-选项及值" class="headerlink" title="打印设置的 XX 选项及值"></a>打印设置的 XX 选项及值</h3><ul>
<li><code>-XX:+PrintCommandLineFlags</code>：可以让在程序运行前打印出用户手动设置或者 JVM 自动设置的 XX 选项。</li>
<li><code>-XX:+PrintFlagsInitial</code>：表示打印所有 XX 选项的默认值。</li>
<li><code>-XX:+PrintFlagsFinal</code>：表示打印出 XX 选项在运行程序时生效的值。</li>
<li><code>-XX:+PrintVMOptions</code>：打印 JVM 的参数。</li>
</ul>
<h3 id="堆、栈、方法区等内存大小设置"><a href="#堆、栈、方法区等内存大小设置" class="headerlink" title="堆、栈、方法区等内存大小设置"></a>堆、栈、方法区等内存大小设置</h3><p>栈：</p>
<ul>
<li><code>-Xss128k</code><ul>
<li>设置每个线程的栈大小为 128k。</li>
<li>等价于 <code>-XX:ThreadStackSize=128k</code>。</li>
</ul>
</li>
</ul>
<p>堆内存：</p>
<ul>
<li><code>-Xms3550m</code>：等价于 <code>-XX:InitialHeapSize</code>，设置 JVM 初始堆内存为 3550M。</li>
<li><code>-Xmx3550m</code>：等价于 <code>-XX:MaxHeapSize</code>，设置 JVM 最大堆内存为 3550M。</li>
<li><code>-Xmn2g</code><ul>
<li>设置年轻代大小为 2G。</li>
<li>官方推荐配置为整个堆大小的 3&#x2F;8。</li>
</ul>
</li>
<li><code>-XX:NewSize=1024m</code>：设置年轻代初始值为 1024M。</li>
<li><code>-XX:MaxNewSize=1024m</code>：设置年轻代最大值为 1024M。</li>
<li><code>-XX:SurvivorRatio=8</code>：设置年轻代中 Eden 区与一个 Survivor 区的比值，默认为 8。</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：自动选择各区大小比例。</li>
<li><code>-XX:NewRatio=4</code>：设置老年代与年轻代（包括 1 个 Eden 和 2 个 Survivor 区）的比值。</li>
<li><code>-XX:PretenureSizeThreadshold=1024</code><ul>
<li>设置让大于此阈值的对象直接分配在老年代，单位为字节。</li>
<li>只对 Serial、ParNew 收集器有效。</li>
</ul>
</li>
<li><code>-XX:MaxTenuringThreshold=15</code><ul>
<li>默认值为 15。</li>
<li>新生代每次 MinorGC 后，还存活的对象年龄 +1，当对象的年龄大于设置的这个值时就进入老年代。</li>
</ul>
</li>
<li><code>-XX:+PrintTenuringDistribution</code>：让 JVM 在每次 MinorGC 后打印出当前使用的 Survivor 中对象的年龄分布。</li>
<li><code>-XX:TargetSurvivoRatio</code>：表示 MinorGC 结束后 Survivor 区域中占用空间的期望比例。</li>
</ul>
<p>方法区：</p>
<ul>
<li>永久代：<ul>
<li><code>-XX:PermSize=256m</code>：设置永久代初始值为 256M。</li>
<li><code>-XX:MaxPermSize=256m</code>：设置永久代最大值为 256M。</li>
</ul>
</li>
<li>元空间：<ul>
<li><code>-XX:MetaspaceSize</code>：初始空间大小。</li>
<li><code>-XX:MaxMetaspaceSize</code>：最大空间，默认没有限制。</li>
<li><code>-XX:+UseCompressedOops</code>：压缩对象指针。</li>
<li><code>-XX:CompressedClassSpaceSize</code>：设置 Class Metaspace 的大小，默认 1G。</li>
</ul>
</li>
</ul>
<p>直接内存：</p>
<ul>
<li><code>-XX:MaxDirectMemorySize</code>：指定 DirectMemory 容量，若未指定，则默认与 Java 堆最大值一样。</li>
</ul>
<h3 id="OutOfMemory-相关的选项"><a href="#OutOfMemory-相关的选项" class="headerlink" title="OutOfMemory 相关的选项"></a>OutOfMemory 相关的选项</h3><ul>
<li><p><code>-XX:+HeapDumpOnOutOfMemoryError</code>：表示在内存出现 OOM 的时候，把 Heap 转存（Dump）到文件以便后续分析。</p>
</li>
<li><p><code>-XX:+HeapDumpBeforeFullGC</code>：表示在出现 FullGC 之前，生成 Heap 转储文件。</p>
</li>
<li><p><code>-XX:HeapDumpPath=&lt;path&gt;</code>：指定 Heap 转存文件的存储路径。</p>
</li>
<li><p><code>-XX:OnOutOfMemoryError</code>：指定一个可行性程序或者脚本的路径，当发生 OOM 的时候，去执行这个脚本。</p>
<blockquote>
<p>对 OnOutOfMemoryError 的运维处理</p>
<p>以部署在 Linux 系统 &#x2F;opt&#x2F;Server 目录下的 Server.jar 为例</p>
<ol>
<li>在 run.sh 启动脚本添加 JVM 参数：<code>-XX:OnOutOfMemoryError=/opt/Server/restart.sh</code></li>
<li>restart.sh 脚本</li>
</ol>
<p>Linux 环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">pid=$&#123;ps -ef | grep Server.jar | awk &#x27;&#123;if($8==&quot;java&quot;) &#123;print $2&#125;&#125;&#x27;&#125;</span><br><span class="line">kill -9 pid</span><br><span class="line">cd /opt/Server/;sh run.sh</span><br></pre></td></tr></table></figure>

<p>Windows 环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo off</span><br><span class="line">wmic process where Name=&#x27;java.exe&#x27; delete</span><br><span class="line">cd D:\Server</span><br><span class="line">start run.bat</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="垃圾收集器相关选项"><a href="#垃圾收集器相关选项" class="headerlink" title="垃圾收集器相关选项"></a>垃圾收集器相关选项</h3><p>7 款经典垃圾收集器与垃圾分代之间的关系：</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220516214737624.png" alt="image-20220516214737624"></p>
<p>垃圾收集器的组合关系：</p>
<p><img src="/master/2023/12/04/JVM-down/image-20220516214822458.png" alt="image-20220516214822458"></p>
<ul>
<li><p>查看默认垃圾收集器</p>
<ul>
<li><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）。</li>
<li>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 PID</code>。</li>
</ul>
</li>
<li><p>Serial 回收器</p>
<blockquote>
<p>  Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾回收器。Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器。</p>
<p>  <code>-XX:+UseSerialGC</code>：指定年轻代和老年代都使用串行回收器。等价于新生代用 Serial GC，且老年代用 Serial Old GC。可以获得最高的单线程收集效率。</p>
</blockquote>
</li>
<li><p>ParNew 回收器</p>
<blockquote>
<p>  <code>-XX:+UseParNewGC</code>：手动指定使用 ParNew 回收器执行内存回收任务。它表示年轻代使用并行回收器，不影响老年代。</p>
<p>  <code>-XX:ParallelGCThreads=N</code>：限制线程数量，默认开启和 CPU 数据相同的线程数。</p>
</blockquote>
</li>
<li><p>Parallel 回收器</p>
<blockquote>
<ul>
<li><p><code>-XX:+UseParallelGC</code>：手动指定年轻代使用 Parallel 并行回收器执行内存回收任务。</p>
</li>
<li><p><code>-XX:+UseParallelOldGC</code>：手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li>分别适用于新生代和老年代。默认 JDK 8 是开启的。</li>
<li>上面两个参数，默认开启一个，另一个也会被开启。（相互激活）</li>
</ul>
</li>
<li><p><code>-XX:ParallelGCThread</code>：设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<ul>
<li>在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 的数量。</li>
<li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU_Count]&#x2F;8。</li>
</ul>
</li>
<li><p><code>-XX:MaxGCPauseMillis</code>：设置垃圾回收器最大停顿时间（即 STW 的时间）。单位是毫秒。</p>
<ul>
<li>为了尽可能地把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li>
<li>该参数使用需谨慎。</li>
</ul>
</li>
<li><p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例 （&#x3D;1&#x2F;(N+1)）。用于衡量吞吐量的大小。</p>
<ul>
<li>取值范围 (0,100)。默认值 99，也就是垃圾回收时间不超过 1%。</li>
<li>与前一个 <code>-XX:MaxGCPauseMillis </code>参数有一定矛盾性，暂停时间越长，Ratio 参数就容易超过设定的比例。</li>
</ul>
</li>
<li><p><code>-XX:+UseAdaptiveSizePolicy</code>：设置 Parallel Scavenge 收集器具有自适应调节策略。</p>
<ul>
<li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>CMS 回收器</p>
<blockquote>
<ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：手动指定使用 CMS 收集器执行内存回收任务。<ul>
<li>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开。即：ParNew（Young 区用）+CMS（Old 区用）+Serial Old 的组合。</li>
</ul>
</li>
<li><code>-XX:CMSInitiatingOccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。<ul>
<li>JDK 5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次 CMS 回收。JDK 6 及以上版本默认值为 92%。</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Full GC 的执行次数。</li>
</ul>
</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：设置在执行多少次 Full GC 后对内存空间进行压缩整理。</li>
<li><code>-XX:ParallelCMSThreads</code>：设置 CMS 的线程数量。<ul>
<li>CMS 默认启动的线程数是（ParallelGCThreads+3）&#x2F;4，ParallelGCThreads 是年轻代并行收集器的线程数，当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<p>  另外，CMS 收集器还有如下常用参数：</p>
<ul>
<li><code>-XX:ConcGCThreads</code>：设置并发垃圾收集的线程数，默认该值是基于 ParallelGCThreads 计算出来的。</li>
<li><code>-XX:+UseCMSInitiatingOccupancyOnly</code>：是否动态可调，用这个参数可以使 CMS 一直按 CMSInitiatingOccupancyFraction 设定的值启动。</li>
<li><code>-XX:+CMSScavengeBeforeRemark</code>：强制 HotSpot 虚拟机在 CMS Remark 阶段之前做一次 Minor GC，用于提高 Remark 阶段的速度。</li>
<li><code>-XX:+CMSClassUnloadingEnable</code>：如果有的话，启用回收 Perm 区（JDK 8 之前）。</li>
<li><code>-XX:+CMSParallelInitialEnabled</code>：用于开启 CMS Initial-Mark 阶段采用多线程的方式进行标记，用于提高标记速度，在 Java 8 开始已经默认开启。</li>
<li><code>-XX:+CMSParallelRemarkEnables</code>：用户开启 CMS Remark 阶段采用多线程的方式进行重新标记，默认开启。</li>
<li><code>-XX:+ExplicitGCInvokesConcurrent</code>、<code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code>：这两个参数用户指定 HotSpot 虚拟机在执行 System.gc() 时使用 CMS 周期。</li>
<li><code>-XX:+CMSPrecleaningEnabled</code>：指定 CMS 是否需要进行 Pre Cleaning 这个阶段。</li>
</ul>
<p>  特别说明：</p>
<ul>
<li>JDK 9 新特性：CMS 被标记为 Deprecate（JEP291）<ul>
<li>如果对 JDK 9 及以上版本的 HotSpot 虚拟机使用参数 <code>-XX:+UseConcMarkSweepGC</code> 来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li>
</ul>
</li>
<li>JDK 14 新特性：删除 CMS 垃圾回收器（JEP363）<ul>
<li>移除了 CMS 垃圾回收器，如果在 JDK 14 中使用 <code>-XX:+UseConcMarkSweepGC</code> 的话，JVM 不会报错，只是给出一个 Warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>G1 回收器</p>
<blockquote>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用 G1 收集器执行内存回收任务。</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1&#x2F;2000。</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms。</li>
<li><code>-XX:ParallelGCThread</code>：设置 STW 时 GC 线程数的值，最多设置为 8。</li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1&#x2F;4 左右。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li>
<li><code>-XX:G1NewSizePercent、-XX:G1MaxNewSizePercent</code>：新生代占用整个堆内存的最小百分比（默认 5%）、最大百分比（默认 60%）。</li>
<li><code>-XX:G1ReservePercent=10</code>：保留内存区域，防止 To Space（Survivor 中的 To 区）溢出。</li>
</ul>
<p>  注意：G1 收集器主要涉及到 Mixed GC，Mixed GC 会回收 Young 区和部分 Old 区。</p>
<p>  G1 关于 Mixed GC 调优常用参数：</p>
<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置堆占用率的百分比（0 到 100）达到这个数值的时候触发 Global Concurrent Marking（全局并发标记），默认为 45%。值为 0 表示间断进行全局并发标记。</li>
<li><code>-XX:G1MixedGCLiveThreadholdPercent</code>：设置 Old 区的 Region 被回收时候的对象占比，默认占用率 85%。只有 Old 区的 Region 中存活的对象占用达到了这个百分比，才会在 Mixed GC 中被回收。</li>
<li><code>-XX:G1HeapWastePercent</code>：在 Global Concurrent Marking（全局并发标记）结束之后，可以知道所有的区有多少空间要被回收，在每次 Young GC 之后和再次发生 Mixed GC 之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生 Mixed GC。</li>
<li><code>-XX:G1MixedGCCountTarget</code>：一次 Global Concurrent Marking（全局并发标记）之后，最多执行 Mixed GC 的次数，默认是 8。</li>
<li><code>-XX:G1OldGCSetRegionThresholdPercent</code>：设置 Mixed GC 收集周期中要收集的 Old Region 数的上限。默认值是 Java 堆的 10%。</li>
</ul>
</blockquote>
</li>
<li><p>怎么选择垃圾回收器</p>
<blockquote>
<ul>
<li>优先调整堆的大小让 JVM 自适应完成。</li>
<li>如果内存小于 100M，使用串行收集器。</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，使用串行收集器。</li>
<li>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择。</li>
<li>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器。官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1。</li>
</ul>
<p>  特别说明：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集器；</li>
<li>调优永远都是针对特定场景、特定需要，不存在一劳永逸的收集器。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="GC-日志相关选项"><a href="#GC-日志相关选项" class="headerlink" title="GC 日志相关选项"></a>GC 日志相关选项</h3><ul>
<li><code>-verbose:gc</code>：输出 GC 日志信息，默认输出到标准输出。</li>
<li><code>-XX:+PrintGC</code>：等同于 <code>-verbose:gc</code> 表示打开简化的 GC 日志。</li>
<li><code>-XX:+PrintGCDetails</code>：在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况。</li>
<li><code>-XX:+PrintGCTimeStamps</code>：输出 GC 发生时的时间戳。</li>
<li><code>-XX:+PrintGCDateStamps</code>：输出 GC 发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800。</li>
<li><code>-XX:+PrintHeapAtGC</code>：每一次 GC 前和 GC 后，都打印堆信息。</li>
<li><code>-Xloggc:&lt;file&gt;</code>：把 GC 日志写入到一个文件夹中去，而不是打印到标准输出中。</li>
<li><code>-XX:+TraceClassLoading</code>：监控类的加载。</li>
<li><code>-XX:+PrintGCApplicationStoppedTime</code>：打印 GC 时线程的停顿时间。</li>
<li><code>-XX:+PrintReferenceGC</code>：记录回收了多少种不同引用类型的引用。</li>
<li><code>-XX:+UseGCLogFileRotation</code>：启用 GC 日志文件的自动转储。</li>
<li><code>-XX:+PrintTenuringDistribution</code>：让 JVM 在每次 Minor GC 后打印出当前使用的 Survivor 中对象的年龄分布。</li>
<li><code>-XX:NumberOfGClogFiles=1</code>：GC 日志文件的循环数目。</li>
<li><code>-XX:GCLogFileSize=1M</code>：控制 GC 日志文件的大小。</li>
</ul>
<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><ul>
<li><code>-XX:+DisableExplicitGC</code>：禁止 HotSpot 执行 System.gc()，默认禁用。</li>
<li><code>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]</code>：指定代码缓存的大小。</li>
<li><code>-XX:+UseCodeCacheFlushing</code>：使用该参数让 JVM 放弃一些被编译的代码，避免代码缓存被占满时 JVM 切换到 Interpreted-only 的情况。</li>
<li><code>-XX:+DoEscapeAnalysis</code>：开启逃逸分析。</li>
<li><code>-XX:+UseBiasedLocking</code>：开启偏向锁。</li>
<li><code>-XX:+UseLargePages</code>：开启使用大页面。</li>
<li><code>-XX:+UseTLAB</code>：使用 TLAB，默认打开。</li>
<li><code>-XX:+PrintTLAB</code>：打印 TLAB 的使用情况。</li>
<li><code>-XX:TLABSize</code>：设置 TLAB 大小。</li>
</ul>
<h2 id="通过-Java-代码获-JVM-参数"><a href="#通过-Java-代码获-JVM-参数" class="headerlink" title="通过 Java 代码获 JVM 参数"></a>通过 Java 代码获 JVM 参数</h2><p>Java 提供了 java.lang.management 包用于监视和管理 Java 虚拟机和 Java 运行时中的其他组件，它允许本地和远程监控和管理运行的 Java 虚拟机。其中 ManagementFactory 这个类还是挺常用的。另外还有 Runtime 类也可以获取一些内存、CPU 核数等相关问题。</p>
<p>通过这些 API 可以监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryMonitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MemoryMXBean</span> <span class="variable">memorymbean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();</span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">usage</span> <span class="operator">=</span> memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n Full Information: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(<span class="string">&quot;No-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line">        System.out.println(<span class="string">&quot;============通过 Java 来获取相关系统状态============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前堆内存大小 TotalMemory：&quot;</span> + (<span class="type">int</span>)Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;空闲堆内存大小 FreeMemory：&quot;</span> + (<span class="type">int</span>)Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大可用总堆内存 MaxMemory：&quot;</span> + (<span class="type">int</span>)Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回 Java 虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 返回 Java 虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx: &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms: &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分析GC日志"><a href="#分析GC日志" class="headerlink" title="分析GC日志"></a>分析GC日志</h1><h2 id="GC-日志参数"><a href="#GC-日志参数" class="headerlink" title="GC 日志参数"></a>GC 日志参数</h2><ul>
<li><code>-verbose:gc</code>：输出 GC 日志信息，默认输出到标准输出。</li>
<li><code>-XX:+PrintGC</code>：输出 GC 日志。类似：<code>-verbose:gc</code>。</li>
<li><code>-XX:+PrintGCDetails</code>：在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况。</li>
<li><code>-XX:+PrintGCTimeStamps</code>：输出 GC 发生时的时间戳。</li>
<li><code>-XX:+PrintGCDateStamps</code>：输出 GC 发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.534+0800）。</li>
<li><code>-XX:+PrintHeapAtGC</code>：每一次 GC 前和 GC 后，都打印堆信息。</li>
<li><code>-Xloggc:&lt;file&gt;</code>：表示把 GC 日志写入到一个文件中去，而不是打印到标准输出中。</li>
</ul>
<h2 id="GC-日志格式"><a href="#GC-日志格式" class="headerlink" title="GC 日志格式"></a>GC 日志格式</h2><h3 id="GC-分类"><a href="#GC-分类" class="headerlink" title="GC 分类"></a>GC 分类</h3><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆手机（Full GC）。</p>
<ul>
<li>部分收集：不是完整收集整个 Java 堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代（Eden &#x2F; S0 &#x2F; S1）的垃圾收集。</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集。<ul>
<li>目前，只有 CMS GC 会有单独收集老年代的行为。</li>
<li>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有 G1 GC 会有这种行为。</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</li>
</ul>
<h3 id="GC-日志分类"><a href="#GC-日志分类" class="headerlink" title="GC 日志分类"></a>GC 日志分类</h3><ul>
<li><p>Minor GC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 31744K -&gt; 2192K(36864K)]</span><br><span class="line">31744K -&gt; 2200K(121856K), 0.0139308 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Full GC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K -&gt; 0K(132096K)]</span><br><span class="line">[ParOldGen: 416K -&gt; 5453K(50176K)] 5520K -&gt; 5453K(182272K), [MetaSpace:</span><br><span class="line">20637K -&gt; 20637K(106700)]， 0.0245883 secs] [Times: user=0.06 sys=0.00,</span><br><span class="line">real=0.02 secs]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="GC-日志结构剖析"><a href="#GC-日志结构剖析" class="headerlink" title="GC 日志结构剖析"></a>GC 日志结构剖析</h3><ul>
<li><p>垃圾收集器</p>
<blockquote>
<ul>
<li>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是”[DefNew”。</li>
<li>使用 ParNew 收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”。</li>
<li>使用 Parallel Scavenge 收集器在新生代的名字是”[PSYoungGen”，这里的 JDK 1.7 使用的就是 PSYoungGen。</li>
<li>使用 Parallel Old Generation 收集器在老年代的名字是”[ParOldGen”。</li>
<li>使用 G1 收集器的话，会显示为”Garbage-First Heap”。</li>
</ul>
<p>  Allocation Failure：表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
</blockquote>
</li>
<li><p>GC 前后情况</p>
<blockquote>
<p>  可以发现 GC 日志格式的规律一般都是：GC 前内存占用 -&gt; GC 后内存占用（该区域内存总大小）</p>
<p>  [PSYoungGen: 5986K -&gt; 696K(8704K)] 5986K -&gt; 704K(9216K)</p>
<p>  中括号内：GC 回收前年轻代堆大小，回收后大小。（年轻代堆总大小）</p>
<p>  括号外：GC 回收前年轻代和老年代大小，回收后大小。（年轻代和老年代总大小）</p>
</blockquote>
</li>
<li><p>GC 时间</p>
<blockquote>
<p>  GC 日志中有三个时间：user、sys 和 real</p>
<ul>
<li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</li>
<li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的的 CPU 时间。</li>
<li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I&#x2F;O 完成）。对于并行 GC，这个数字应该接近（用户时间+系统时间）除以垃圾收集器使用的线程数。</li>
</ul>
<p>  由于多核的原因，一般的 GC 事件中，Real Time 是小于 sys + user time 的，因为一般是多个线程并发的去做 GC，所以 Real Time 是要小于 sys + user time 的。如果 real &gt; sys + user 的话，则你的应用可能存在下列问题：IO 负载非常重或者是 CPU 不够用。</p>
</blockquote>
</li>
</ul>
<h3 id="Minor-GC-日志解析"><a href="#Minor-GC-日志解析" class="headerlink" title="Minor GC 日志解析"></a>Minor GC 日志解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-11-20T17:19:43.265-0800:0.822:[GC (ALLOCATION FAILURE) [PSYOUNGGEN:</span><br><span class="line">76800k -&gt; 8433K(89600K)] 76800K -&gt; 8449K(294400K), 0.0088371 SECS [TIMES:</span><br><span class="line">USER=0.02 SYS=0.01, REAL=0.01 SECS]]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>2020-11-20T17:19:43.265-0800：日志打印时间日期格式。</li>
<li>0.822:：GC 发生时，Java 虚拟机启动以来经过的秒数。</li>
<li>GC (ALLOCATION FAILURE)：发生了一次垃圾回收，这是一次 Minor GC。它不区分新生代 GC 还是老年代 GC，括号里的内容是 GC 发生的原因，这里的 Allocation Failure 的原因是新生代中没有足够区域能够存放需要分配的数据而失败。</li>
<li>[PSYOUNGGEN:76800k -&gt; 8433K(89600K)]：<ul>
<li>PSYoungGen：表示 GC 发生的区域，区域名称与使用的 GC 收集器是密切相关的。<ul>
<li>Serial 收集器：Default New Generation 显示 DefNew。</li>
<li>ParNew 收集器：ParNew。</li>
<li>Parallel Scanvenge 收集器：PSYoung，老年代和新生代同理，也是和收集器名称相关。</li>
</ul>
</li>
<li>76800k -&gt; 8433K(89600K)：GC 前该内存区域已使用容量 -&gt; GC 后该区域容量（该区域总容量）。<ul>
<li>如果是新生代，总容量则会显示整个新生代内存的 9&#x2F;10，即 Eden + From&#x2F;To 区。</li>
<li>如果是老年代，总容量则是全部内存大小，无变化。</li>
</ul>
</li>
</ul>
</li>
<li>76800K -&gt; 8449K(294400K)：在显示完区域容量 GC 的情况之后，会接着显示整个堆内存区域的 GC 情况：GC 前堆内存已使用容量 -&gt; GC 堆内存容量（堆内存总容量）堆内存总容量 &#x3D; 9&#x2F;10 新生代 + 老年代 &lt; 初始化的内存大小。</li>
<li>0.0088371 SECS：整个 GC 所花费的时间，单位是秒。</li>
<li>[TIMES:USER&#x3D;0.02 SYS&#x3D;0.01, REAL&#x3D;0.01 SECS]：<ul>
<li>user：指的是 CPU 工作在用户态所花费的时间。</li>
<li>sys：指的是 CPU 工作在内核态所花费的时间。</li>
<li>real：指的是在此次 GC 事件中所花费的总时间。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Full-GC-日志解析"><a href="#Full-GC-日志解析" class="headerlink" title="Full GC 日志解析"></a>Full GC 日志解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-11-20T17:19:43.794-0800: 1.351: [FULL GC (METADATA GC THRESHOLD)</span><br><span class="line">[PSYOUNGGEN:10082K -&gt; 0K(89600K)] [PAROLDGEN: 32K -&gt; 9638K(204800K)]</span><br><span class="line">10114K -&gt; 9638K(294400K),</span><br><span class="line">[METASPACE: 20158K -&gt; 20156K(1067008K)], 0.0285388 SECS] [TIMES: USER=0.11 SYS=0.0, REAL=0.03 SECS]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>2020-11-20T17:19:43.794-0800：日志打印时间日期格式。</li>
<li>1.351：GC 发生时，Java 虚拟机启动以来经过的秒数。</li>
<li>FULL GC (METADATA GC THRESHOLD)：发生了一次垃圾回收，这是一次 FULL GC。它不区分新生代 GC 还是老年代 GC。括号里的内容是 GC 发生的原因，这里的 Metadata GC Threshold 的原因是 Metaspace 区不够用了。<ul>
<li>Full GC（Ergonomics）：JVM 自适应调整导致的 GC。</li>
<li>Full GC（System）：调整了 System.gc() 方法。</li>
</ul>
</li>
<li>[PSYOUNGGEN:10082K -&gt; 0K(89600K)]：<ul>
<li>PSYoungGen：表示 GC 发生的区域，区域名称与使用的 GC 收集器是密切相关的。<ul>
<li>Serial 收集器：Default New Generation 显示 DefNew。</li>
<li>ParNew 收集器：ParNew。</li>
<li>Parallel Scanvenge 收集器：PSYoung，老年代和新生代同理，也是和收集器名称相关。</li>
</ul>
</li>
<li>10082K -&gt; 0K(89600K)：GC 前该内存区域已使用容量 -&gt; GC 后该区域容量（该区域总容量）。<ul>
<li>如果是新生代，总容量则会显示整个新生代内存的 9&#x2F;10，即 Eden + From&#x2F;To 区。</li>
<li>如果是老年代，总容量则是全部内存大小，无变化。</li>
</ul>
</li>
</ul>
</li>
<li>[PAROLDGEN: 32K -&gt; 9638K(204800K)]：老年代区域没有发生 GC，因为本次 GC 是 Metaspace 引起的。</li>
<li>10114K -&gt; 9638K(294400K)：在显示完区域容量 GC 的情况之后，会接着显示整个堆内存区域的 GC 情况：GC 前堆内存已使用容量 -&gt; GC 堆内存容量（堆内存总容量）堆内存总容量 &#x3D; 9&#x2F;10 新生代 + 老年代 &lt; 初始化的内存大小。</li>
<li>[METASPACE: 20158K -&gt; 20156K(1067008K)]：Metaspace GC 回收 2K 空间。</li>
<li>0.0285388 SECS：整个 GC 所花费的时间，单位是秒。</li>
<li>[TIMES:USER&#x3D;0.11 SYS&#x3D;0.00, REAL&#x3D;0.03 SECS]：<ul>
<li>user：指的是 CPU 工作在用户态所花费的时间。</li>
<li>sys：指的是 CPU 工作在内核态所花费的时间。</li>
<li>real：指的是在此次 GC 事件中所花费的总时间。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="GC-日志分析工具"><a href="#GC-日志分析工具" class="headerlink" title="GC 日志分析工具"></a>GC 日志分析工具</h2><p>上节介绍了 GC 日志的打印及含义，但是 GC 日志看起来比较麻烦，本节将会介绍一下 GC 日志可视化分析工具 GCeasy 和 GCViewer 等。通过 GC 日志可视化分析工具，我们可以很方便的看到 JVM 各个分代的内存使用情况、垃圾回收次数、垃圾回收的原因、垃圾回收占用的时间、吞吐量等，这些指标在我们进行 JVM 调优的时候是很有用的。</p>
<p>如果想把 GC 日志存到文件的话，是下面这个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:/path/to/gc.log</span><br></pre></td></tr></table></figure>

<p>然后就可以用一些工具去分析这些 GC 日志。</p>
<h3 id="GCeasy"><a href="#GCeasy" class="headerlink" title="GCeasy"></a>GCeasy</h3><ul>
<li><p>基本概念：</p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://gceasy.io/%EF%BC%8CGCeasy">https://gceasy.io/，GCeasy</a> 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄漏检测、GC 暂停原因分析、JVM 配置建议优化等功能，而且是可以免费使用的（有一些服务是收费的）。</p>
</li>
</ul>
<h3 id="GCViewer"><a href="#GCViewer" class="headerlink" title="GCViewer"></a>GCViewer</h3><ul>
<li><p>基本概念</p>
<p>上面介绍了一款在线的 GC 日志分析器，下面介绍一个离线版的 GCViewer。GCViewer 是一个免费的、开源的分析小工具，用于可视化查看由 SUN&#x2F;Oracle、IBM、HP 和 BEA Java 虚拟机产生的垃圾收集器的日志。GCViewer 用于可视化 Java VM 选项 <code>-verbose:gc</code> 和 .NET 生成的数据 <code>-Xloggc:&lt;file&gt;</code>。它还计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p>
</li>
<li><p>安装</p>
<ul>
<li><p>下载 GCViewer 工具</p>
<blockquote>
<p>  源码下载：<a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></p>
<p>  运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p>
</blockquote>
</li>
<li><p>只需双击 gcviewer-1.3x.jar 或运行 java -jar gcviewer-1.3x.jar（它需要运行 Java 1.8 VM），即可启动 GCViewer（GUI）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="其他工具-1"><a href="#其他工具-1" class="headerlink" title="其他工具"></a>其他工具</h3><ul>
<li><p>GChisto</p>
<p>GChisto 是一款专业分析 GC 日志的工具，可以通过 GC 日志来分析：Minor GC、Full GC 的次数、频率、持续时间等，通过列表、报表、图表等不同形式来反应 GC 的情况。</p>
</li>
<li><p>HPjmeter</p>
<p>工具很强大，但只能打开由一下参数生成的 GC log，<code>-verbose:gc、-Xloggc:gc.log</code>。添加其他参数生成的 gc.log 无法打开。HPjmeter 集成了以前的 HPjtune 功能，可以分析在 HP 机器上产生的垃圾回收日志文件。</p>
</li>
</ul>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://github.com/hjianming/hjianming.github.io">HUANG jm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/hjianming/hjianming.github.io/2023/12/04/JVM-down/">https://github.com/hjianming/hjianming.github.io/2023/12/04/JVM-down/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/hjianming/hjianming.github.io" target="_blank">HUANGjm 's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=1609519678,2974733914&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/04/JVM-mid/" title="JVM中篇：字节码与类的加载篇"><img class="cover" src="https://img1.baidu.com/it/u=1124169842,3402755948&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-04</div><div class="title">JVM中篇：字节码与类的加载篇</div></div></a></div><div><a href="/2023/12/04/JVM-up/" title="JVM上篇：内存与垃圾回收篇"><img class="cover" src="https://img2.baidu.com/it/u=4088804987,3950260204&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-04</div><div class="title">JVM上篇：内存与垃圾回收篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img0.baidu.com/it/u=494257227,1085354721&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUANG jm</div><div class="author-info__description">越努力越幸运</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！这里是我的学习生活分享!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">性能调优概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">大厂面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">背景说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">生产环境中的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E4%BC%98%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">为什么要调优？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">不同阶段的考虑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.</span> <span class="toc-text">调优概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E7%9A%84%E4%BE%9D%E6%8D%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">监控的依据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E7%9A%84%E5%A4%A7%E6%96%B9%E5%90%91"><span class="toc-number">1.3.2.</span> <span class="toc-text">调优的大方向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.4.</span> <span class="toc-text">性能优化的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%E6%B5%8B%E8%AF%95%E6%8C%87%E6%A0%87"><span class="toc-number">1.5.</span> <span class="toc-text">性能评价测试指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%EF%BC%88%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">停顿时间（响应时间）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%95%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">并发数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">内存占用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BA%92%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.5.</span> <span class="toc-text">相互间的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">JVM监控及诊断工具-命令行篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">2.1.1.</span> <span class="toc-text">简单命令行工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jps%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-Java-%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">jps：查看正在运行的 Java 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jstat%EF%BC%9A%E6%9F%A5%E7%9C%8B-JVM-%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.</span> <span class="toc-text">jstat：查看 JVM 统计信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">2.3.3.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jinfo%EF%BC%9A%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9-JVM-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">jinfo：实时查看和修改 JVM 配置参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-2"><span class="toc-number">2.4.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-number">2.4.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">拓展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jmap%EF%BC%9A%E5%AF%BC%E5%87%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6-amp-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.5.</span> <span class="toc-text">jmap：导出内存映像文件&amp;内存使用的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-3"><span class="toc-number">2.5.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="toc-number">2.5.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1%EF%BC%9A%E5%AF%BC%E5%87%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-number">2.5.3.</span> <span class="toc-text">使用 1：导出内存映像文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-2%EF%BC%9A%E6%98%BE%E7%A4%BA%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-number">2.5.4.</span> <span class="toc-text">使用 2：显示堆内存相关信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3%EF%BC%9A%E5%85%B6%E4%BB%96%E4%BD%9C%E7%94%A8"><span class="toc-number">2.5.5.</span> <span class="toc-text">使用 3：其他作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.5.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jhat%EF%BC%9AJDK-%E8%87%AA%E5%B8%A6%E5%A0%86%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">2.6.</span> <span class="toc-text">jhat：JDK 自带堆分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-4"><span class="toc-number">2.6.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="toc-number">2.6.2.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jstack%EF%BC%9A%E6%89%93%E5%8D%B0-JVM-%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7"><span class="toc-number">2.7.</span> <span class="toc-text">jstack：打印 JVM 中线程快照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-5"><span class="toc-number">2.7.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-5"><span class="toc-number">2.7.2.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jcmd%EF%BC%9A%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-number">2.8.</span> <span class="toc-text">jcmd：多功能命令行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-6"><span class="toc-number">2.8.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-6"><span class="toc-number">2.8.2.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jstatd%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-number">2.9.</span> <span class="toc-text">jstatd：远程主机信息收集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">JVM监控及诊断工具-GUI篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">工具概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JConsole"><span class="toc-number">3.2.</span> <span class="toc-text">JConsole</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">三种连接方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">主要作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Visual-VM"><span class="toc-number">3.3.</span> <span class="toc-text">Visual VM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">基本概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">3.3.2.</span> <span class="toc-text">插件的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">连接方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">3.3.4.</span> <span class="toc-text">主要功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eclipse-MAT"><span class="toc-number">3.4.</span> <span class="toc-text">Eclipse MAT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">基本概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A0%86-dump-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text">获取堆 dump 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%A0%86-dump-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.3.</span> <span class="toc-text">分析堆 dump 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">再谈内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">3.5.1.</span> <span class="toc-text">内存泄露的理解与分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84-8-%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">3.5.2.</span> <span class="toc-text">Java 中内存泄漏的 8 种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8-OQL-%E8%AF%AD%E8%A8%80%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">3.5.3.</span> <span class="toc-text">支持使用 OQL 语言查询对象信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JProfiler"><span class="toc-number">3.6.</span> <span class="toc-text">JProfiler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-3"><span class="toc-number">3.6.1.</span> <span class="toc-text">基本概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">3.6.2.</span> <span class="toc-text">安装与配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">3.6.3.</span> <span class="toc-text">具体使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arthas"><span class="toc-number">3.7.</span> <span class="toc-text">Arthas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-4"><span class="toc-number">3.7.1.</span> <span class="toc-text">基本概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">3.7.2.</span> <span class="toc-text">安装与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E8%AF%8A%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="toc-number">3.7.3.</span> <span class="toc-text">相关诊断指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Mission-Control"><span class="toc-number">3.8.</span> <span class="toc-text">Java Mission Control</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">3.8.1.</span> <span class="toc-text">历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-1"><span class="toc-number">3.8.2.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.8.3.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%EF%BC%9A%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7-JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.8.4.</span> <span class="toc-text">功能：实时监控 JVM 运行时的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Flight-Recorder"><span class="toc-number">3.8.5.</span> <span class="toc-text">Java Flight Recorder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><span class="toc-number">3.9.</span> <span class="toc-text">其他工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flame-Graphs%EF%BC%88%E7%81%AB%E7%84%B0%E5%9B%BE%EF%BC%89"><span class="toc-number">3.9.1.</span> <span class="toc-text">Flame Graphs（火焰图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tprofiler"><span class="toc-number">3.9.2.</span> <span class="toc-text">Tprofiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTrace%E2%80%94%E2%80%94Java-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%BF%BD%E8%B8%AA%E5%B7%A5%E5%85%B7"><span class="toc-number">3.9.3.</span> <span class="toc-text">BTrace——Java 运行时追踪工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">JVM运行时参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">JVM 参数选项类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%80%EF%BC%9A%E6%A0%87%E5%87%86%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-number">4.1.1.</span> <span class="toc-text">类型一：标准参数选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BA%8C%EF%BC%9A-X-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-number">4.1.2.</span> <span class="toc-text">类型二：-X 参数选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%89%EF%BC%9A-XX-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-number">4.1.3.</span> <span class="toc-text">类型三：-XX 参数选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-JVM-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-number">4.2.</span> <span class="toc-text">添加 JVM 参数选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Eclipse"><span class="toc-number">4.2.1.</span> <span class="toc-text">Eclipse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDEA"><span class="toc-number">4.2.2.</span> <span class="toc-text">IDEA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C-jar-%E5%8C%85"><span class="toc-number">4.2.3.</span> <span class="toc-text">运行 jar 包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Tomcat-%E8%BF%90%E8%A1%8C-war-%E5%8C%85"><span class="toc-number">4.2.4.</span> <span class="toc-text">通过 Tomcat 运行 war 包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD"><span class="toc-number">4.2.5.</span> <span class="toc-text">程序运行过程中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-JVM-%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-number">4.3.</span> <span class="toc-text">常用的 JVM 参数选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%AE%BE%E7%BD%AE%E7%9A%84-XX-%E9%80%89%E9%A1%B9%E5%8F%8A%E5%80%BC"><span class="toc-number">4.3.1.</span> <span class="toc-text">打印设置的 XX 选项及值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%AD%89%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.3.2.</span> <span class="toc-text">堆、栈、方法区等内存大小设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutOfMemory-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-number">4.3.3.</span> <span class="toc-text">OutOfMemory 相关的选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E5%85%B3%E9%80%89%E9%A1%B9"><span class="toc-number">4.3.4.</span> <span class="toc-text">垃圾收集器相关选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3%E9%80%89%E9%A1%B9"><span class="toc-number">4.3.5.</span> <span class="toc-text">GC 日志相关选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.6.</span> <span class="toc-text">其他参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Java-%E4%BB%A3%E7%A0%81%E8%8E%B7-JVM-%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">通过 Java 代码获 JVM 参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%9E%90GC%E6%97%A5%E5%BF%97"><span class="toc-number">5.</span> <span class="toc-text">分析GC日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GC-%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">GC 日志参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">GC 日志格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E5%88%86%E7%B1%BB"><span class="toc-number">5.2.1.</span> <span class="toc-text">GC 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E6%97%A5%E5%BF%97%E5%88%86%E7%B1%BB"><span class="toc-number">5.2.2.</span> <span class="toc-text">GC 日志分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90"><span class="toc-number">5.2.3.</span> <span class="toc-text">GC 日志结构剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC-%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="toc-number">5.2.4.</span> <span class="toc-text">Minor GC 日志解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-GC-%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="toc-number">5.2.5.</span> <span class="toc-text">Full GC 日志解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">5.3.</span> <span class="toc-text">GC 日志分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GCeasy"><span class="toc-number">5.3.1.</span> <span class="toc-text">GCeasy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCViewer"><span class="toc-number">5.3.2.</span> <span class="toc-text">GCViewer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-1"><span class="toc-number">5.3.3.</span> <span class="toc-text">其他工具</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/JUC/" title="JAVA并发编程"><img src="https://img0.baidu.com/it/u=2673111999,852452608&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=450" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAVA并发编程"/></a><div class="content"><a class="title" href="/2024/03/18/JUC/" title="JAVA并发编程">JAVA并发编程</a><time datetime="2024-03-18T03:21:56.656Z" title="发表于 2024-03-18 11:21:56">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/06/SkyTakeOut/" title="麦老头炸鸡"><img src="https://img1.baidu.com/it/u=3286805665,73344517&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1200&amp;h=639" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="麦老头炸鸡"/></a><div class="content"><a class="title" href="/2024/03/06/SkyTakeOut/" title="麦老头炸鸡">麦老头炸鸡</a><time datetime="2024-03-06T13:34:03.024Z" title="发表于 2024-03-06 21:34:03">2024-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/07/SpringCloudUtility/" title="SpringCloud实用篇"><img src="https://img2.baidu.com/it/u=3840651282,2081575526&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud实用篇"/></a><div class="content"><a class="title" href="/2023/12/07/SpringCloudUtility/" title="SpringCloud实用篇">SpringCloud实用篇</a><time datetime="2023-12-07T07:29:54.944Z" title="发表于 2023-12-07 15:29:54">2023-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/04/JVM-mid/" title="JVM中篇：字节码与类的加载篇"><img src="https://img1.baidu.com/it/u=1124169842,3402755948&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM中篇：字节码与类的加载篇"/></a><div class="content"><a class="title" href="/2023/12/04/JVM-mid/" title="JVM中篇：字节码与类的加载篇">JVM中篇：字节码与类的加载篇</a><time datetime="2023-12-04T14:49:36.899Z" title="发表于 2023-12-04 22:49:36">2023-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/04/JVM-up/" title="JVM上篇：内存与垃圾回收篇"><img src="https://img2.baidu.com/it/u=4088804987,3950260204&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM上篇：内存与垃圾回收篇"/></a><div class="content"><a class="title" href="/2023/12/04/JVM-up/" title="JVM上篇：内存与垃圾回收篇">JVM上篇：内存与垃圾回收篇</a><time datetime="2023-12-04T14:38:15.904Z" title="发表于 2023-12-04 22:38:15">2023-12-04</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By HUANG jm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>